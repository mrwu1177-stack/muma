<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åŠ å¯†è´§å¸å¼‚åŠ¨ç›‘æ§ä¸­å¿ƒ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --bg-primary: #f0f9ff;
      --bg-secondary: #e0f2fe;
      --text-primary: #000000;
      --text-secondary: #1e293b;
      --border-color: #e2e8f0;
      --accent-gradient: linear-gradient(to right, #0ea5e9, #06b6d4);
      --header-bg: linear-gradient(to right, #e0f2fe, #bae6fd);
      --header-text: #000000;
    }

    /* æš—è‰²ä¸»é¢˜å˜é‡ */
    .dark {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --text-primary: #ffffff;
      --text-secondary: #f1f5f9;
      --border-color: #334155;
      --accent-gradient: linear-gradient(to right, #1e40af, #0891b2);
      --header-bg: linear-gradient(to right, #1e3a5f, #0f3d46);
      --header-text: #ffffff;
    }

    body {
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-primary) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      margin: 0;
      padding: 0;
      transition: background 0.3s ease, color 0.3s ease;
    }

    .animate-pulse {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: .5; }
    }
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
    .overflow-x-auto::-webkit-scrollbar {
      height: 6px;
    }
    .overflow-x-auto::-webkit-scrollbar-track {
      background: rgba(203, 213, 225, 0.3);
      border-radius: 3px;
    }
    .overflow-x-auto::-webkit-scrollbar-thumb {
      background: rgba(56, 189, 248, 0.5);
      border-radius: 3px;
    }
    .overflow-x-auto::-webkit-scrollbar-thumb:hover {
      background: rgba(56, 189, 248, 0.7);
    }

    /* æš—è‰²ä¸»é¢˜æ»šåŠ¨æ¡ */
    .dark .overflow-x-auto::-webkit-scrollbar-track {
      background: rgba(51, 65, 85, 0.3);
    }
    .dark .overflow-x-auto::-webkit-scrollbar-thumb {
      background: rgba(56, 189, 248, 0.5);
    }

    /* å¡ç‰‡æ‚¬åœæ•ˆæœ */
    .card-hover {
      transition: all 0.3s ease;
    }
    .card-hover:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(56, 189, 248, 0.3);
      border-color: rgba(56, 189, 248, 0.5);
    }
    /* æ¸å˜è¾¹æ¡†åŠ¨ç”» */
    @keyframes border-glow {
      0%, 100% { border-color: rgba(56, 189, 248, 0.3); }
      50% { border-color: rgba(56, 189, 248, 0.6); }
    }
    .border-glow {
      animation: border-glow 3s ease-in-out infinite;
    }

    /* æš—è‰²ä¸»é¢˜å¡ç‰‡æ ·å¼ */
    .dark .bg-white\/80 {
      background: rgba(30, 41, 59, 0.8) !important;
      border-color: #334155 !important;
    }

    /* æ–°é—»å¡ç‰‡æ ·å¼ */
    .news-card-image {
      width: 100%;
      height: 120px;
      object-fit: cover;
      border-radius: 8px;
      margin-bottom: 0.75rem;
    }

    .news-card {
      min-height: 140px;
    }

    .news-card-with-image {
      min-height: 260px;
    }


    .dark .bg-gradient-to-r.from-sky-100.to-cyan-100 {
      background: linear-gradient(to right, #1e3a5f, #0f3d46) !important;
      border-color: #334155 !important;
    }

    .dark .text-slate-600,
    .dark .text-slate-500,
    .dark .text-slate-400 {
      color: #94a3b8 !important;
    }

    .dark .text-slate-800,
    .dark .text-slate-700 {
      color: #f1f5f9 !important;
    }

    .dark .text-slate-900 {
      color: #ffffff !important;
    }

    .dark .bg-white\/60 {
      background: rgba(30, 41, 59, 0.6) !important;
    }

    .dark .border-slate-200,
    .dark .border-slate-300 {
      border-color: #334155 !important;
    }

    .dark .bg-slate-50 {
      background: #1e293b !important;
    }

    .dark .bg-slate-100 {
      background: #334155 !important;
    }

    /* æš—è‰²ä¸»é¢˜æŒ‰é’®æ ·å¼ */
    .dark button {
      color: #f1f5f9;
    }

    /* æš—è‰²ä¸»é¢˜ä¸‹çš„SVGå›¾æ ‡ */
    .dark svg {
      color: #ffffff;
    }

    /* äº®è‰²ä¸»é¢˜ - ç¡®ä¿æ‰€æœ‰ä¸»è¦æ–‡å­—éƒ½æ˜¯é»‘è‰² */
    h1, h2, h3, .text-slate-800, .text-slate-700, .text-slate-600, .text-slate-900,
    body h1, body h2, body h3 {
      color: #000000 !important;
    }

    /* äº®è‰²ä¸»é¢˜ - æ¬¡è¦æ–‡å­—ç”¨æ·±ç°è‰² */
    .text-slate-500, .text-slate-400 {
      color: #1e293b !important;
    }

    /* æš—è‰²ä¸»é¢˜ä¸‹çš„æ‰€æœ‰æ–‡å­—å¼ºåˆ¶ç™½è‰²ï¼ˆé™¤äº†ä»·æ ¼é¢œè‰²ï¼‰ */
    .dark h1,
    .dark h2,
    .dark h3,
    .dark .text-slate-800,
    .dark .text-slate-700,
    .dark .text-slate-600,
    .dark .text-slate-900,
    .dark span:not(.text-green-500):not(.text-red-500):not(.text-emerald-500):not(.text-rose-500):not(.text-green-400):not(.text-red-400):not(.text-yellow-700):not(.text-yellow-300):not(.text-cyan-500):not(.text-cyan-400),
    .dark p,
    .dark div:not(.bg-gradient-to-r):not([id*="Indicator"]):not(#anomalyContent):not(#anomalySignalsTable) {
      color: #ffffff !important;
    }

    /* Header å†…éƒ¨å…ƒç´ èƒŒæ™¯è‰²é€‚é… */
    #apiStatus, #themeToggle, .flex.gap-2 a {
      background: rgba(255, 255, 255, 0.2) !important;
    }

    .dark #apiStatus, .dark #themeToggle, .dark .flex.gap-2 a {
      background: rgba(255, 255, 255, 0.15) !important;
    }

    .dark #apiStatusText,
    .dark #themeToggle span,
    .dark .flex.gap-2 a span {
      color: #ffffff !important;
    }

    .dark .bg-slate-50 {
      background: #1e293b !important;
    }

    .dark .bg-slate-100 {
      background: #334155 !important;
    }

    /* æš—è‰²ä¸»é¢˜æŒ‰é’®æ ·å¼ */
    .dark button {
      color: #f1f5f9;
    }
  </style>
</head>
<body class="min-h-screen">
  <div class="container mx-auto px-3 py-4 max-w-7xl flex flex-col min-h-screen">
    <!-- Header -->
    <header id="mainHeader" class="rounded-2xl p-3 mb-3 shadow-lg shrink-0" style="background: var(--header-bg); color: var(--header-text);">
      <div class="flex items-center gap-3">
        <span class="text-xl font-bold">HelloYan</span>
        <div id="apiStatus" class="flex items-center gap-1.5 px-2 py-0.5 bg-white/20 rounded-lg text-xs">
          <div id="apiStatusIndicator" class="w-1.5 h-1.5 rounded-full bg-yellow-400 animate-pulse"></div>
          <span id="apiStatusText">APIè¿æ¥ä¸­</span>
        </div>
        <button id="themeToggle" class="flex items-center justify-center w-9 h-9 bg-white/20 rounded-lg hover:bg-white/30 transition-all" title="åˆ‡æ¢ä¸»é¢˜">
          <svg id="sunIcon" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/>
          </svg>
          <svg id="moonIcon" class="w-5 h-5 hidden" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-3.03 0-5.5-2.47-5.5-5.5 0-1.82.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/>
          </svg>
        </button>
      </div>
      <div id="progressBar" class="mt-2 h-1 bg-white/20 rounded-full overflow-hidden hidden">
        <div id="progressFill" class="h-full bg-white/80 transition-all duration-300" style="width: 0%"></div>
      </div>
    </header>

    <!-- Main Grid -->
    <div class="grid grid-cols-1 gap-3 overflow-hidden flex-1">
      <!-- æ¿å—1: å¼‚åŠ¨ä¿¡å·ç›‘æ§ -->
      <div id="anomaly-section" class="bg-white/80 backdrop-blur-sm rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col flex-none">
        <div class="p-2 bg-gradient-to-r from-sky-100 to-cyan-100 border-b border-slate-200 shrink-0">
          <div class="flex items-center justify-between flex-wrap gap-2">
            <div class="flex items-center gap-2">
              <div class="w-7 h-7 bg-gradient-to-br from-sky-500 to-cyan-500 rounded-lg flex items-center justify-center text-white text-sm">
                ğŸ¯
              </div>
              <div>
                <h2 class="text-sm font-semibold text-slate-800">ä¿¡å·ç›‘æ§</h2>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <!-- æ ‡ç­¾é¡µåˆ‡æ¢ -->
              <div class="flex gap-1 bg-slate-200/50 rounded-lg p-0.5">
                <button id="tabAnomaly" onclick="switchSignalTab('anomaly')" class="px-2 py-1 text-xs rounded transition-all bg-sky-500 text-white">
                  å¼‚åŠ¨ç›‘æ§
                </button>
              </div>
              <!-- APIé€‰æ‹©å™¨ -->
              <select id="apiSelector" onchange="switchApiProvider()" class="px-2 py-1 bg-slate-200 border border-slate-300 rounded-lg text-xs text-slate-700 focus:outline-none focus:ring-2 focus:ring-sky-500">
                <option value="bybit">Bybit</option>
                <option value="okx">OKX</option>
                <option value="binance">Binance</option>
              </select>
              <div id="anomalyStatusIndicator" class="w-2 h-2 rounded-full bg-yellow-400 animate-pulse"></div>
              <span id="anomalyStatus" class="text-xs text-slate-400">åˆ†æä¸­</span>
              <span id="anomalyLastUpdate" class="text-xs text-slate-400">æ›´æ–°: --</span>
            </div>
          </div>
        </div>

        <!-- æ‰«æç»Ÿè®¡ä¿¡æ¯ -->
        <div id="analysisStats" class="hidden px-2 py-1.5 bg-slate-100/50 border-b border-slate-200 shrink-0">
          <div class="flex items-center gap-3 text-xs flex-wrap">
            <div class="flex items-center gap-1">
              <span class="text-slate-500">æ‰«æ:</span>
              <span id="scannedCount" class="text-slate-800 font-semibold">0</span>
            </div>
            <div class="flex items-center gap-1">
              <span class="text-slate-500">åˆ†æ:</span>
              <span id="analyzedCount" class="text-slate-800 font-semibold">0</span>
            </div>
            <div class="flex items-center gap-1">
              <span class="text-slate-500">ä¿¡å·:</span>
              <span id="totalSignals" class="text-sky-500 font-semibold">0</span>
            </div>
            <div class="h-3 w-px bg-slate-300"></div>
            <div class="flex items-center gap-1">
              <span class="text-slate-500">ä¸»æ‹‰:</span>
              <span id="mainUpCount" class="text-green-600 font-semibold">0</span>
            </div>
            <div class="flex items-center gap-1">
              <span class="text-slate-500">ä¸»ç ¸:</span>
              <span id="mainDownCount" class="text-red-500 font-semibold">0</span>
            </div>
            <div class="h-3 w-px bg-slate-300"></div>
            <div class="flex items-center gap-1">
              <span class="text-slate-500">èµ„æ‹‰:</span>
              <span id="fundUpCount" class="text-emerald-600 font-semibold">0</span>
            </div>
            <div class="flex items-center gap-1">
              <span class="text-slate-500">èµ„ç ¸:</span>
              <span id="fundDownCount" class="text-pink-600 font-semibold">0</span>
            </div>
          </div>
        </div>

        <div class="p-2 overflow-hidden flex flex-col">
          <!-- å¼‚åŠ¨ç›‘æ§æ ‡ç­¾é¡µå†…å®¹ -->
          <div id="anomalyTabContent" class="flex flex-col">
            <div id="anomalyLoading" class="text-center py-3 text-slate-400 shrink-0">
              <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-sky-500 mx-auto mb-1"></div>
              æ­£åœ¨åˆ†æå¸‚åœºå¼‚åŠ¨...
            </div>
            <div id="anomalyEmpty" class="hidden text-center py-3 text-slate-400 shrink-0">
              æš‚æ— å¼‚åŠ¨ä¿¡å·ï¼Œç­‰å¾…æ£€æµ‹...
            </div>
            <div id="anomalyContent" class="hidden overflow-x-auto" style="max-height: 500px;">
              <table class="w-full text-xs">
                <thead>
                  <tr class="bg-slate-100/50">
                    <th class="px-2 py-2 text-left font-semibold text-slate-600 cursor-pointer hover:bg-slate-200" onclick="sortAnomalySignals('symbol')">
                      åç§° <span id="sortSymbol"></span>
                    </th>
                    <th class="px-2 py-2 text-left font-semibold text-slate-600">ä¿¡å·</th>
                    <th class="px-2 py-2 text-left font-semibold text-slate-600">æ”¾é‡æ•°æ®</th>
                    <th class="px-2 py-2 text-left font-semibold text-slate-600 cursor-pointer hover:bg-slate-200" onclick="sortAnomalySignals('price')">
                      ä»·æ ¼ <span id="sortPrice"></span>
                    </th>
                    <th class="px-2 py-2 text-left font-semibold text-slate-600 cursor-pointer hover:bg-slate-200" title="æ³¢æµªå‘¨æœŸæˆäº¤é‡ï¼ˆå¾€å‰48æ ¹Kçº¿æœ€é«˜ç‚¹åˆ°ä½ç‚¹æˆ–æœ€ä½ç‚¹åˆ°æœ€é«˜ç‚¹ï¼‰" onclick="sortAnomalySignals('volume')">
                      æˆäº¤é‡(48hæ³¢æµª) <span id="sortVolume"></span>
                    </th>
                    <th class="px-2 py-2 text-left font-semibold text-slate-600 cursor-pointer hover:bg-slate-200" onclick="sortAnomalySignals('change')">
                      24å°æ—¶æ¶¨è·Œå¹… <span id="sortChange"></span>
                    </th>
                    <th class="px-2 py-2 text-left font-semibold text-slate-600">èµ„é‡‘è´¹ç‡</th>
                    <th class="px-2 py-2 text-left font-semibold text-slate-600">æŒä»“é‡</th>
                    <th class="px-2 py-2 text-left font-semibold text-slate-600 cursor-pointer hover:bg-slate-200" onclick="sortAnomalySignals('time')">
                      æ—¶é—´ <span id="sortTime"></span>
                    </th>
                  </tr>
                </thead>
                <tbody id="anomalySignalsTable">
                </tbody>
              </table>
            </div>
          </div>

      <!-- æ¿å—2: æ–°é—»ç»¼åˆ -->
      <div id="news-section" class="bg-white/80 backdrop-blur-sm rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col flex-none" style="min-height: 250px; max-height: 400px;">
        <div class="p-2 bg-gradient-to-r from-sky-100 to-cyan-100 border-b border-slate-200 shrink-0">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-2">
              <div class="w-7 h-7 bg-gradient-to-br from-sky-500 to-cyan-500 rounded-lg flex items-center justify-center text-white text-sm">
                ğŸ“°
              </div>
              <h2 class="text-sm font-semibold text-slate-800">æ–°é—»ç»¼åˆ</h2>
            </div>
            <div class="flex items-center gap-1">
              <button id="tabLatest" onclick="switchTab('latest')" class="px-2 py-1 rounded-lg text-xs font-medium transition-all bg-sky-500 text-white">æœ€æ–°</button>
              <button id="tabHot" onclick="switchTab('hot')" class="px-2 py-1 rounded-lg text-xs font-medium transition-all bg-slate-200 text-slate-600 hover:bg-slate-300">çƒ­é—¨</button>
              <button id="tabKol" onclick="switchTab('kol')" class="px-2 py-1 rounded-lg text-xs font-medium transition-all bg-slate-200 text-slate-600 hover:bg-slate-300">KOL</button>
            </div>
          </div>
        </div>

        <div class="p-2 flex-1 overflow-hidden flex flex-col" style="min-height: 200px; max-height: 350px;">
          <div id="newsLoading" class="text-center py-3 text-slate-400 shrink-0">åŠ è½½ä¸­...</div>
          <div id="newsEmpty" class="hidden text-center py-3 text-slate-400 shrink-0">æš‚æ— æ•°æ®</div>
          <div id="newsContent" class="hidden flex-1 overflow-y-auto">
            <!-- çƒ­é—¨å¿«è®¯ - 2Ã—2ç½‘æ ¼ -->
            <div id="contentHot" class="hidden grid grid-cols-2 gap-2">
            </div>
            <!-- æœ€æ–°å¿«è®¯ - 2Ã—2ç½‘æ ¼ -->
            <div id="contentLatest" class="grid grid-cols-2 gap-2">
            </div>
            <!-- KOLè§‚ç‚¹ - 2Ã—2ç½‘æ ¼ -->
            <div id="contentKol" class="hidden grid grid-cols-2 gap-2">
            </div>
          </div>
        </div>
      </div>

      <!-- ç»¼åˆä¿¡æ¯é¢æ¿ -->
      <div class="bg-white/80 backdrop-blur-sm rounded-xl shadow-sm border border-slate-200 overflow-hidden shrink-0">
        <div class="p-2 bg-gradient-to-r from-sky-100 to-cyan-100 border-b border-slate-200">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-2">
              <div class="w-7 h-7 bg-gradient-to-br from-sky-500 to-cyan-500 rounded-lg flex items-center justify-center text-white text-sm">
                ğŸ”¥
              </div>
              <h2 class="text-sm font-semibold text-slate-800">å¸‚åœºçƒ­åº¦</h2>
            </div>
            <div class="flex items-center gap-2 ml-auto">
              <span id="marketDataLastUpdate" class="text-xs text-slate-400">æ›´æ–°: --</span>
              <button onclick="refreshMarketData()" class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded-lg text-xs text-slate-700 transition-colors">
                ğŸ”„
              </button>
            </div>
          </div>
        </div>

        <div class="p-2 overflow-hidden">
          <!-- å¸‚åœºçƒ­åº¦å†…å®¹ -->
          <div id="contentTrending" class="grid grid-cols-3 gap-3">
            <!-- çƒ­é—¨æœç´¢ -->
            <div class="bg-slate-50 rounded-lg p-3 border border-slate-200 overflow-hidden">
              <div class="text-xs text-slate-500 mb-2 flex items-center gap-1 shrink-0">
                ğŸ”¥ çƒ­é—¨æœç´¢TOP10
              </div>
              <div id="marketTrending" class="space-y-1 text-xs overflow-y-auto" style="max-height: 340px;">
                <div class="text-black text-center py-3">åŠ è½½ä¸­...</div>
              </div>
            </div>

            <!-- 24hæ¶¨å¹…æ¦œ -->
            <div class="bg-slate-50 rounded-lg p-3 border border-slate-200 overflow-hidden">
              <div class="text-xs text-black mb-2 flex items-center gap-1 shrink-0">
                ğŸ“ˆ 24hæ¶¨å¹…æ¦œTOP10
              </div>
              <div id="topGainers" class="space-y-1 text-xs overflow-y-auto" style="max-height: 340px;">
                <div class="text-black text-center py-3">åŠ è½½ä¸­...</div>
              </div>
            </div>

            <!-- 24hæˆäº¤é‡æ¦œ -->
            <div class="bg-slate-50 rounded-lg p-3 border border-slate-200 overflow-hidden">
              <div class="text-xs text-black mb-2 flex items-center gap-1 shrink-0">
                ğŸ’¹ 24hæˆäº¤é‡æ¦œTOP10
              </div>
              <div id="topVolume" class="space-y-1 text-xs overflow-y-auto" style="max-height: 340px;">
                <div class="text-black text-center py-3">åŠ è½½ä¸­...</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      </div>


    </div>

    <!-- ç›‘æ§æ—¥å¿—é¢æ¿ -->
    <div class="bg-white/80 backdrop-blur-sm rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col shrink-0 mt-3" style="max-height: 225px; min-height: 150px;">
      <div class="p-2 bg-gradient-to-r from-sky-100 to-cyan-100 border-b border-slate-200 shrink-0">
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-2">
            <div class="w-7 h-7 bg-gradient-to-br from-sky-500 to-cyan-500 rounded-lg flex items-center justify-center text-white text-sm">
              ğŸ“‹
            </div>
            <div>
              <h2 class="text-sm font-semibold text-slate-800">ç›‘æ§æ—¥å¿—</h2>
              <p class="text-xs text-slate-400">å®æ—¶æ˜¾ç¤ºAPIè°ƒç”¨çŠ¶æ€å’Œç³»ç»Ÿä¿¡æ¯</p>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <!-- æ—¥å¿—ç­›é€‰æŒ‰é’® -->
            <div class="flex bg-slate-200/50 rounded-lg p-0.5">
              <button onclick="filterLogs('all')" id="filterAll" class="px-2 py-1 text-xs bg-sky-500 text-white rounded transition-all">å…¨éƒ¨</button>
              <button onclick="filterLogs('normal')" id="filterNormal" class="px-2 py-1 text-xs text-slate-500 hover:bg-slate-300 rounded transition-all">æ­£å¸¸</button>
              <button onclick="filterLogs('error')" id="filterError" class="px-2 py-1 text-xs text-red-500 hover:bg-red-100 rounded transition-all">æŠ¥é”™</button>
              <button onclick="filterLogs('warning')" id="filterWarning" class="px-2 py-1 text-xs text-amber-500 hover:bg-amber-100 rounded transition-all">é”™è¯¯æç¤º</button>
            </div>
            <div class="w-px h-4 bg-slate-300"></div>
            <button onclick="clearLogs()" class="px-2 py-1 rounded-lg text-xs bg-slate-200 text-slate-500 hover:bg-slate-300 transition-all">
              æ¸…ç©ºæ—¥å¿—
            </button>
            <button onclick="clearAllHistory()" class="px-2 py-1 rounded-lg text-xs bg-red-100 text-red-500 hover:bg-red-200 transition-all" title="æ¸…é™¤æ‰€æœ‰å†å²æ•°æ®ï¼ˆä¿¡å·ã€æ–°é—»ã€æ—¥å¿—ï¼‰">
              æ¸…é™¤å†å²
            </button>
            <button onclick="toggleLogs()" id="logToggleBtn" class="px-2 py-1 rounded-lg text-xs bg-slate-200 text-slate-500 hover:bg-slate-300 transition-all">
              å±•å¼€
            </button>
          </div>
        </div>
      </div>
      <div id="logContainer" class="p-2 flex-1 overflow-y-auto font-mono text-xs hidden" style="background: rgba(248, 250, 252, 0.8);">
        <!-- æ—¥å¿—å†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
      </div>
    </div>

    <!-- API Key é…ç½®æ¨¡æ€æ¡† -->
    <div id="apiKeyModal" class="fixed inset-0 z-50 hidden flex items-center justify-center" style="background: rgba(0,0,0,0.5);">
      <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 border border-slate-200 shadow-2xl">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-bold text-slate-800">Followin API é…ç½®</h3>
          <button onclick="hideApiKeyConfig()" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
        </div>
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-slate-600 mb-2">API Key</label>
            <input
              type="text"
              id="apiKeyInput"
              placeholder="è¯·è¾“å…¥æ‚¨çš„Followin API Key"
              class="w-full px-3 py-2 bg-slate-100 border border-slate-300 rounded-lg text-slate-700 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
            />
            <button
              onclick="useDefaultApiKey()"
              class="mt-2 text-xs text-sky-500 hover:text-sky-600 underline"
            >
              ä½¿ç”¨é»˜è®¤API Key
            </button>
          </div>
          <div class="text-xs text-slate-500 space-y-1">
            <p>ğŸ’¡ è·å–API Keyï¼š</p>
            <p>1. è®¿é—® <a href="https://followin.io" target="_blank" class="text-sky-500 hover:underline">followin.io</a> å®˜ç½‘</p>
            <p>2. æ³¨å†Œ/ç™»å½•è´¦å·</p>
            <p>3. åœ¨ä¸ªäººä¸­å¿ƒ/å¼€å‘è€…ä¸­å¿ƒè·å–API Key</p>
            <p class="text-green-600 mt-2">âœ… å½“å‰å·²é¢„ç½®é»˜è®¤API Keyï¼Œå¯æ­£å¸¸ä½¿ç”¨</p>
            <p class="text-amber-600 mt-1">âš ï¸ API Keyå°†ä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­ï¼Œè¯·å‹¿æ³„éœ²</p>
          </div>
          <button
            onclick="saveApiKey()"
            class="w-full bg-gradient-to-r from-sky-500 to-cyan-500 hover:from-sky-600 hover:to-cyan-600 text-white font-medium py-2 px-4 rounded-lg transition-all"
          >
            ä¿å­˜é…ç½®
          </button>
          <button
            onclick="hideApiKeyConfig()"
            class="w-full bg-slate-200 hover:bg-slate-300 text-slate-600 font-medium py-2 px-4 rounded-lg transition-all"
          >
            å–æ¶ˆ
          </button>
        </div>
      </div>
    </div>

    <!-- æ–°é—»å…¨æ–‡å¼¹çª— -->
    <div id="newsDetailModal" class="fixed inset-0 z-50 hidden flex items-center justify-center" style="background: rgba(0,0,0,0.5);" onclick="hideNewsDetail()">
      <div class="bg-white rounded-xl p-6 max-w-2xl w-full mx-4 border border-slate-200 shadow-2xl max-h-[85vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-bold text-slate-800" id="newsDetailTitle">æ–°é—»æ ‡é¢˜</h3>
          <button onclick="hideNewsDetail()" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
        </div>
        <div class="space-y-4">
          <div class="flex items-center gap-2 flex-wrap text-sm">
            <span id="newsDetailTime" class="text-slate-400">å‘å¸ƒæ—¶é—´</span>
            <span id="newsDetailSource" class="px-2 py-1 bg-sky-100 text-sky-600 rounded-md font-medium">æ¥æº</span>
          </div>
          <div id="newsDetailContent" class="text-slate-600 text-sm leading-relaxed whitespace-pre-wrap">
            æ–°é—»å†…å®¹
          </div>
          <div id="newsDetailTags" class="flex items-center gap-2 flex-wrap text-xs">
          </div>
          <button
            onclick="hideNewsDetail()"
            class="w-full bg-slate-200 hover:bg-slate-300 text-slate-600 font-medium py-2 px-4 rounded-lg transition-all mt-4"
          >
            å…³é—­
          </button>
        </div>
      </div>
    </div>

    <!-- å¸ç§è¯¦æƒ…å¼¹çª— -->
    <div id="coinDetailModal" class="fixed inset-0 z-50 hidden flex items-center justify-center" style="background: rgba(0,0,0,0.5);" onclick="hideCoinDetail()">
      <div class="bg-white rounded-xl p-4 max-w-2xl w-full mx-4 border border-slate-200 shadow-2xl max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
        <!-- æ ‡é¢˜æ ï¼šå¸ç§åç§° | Twitteræœç´¢ | å…³é—­æŒ‰é’® -->
        <div class="flex items-center justify-between mb-4">
          <div id="coinDetailName" class="text-xl font-bold text-slate-800">å¸ç§åç§°</div>
          <div class="flex items-center gap-2">
            <a id="coinDetailTwitterSearch" href="#" target="_blank" class="px-3 py-1.5 bg-sky-100 hover:bg-sky-200 text-sky-600 text-sm rounded-lg transition-all">
              Twitteræœç´¢
            </a>
            <button onclick="hideCoinDetail()" class="text-slate-500 hover:text-slate-800 transition-colors p-1">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
              </svg>
            </button>
          </div>
        </div>

        <!-- ç¬¬äºŒè¡Œï¼šèµ„é‡‘è´¹ç‡ | 24häº¤æ˜“é‡ -->
        <div class="grid grid-cols-2 gap-3 mb-3">
          <div class="p-2.5 bg-slate-50 rounded-lg border border-slate-200">
            <div class="text-slate-500 text-xs mb-1">èµ„é‡‘è´¹ç‡</div>
            <span id="coinDetailFundingRate" class="text-sm font-bold">--</span>
            <span id="coinDetailFundingTime" class="text-xs text-slate-400 ml-1"></span>
          </div>
          <div class="p-2.5 bg-slate-50 rounded-lg border border-slate-200">
            <div class="text-slate-500 text-xs mb-1">24hæ¶¨è·Œå¹…</div>
            <span id="coinDetailChange" class="text-sm font-bold">0.00%</span>
          </div>
        </div>

        <!-- ç¬¬ä¸‰è¡Œï¼šæŒä»“é‡ | 24häº¤æ˜“é‡ -->
        <div class="grid grid-cols-2 gap-3 mb-3">
          <div class="p-2.5 bg-slate-50 rounded-lg border border-slate-200">
            <div class="text-slate-500 text-xs mb-1">æŒä»“é‡</div>
            <span id="coinDetailOpenInterest" class="text-sm font-bold text-slate-800">$0.00</span>
            <span id="coinDetailOpenInterestCount" class="text-xs text-slate-400 ml-1"></span>
          </div>
          <div class="p-2.5 bg-slate-50 rounded-lg border border-slate-200">
            <div class="text-slate-500 text-xs mb-1">24häº¤æ˜“é‡</div>
            <span id="coinDetailVolume" class="text-sm font-bold text-slate-800">$0.00</span>
          </div>
        </div>

        <!-- ç¬¬å››è¡Œï¼šä»·æ ¼ï¼ˆå•ç‹¬ä¸€è¡Œï¼Œçªå‡ºæ˜¾ç¤ºï¼‰ -->
        <div class="mb-4">
          <div class="text-slate-500 text-xs mb-1">ä»·æ ¼</div>
          <div id="coinDetailPrice" class="text-2xl font-bold text-slate-800">$0.00</div>
        </div>

        <!-- Kçº¿å›¾åŒºåŸŸ -->
        <div class="mb-4">
          <div class="flex items-center justify-between mb-2">
            <div class="text-slate-500 text-xs font-medium">ğŸ“Š ä»·æ ¼èµ°åŠ¿</div>
            <div class="flex gap-1 flex-wrap">
              <button id="pricePeriod5m" onclick="changePricePeriod('5m')" class="px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300">5m</button>
              <button id="pricePeriod15m" onclick="changePricePeriod('15m')" class="px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300">15m</button>
              <button id="pricePeriod1h" onclick="changePricePeriod('1h')" class="px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300">1h</button>
              <button id="pricePeriod4h" onclick="changePricePeriod('4h')" class="px-2 py-0.5 text-xs bg-sky-500 text-white rounded">4h</button>
              <button id="pricePeriod1d" onclick="changePricePeriod('1d')" class="px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300">1d</button>
            </div>
          </div>
          <div class="bg-slate-50 rounded-lg border border-slate-200 flex" style="height: 200px;">
            <!-- å·¦ä¾§Kçº¿å›¾Canvas -->
            <div class="p-3" style="width: calc(100% - 80px);">
              <canvas id="priceChart"></canvas>
            </div>
            <!-- å³ä¾§ä»·æ ¼æ ‡ç­¾å®¹å™¨ -->
            <div id="priceLabelsContainer" class="w-20 p-2 flex flex-col justify-between text-right">
              <!-- ä»·æ ¼æ ‡ç­¾å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
          </div>
        </div>

        <!-- æˆäº¤é‡å†å²è¶‹åŠ¿å›¾åŒºåŸŸ -->
        <div class="mb-4">
          <div class="flex items-center justify-between mb-2">
            <div class="text-slate-500 text-xs font-medium">ğŸ“Š æˆäº¤é‡å†å²è¶‹åŠ¿(ç°è´§)</div>
            <div class="flex gap-1 flex-wrap">
              <button id="volumePeriod5m" onclick="changeVolumePeriod('5m')" class="px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300">5m</button>
              <button id="volumePeriod15m" onclick="changeVolumePeriod('15m')" class="px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300">15m</button>
              <button id="volumePeriod1h" onclick="changeVolumePeriod('1h')" class="px-2 py-0.5 text-xs bg-sky-500 text-white rounded">1h</button>
              <button id="volumePeriod4h" onclick="changeVolumePeriod('4h')" class="px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300">4h</button>
              <button id="volumePeriod1d" onclick="changeVolumePeriod('1d')" class="px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300">1d</button>
            </div>
          </div>
          <div class="bg-slate-50 rounded-lg border border-slate-200 p-3" style="height: 200px;">
            <canvas id="volumeChart"></canvas>
          </div>
          <div id="volumeInsight" class="mt-2 text-xs text-slate-500"></div>
        </div>

        <!-- å…³é—­æŒ‰é’® -->
        <button onclick="hideCoinDetail()" class="w-full bg-slate-200 hover:bg-slate-300 text-slate-600 font-medium py-2.5 px-4 rounded-lg transition-all">
          å…³é—­
        </button>
      </div>
    </div>

    <!-- æ± å­è¯¦æƒ…å¼¹çª— -->
    <div id="poolDetailModal" class="fixed inset-0 z-50 hidden flex items-center justify-center" style="background: rgba(0,0,0,0.5);" onclick="hidePoolDetail()">
      <div class="bg-white rounded-xl p-6 max-w-4xl w-full mx-4 border border-slate-200 shadow-2xl max-h-[85vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-bold text-slate-800">æ± å­è¯¦æƒ…</h3>
          <button onclick="hidePoolDetail()" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
        </div>

        <!-- æ± å­ä¿¡æ¯å¤´éƒ¨ -->
        <div id="poolDetailHeader" class="flex items-center gap-4 mb-6">
          <div class="flex-1">
            <div id="poolDetailName" class="text-2xl font-bold text-slate-800">æ± å­åç§°</div>
            <div id="poolDetailBadges" class="flex gap-2 mt-1 text-sm">
            </div>
          </div>
          <div class="text-right">
            <div id="poolDetailTVL" class="text-2xl font-bold text-sky-500">$0.00</div>
            <div class="text-slate-400 text-sm mt-1">TVL</div>
          </div>
        </div>

        <!-- äº¤æ˜“å¯¹ä¿¡æ¯ -->
        <div id="poolDetailPairSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-700">ğŸ’± äº¤æ˜“å¯¹</h3>
          <div class="grid grid-cols-2 gap-3">
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">åŸºç¡€ä»£å¸</div>
              <div id="poolDetailBaseToken" class="text-slate-800 font-bold">--</div>
              <div id="poolDetailBaseTokenAddress" class="text-slate-400 text-xs mt-1 break-all">--</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">æŠ¥ä»·ä»£å¸</div>
              <div id="poolDetailQuoteToken" class="text-slate-800 font-bold">--</div>
              <div id="poolDetailQuoteTokenAddress" class="text-slate-400 text-xs mt-1 break-all">--</div>
            </div>
          </div>
        </div>

        <!-- å…³é”®æŒ‡æ ‡ -->
        <div id="poolDetailMetricsSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-700">ğŸ“Š å…³é”®æŒ‡æ ‡</h3>
          <div class="grid grid-cols-2 md:grid-cols-3 gap-3">
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">TVL</div>
              <div id="poolDetailTVLMetric" class="text-slate-800 font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">24häº¤æ˜“é‡</div>
              <div id="poolDetailVolume24h" class="text-slate-800 font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">24häº¤æ˜“æ¬¡æ•°</div>
              <div id="poolDetailTxCount" class="text-slate-800 font-bold">0</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">äº¤æ˜“ä»·æ ¼</div>
              <div id="poolDetailPrice" class="text-slate-800 font-bold">$0.00</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">DEXå¹³å°</div>
              <div id="poolDetailDex" class="text-slate-800 font-bold">--</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">ç½‘ç»œ</div>
              <div id="poolDetailNetwork" class="text-slate-800 font-bold">--</div>
            </div>
          </div>
        </div>

        <!-- æ± å­åœ°å€ -->
        <div id="poolDetailAddressSection" class="mb-6">
          <h3 class="font-bold text-sm mb-2 text-slate-700">ğŸ”— æ± å­åœ°å€</h3>
          <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
            <div id="poolDetailAddress" class="text-sky-600 text-xs break-all">--</div>
          </div>
        </div>

        <!-- ä»·æ ¼å˜åŒ–æ•°æ® -->
        <div id="poolDetailPriceChangeSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-700">ğŸ’¹ ä»·æ ¼å˜åŒ–</h3>
          <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">1å°æ—¶</div>
              <div id="poolDetailChange1h" class="text-slate-800 font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">6å°æ—¶</div>
              <div id="poolDetailChange6h" class="text-slate-800 font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">24å°æ—¶</div>
              <div id="poolDetailChange24h" class="text-slate-800 font-bold">0.00%</div>
            </div>
            <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div class="text-slate-500 text-xs mb-1">7å¤©</div>
              <div id="poolDetailChange7d" class="text-slate-800 font-bold">0.00%</div>
            </div>
          </div>
        </div>

        <!-- å¤–éƒ¨é“¾æ¥ -->
        <div id="poolDetailLinksSection" class="mb-6">
          <h3 class="font-bold text-sm mb-3 text-slate-700">ğŸŒ å¤–éƒ¨é“¾æ¥</h3>
          <div class="flex flex-wrap gap-2">
            <a id="poolDetailTwitter" href="#" target="_blank" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 text-slate-600 text-sm rounded-lg transition-all">
              Twitter/X â†—
            </a>
            <a id="poolDetailGeckoTerminal" href="#" target="_blank" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 text-slate-600 text-sm rounded-lg transition-all">
              GeckoTerminal â†—
            </a>
            <a id="poolDetailDexscreener" href="#" target="_blank" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 text-slate-600 text-sm rounded-lg transition-all">
              Dexscreener â†—
            </a>
          </div>
        </div>

        <!-- å…³é—­æŒ‰é’® -->
        <button onclick="hidePoolDetail()" class="w-full bg-slate-200 hover:bg-slate-300 text-slate-600 font-medium py-2 px-4 rounded-lg transition-all">
          å…³é—­
        </button>
      </div>
    </div>
  </div>

  <script>
    // ==================== API Key é…ç½® ====================
    // é»˜è®¤API Keyï¼ˆä»Followin Open APIæ–‡æ¡£ä¸­æå–ï¼‰
    const DEFAULT_API_KEY = 'p0JNCcX8rGkEsi6hb883iDWyPGsNY6WK';
    let FOLLOWIN_API_KEY = '';

    // ==================== æ··åˆAPIé…ç½®ï¼ˆ2026å¹´æ¨èæ–¹æ¡ˆï¼‰====================
    // ä½¿ç”¨Coinloreè·å–çƒ­é—¨ä»£å¸ï¼ˆå…è´¹æ— é™ï¼Œæ— éœ€API Keyï¼‰
    
    const COINLORE_API_URL = 'https://api.coinlore.net/api';

    // ä»localStorageåŠ è½½API Keyï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
    function loadApiKey() {
      const savedKey = localStorage.getItem('followin_api_key');
      if (savedKey) {
        FOLLOWIN_API_KEY = savedKey;
        // addLog('info', 'å·²åŠ è½½ä¿å­˜çš„API Key'); // æ³¨é‡Šæ‰ï¼Œå› ä¸ºæ­¤æ—¶ addLog å‡½æ•°è¿˜æœªå®šä¹‰
      } else {
        // ä½¿ç”¨é»˜è®¤API Key
        FOLLOWIN_API_KEY = DEFAULT_API_KEY;
        // addLog('success', 'ä½¿ç”¨é»˜è®¤API Key'); // æ³¨é‡Šæ‰ï¼Œå› ä¸ºæ­¤æ—¶ addLog å‡½æ•°è¿˜æœªå®šä¹‰
      }
      return FOLLOWIN_API_KEY;
    }

    // æ˜¾ç¤ºAPI Keyé…ç½®æ¨¡æ€æ¡†
    function showApiKeyConfig() {
      const modal = document.getElementById('apiKeyModal');
      const input = document.getElementById('apiKeyInput');
      input.value = FOLLOWIN_API_KEY || DEFAULT_API_KEY;
      modal.classList.remove('hidden');
    }

    // éšè—API Keyé…ç½®æ¨¡æ€æ¡†
    function hideApiKeyConfig() {
      const modal = document.getElementById('apiKeyModal');
      modal.classList.add('hidden');
    }

    // ä½¿ç”¨é»˜è®¤API Key
    function useDefaultApiKey() {
      const input = document.getElementById('apiKeyInput');
      input.value = DEFAULT_API_KEY;
      // addLog('info', 'å·²å¡«å…¥é»˜è®¤API Key'); // æ³¨é‡Šæ‰ï¼Œå› ä¸ºæ­¤æ—¶ addLog å‡½æ•°è¿˜æœªå®šä¹‰
    }

    // ä¿å­˜API Key
    function saveApiKey() {
      const input = document.getElementById('apiKeyInput');
      const apiKey = input.value.trim();

      if (!apiKey) {
        alert('è¯·è¾“å…¥API Key');
        return;
      }

      FOLLOWIN_API_KEY = apiKey;
      localStorage.setItem('followin_api_key', apiKey);
      // addLog('success', 'API Keyå·²ä¿å­˜'); // æ³¨é‡Šæ‰ï¼Œå› ä¸ºæ­¤æ—¶ addLog å‡½æ•°è¿˜æœªå®šä¹‰
      hideApiKeyConfig();

      // è‡ªåŠ¨åˆ·æ–°æ–°é—»æ•°æ®
      refreshNewsData();
    }

    // ==================== å…¨å±€ç¼“å­˜å˜é‡ ====================
    // æ³¨æ„ï¼šè¿™äº›ç¼“å­˜å˜é‡å®šä¹‰åœ¨æ‰€æœ‰å‡½æ•°ä¹‹å‰ï¼Œé¿å…å˜é‡æœªå®šä¹‰é”™è¯¯

    // Kçº¿æ•°æ®ç¼“å­˜ (symbol -> { data: [], timestamp: number })
    const klineCache = new Map();

    // ä»·æ ¼å†å²ç¼“å­˜ (ç”¨äºKçº¿å›¾)
    const priceHistoryCache = new Map();

    // æŒä»“é‡å†å²ç¼“å­˜ (ç”¨äºæŒä»“é‡è¶‹åŠ¿å›¾)
    const openInterestHistoryCache = new Map();

    // ç¼“å­˜æ—¶é—´é…ç½®ï¼ˆæ ¹æ®å‘¨æœŸåŠ¨æ€è°ƒæ•´ï¼‰
    const CACHE_TIME = {
      '5m': 30000,      // 30ç§’
      '15m': 60000,     // 1åˆ†é’Ÿ
      '30m': 120000,    // 2åˆ†é’Ÿ
      '1h': 300000,     // 5åˆ†é’Ÿ
      '2h': 600000,     // 10åˆ†é’Ÿ
      '4h': 600000,     // 10åˆ†é’Ÿ
      '6h': 600000,     // 10åˆ†é’Ÿ
      '12h': 1200000,   // 20åˆ†é’Ÿ
      '1d': 3600000,    // 1å°æ—¶
      '1w': 7200000     // 2å°æ—¶
    };

    // ==================== å¤šæ•°æ®æºé…ç½® ====================
    
    // æ•°æ®æºæšä¸¾
    const DATA_SOURCES = {
      BINANCE: 'binance',
      OKX: 'okx',
      BYBIT: 'bybit',
      CRYPTOCOMPARE: 'cryptocompare'
    };

    // æ•°æ®æºé…ç½®ï¼ˆä¼˜å…ˆçº§ã€è´¨é‡è¯„åˆ†ã€æ˜¯å¦è·³è¿‡å»é‡ï¼‰
    const DATA_SOURCE_CONFIG = {
      [DATA_SOURCES.BINANCE]: { priority: 1, quality: 100, skipDedup: false },
      [DATA_SOURCES.OKX]: { priority: 2, quality: 90, skipDedup: false },
      [DATA_SOURCES.BYBIT]: { priority: 3, quality: 85, skipDedup: false },
      [DATA_SOURCES.CRYPTOCOMPARE]: { priority: 4, quality: 75, skipDedup: true }  // ä½è´¨é‡ï¼Œå»é‡æ—¶è·³è¿‡
    };

    // æ•°æ®æºçŠ¶æ€
    const dataSourceStatus = new Map();
    
    // åˆå§‹åŒ–æ•°æ®æºçŠ¶æ€
    function initDataSourceStatus() {
      dataSourceStatus.set(DATA_SOURCES.BINANCE, { available: true, errors: 0, lastError: null });
      dataSourceStatus.set(DATA_SOURCES.OKX, { available: true, errors: 0, lastError: null });
      dataSourceStatus.set(DATA_SOURCES.BYBIT, { available: true, errors: 0, lastError: null });
      dataSourceStatus.set(DATA_SOURCES.CRYPTOCOMPARE, { available: true, errors: 0, lastError: null });
    }

    // è®°å½•æ•°æ®æºé”™è¯¯
    function recordDataSourceError(source, error) {
      const status = dataSourceStatus.get(source);
      if (status) {
        status.errors++;
        status.lastError = error;
        
        // å¦‚æœé”™è¯¯è¶…è¿‡é˜ˆå€¼ï¼Œæ ‡è®°ä¸ºä¸å¯ç”¨
        if (status.errors >= 3) {
          status.available = false;
          addLog('warn', `æ•°æ®æº ${source} è¿ç»­å¤±è´¥ ${status.errors} æ¬¡ï¼Œæš‚æ—¶ç¦ç”¨`);
        }
      }
    }

    // æ£€æŸ¥æ•°æ®æºæ˜¯å¦å¯ç”¨
    function isDataSourceAvailable(source) {
      const status = dataSourceStatus.get(source);
      return status ? status.available : false;
    }

    // é‡ç½®æ•°æ®æºçŠ¶æ€
    function resetDataSourceStatus(source) {
      const status = dataSourceStatus.get(source);
      if (status) {
        status.errors = 0;
        status.available = true;
        status.lastError = null;
        addLog('info', `æ•°æ®æº ${source} çŠ¶æ€å·²é‡ç½®`);
      }
    }

    // æ•°æ®æºä¼˜å…ˆçº§ï¼ˆæŒ‰é¡ºåºå°è¯•ï¼‰
    const DATA_SOURCE_PRIORITY = [
      DATA_SOURCES.BINANCE,
      DATA_SOURCES.OKX,
      DATA_SOURCES.BYBIT,
      DATA_SOURCES.CRYPTOCOMPARE
    ];

    // ==================== æ™ºèƒ½ç¼“å­˜ç®¡ç†å™¨ ====================
    
    // é«˜ä¼˜å…ˆçº§å¸ç§é›†åˆï¼ˆä¿¡å·å¼‚åŠ¨å¸ç§ï¼‰
    const highPrioritySymbols = new Set();
    
    // ==================== åˆçº¦å¸ç§ç™½åå• ====================
    // åªæ˜¾ç¤ºæœ‰æœŸè´§åˆçº¦çš„äº¤æ˜“å¯¹ï¼Œé¿å…æŸ¥è¯¢æ— åˆçº¦å¸ç§çš„æŒä»“é‡æ•°æ®
    const FUTURES_SYMBOLS = new Set([
      // å¸‚å€¼Top 30ä¸»æµå¸ç§
      'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT',
      'ADAUSDT', 'AVAXUSDT', 'DOGEUSDT', 'DOTUSDT', 'LINKUSDT',
      'MATICUSDT', 'LTCUSDT', 'UNIUSDT', 'ATOMUSDT', 'ETCUSDT',
      'XLMUSDT', 'ALGOUSDT', 'VETUSDT', 'FILUSDT', 'NEARUSDT',
      'APTUSDT', 'INJUSDT', 'QNTUSDT', 'ARBUSDT', 'OPUSDT',
      'APTUSDT', 'SEIUSDT', 'SUIUSDT',
      
      // DeFiçƒ­é—¨å¸ç§
      'AAVEUSDT', 'MKRUSDT', 'COMPUSDT', 'CRVUSDT', 'SNXUSDT',
      'YFIUSDT', 'SUSHIUSDT', '1INCHUSDT', 'LDOUSDT', 'GMXUSDT',
      'PENDLEUSDT', 'EIGENUSDT', 'ENAUSDT',
      
      // AIçƒ­é—¨å¸ç§
      'FETUSDT', 'RNDRUSDT', 'TIAUSDT', 'SEIUSDT', 'AGIXUSDT',
      'NEARUSDT', 'WLDUSDT', 'TAOUSDT', 'OMUSDT',
      
      // Memeçƒ­é—¨å¸ç§ï¼ˆæœ‰åˆçº¦ï¼‰
      'PEPEUSDT', 'WIFUSDT', 'FLOKIUSDT', 'BONKUSDT', 'SHIBUSDT',
      'MEMEUSDT', 'DOGEUSDT',
      
      // L2çƒ­é—¨å¸ç§
      'ARBUSDT', 'OPUSDT', 'MATICUSDT', 'IMXUSDT',
      
      // å…¶ä»–çƒ­é—¨å¸ç§
      'TRXUSDT', 'XMRUSDT', 'ETCUSDT', 'ICPUSDT', 'HBARUSDT',
      'QNTUSDT', 'GRTUSDT', 'ZECUSDT', 'XTZUSDT', 'EOSUSDT'
    ]);
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºåˆçº¦äº¤æ˜“å¯¹
    function isFuturesSymbol(symbol) {
      return FUTURES_SYMBOLS.has(symbol);
    }
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºé«˜ä¼˜å…ˆçº§äº¤æ˜“å¯¹ï¼ˆä¿¡å·ç›‘æ§ä¸­çš„å¸ç§ï¼‰
    function isHighPrioritySymbol(symbol) {
      return highPrioritySymbols.has(symbol);
    }
    
    // è¯·æ±‚é™æµå™¨ï¼ˆé˜²æ­¢APIé™æµï¼‰
    class RateLimiter {
      constructor(maxRequests = 100, windowMs = 60000) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
        this.requests = [];
      }
      
      async request(fn) {
        // æ¸…ç†è¿‡æœŸè¯·æ±‚
        const now = Date.now();
        this.requests = this.requests.filter(t => now - t < this.windowMs);
        
        // æ£€æŸ¥æ˜¯å¦è¶…é™
        if (this.requests.length >= this.maxRequests) {
          const oldest = Math.min(...this.requests);
          const waitTime = this.windowMs - (now - oldest);
          console.log(`[RateLimiter] è¯·æ±‚è¿‡å¤šï¼Œç­‰å¾… ${waitTime}ms`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
        }
        
        this.requests.push(now);
        return await fn();
      }
    }
    
    const rateLimiter = new RateLimiter(100, 60000);  // æ¯åˆ†é’Ÿ100æ¬¡
    
    // æ•°æ®ç¼“å­˜ç®¡ç†å™¨
    class DataCacheManager {
      constructor() {
        this.cache = new Map();
        this.maxCacheSize = 30;  // æœ€å¤šç¼“å­˜30ä¸ªå¸ç§
        this.updateIntervals = [];
      }
      
      // è®¾ç½®ç¼“å­˜
      set(symbol, data, priority = 'normal') {
        const now = Date.now();
        const cached = this.cache.get(symbol);
        
        const cacheData = {
          ...data,
          cache: {
            created: now,
            lastUpdated: now,
            ttl: priority === 'high' ? 300000 : 300000,  // 5åˆ†é’Ÿ
            priority: priority,
            hitCount: (cached?.cache?.hitCount || 0) + 1
          }
        };
        
        this.cache.set(symbol, cacheData);
        
        // å¦‚æœç¼“å­˜è¶…å‡ºé™åˆ¶ï¼Œæ‰§è¡ŒLRUæ¸…ç†
        this.cleanupIfNeeded();
      }
      
      // è·å–ç¼“å­˜
      get(symbol) {
        const data = this.cache.get(symbol);
        if (!data) return null;
        
        // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        const now = Date.now();
        if (now - data.cache.lastUpdated > data.cache.ttl) {
          console.log(`[Cache] ${symbol} ç¼“å­˜å·²è¿‡æœŸ`);
          return null;
        }
        
        // æ›´æ–°è®¿é—®æ—¶é—´ï¼ˆç”¨äºLRUï¼‰
        data.cache.lastAccessed = now;
        return data;
      }
      
      // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
      isValid(symbol) {
        const data = this.cache.get(symbol);
        if (!data) return false;
        
        const now = Date.now();
        return now - data.cache.lastUpdated <= data.cache.ttl;
      }
      
      // LRUæ¸…ç†
      cleanupIfNeeded() {
        if (this.cache.size <= this.maxCacheSize) return;
        
        // æŒ‰ä¼˜å…ˆçº§å’Œè®¿é—®æ—¶é—´æ’åº
        const entries = Array.from(this.cache.entries())
          .filter(([symbol, data]) => data.cache.priority !== 'high')  // ä¿ç•™é«˜ä¼˜å…ˆçº§
          .sort((a, b) => {
            const timeA = a[1].cache.lastAccessed || a[1].cache.created;
            const timeB = b[1].cache.lastAccessed || b[1].cache.created;
            return timeA - timeB;  // æœ€å…ˆåˆ é™¤æœ€ä¹…æœªè®¿é—®çš„
          });
        
        // åˆ é™¤è¶…è¿‡é™åˆ¶çš„ç¼“å­˜
        const toDelete = entries.slice(0, entries.length - this.maxCacheSize);
        toDelete.forEach(([symbol]) => {
          this.cache.delete(symbol);
          console.log(`[Cache] LRUæ¸…ç†: åˆ é™¤ ${symbol}`);
        });
      }
      
      // æ¸…ç†è¿‡æœŸç¼“å­˜
      cleanupExpired() {
        const now = Date.now();
        for (const [symbol, data] of this.cache) {
          if (now - data.cache.created > 3600000) {  // è¶…è¿‡1å°æ—¶
            console.log(`[Cache] æ¸…ç†è¿‡æœŸç¼“å­˜: ${symbol}`);
            this.cache.delete(symbol);
            highPrioritySymbols.delete(symbol);
          }
        }
      }
      
      // æ›´æ–°é«˜ä¼˜å…ˆçº§å®æ—¶æ•°æ®ï¼ˆä»·æ ¼ã€æ¶¨è·Œå¹…ï¼‰
      async updateHighPriorityData() {
        const symbols = Array.from(highPrioritySymbols);
        if (symbols.length === 0) return;
        
        console.log(`[Cache] æ›´æ–°é«˜ä¼˜å…ˆçº§æ•°æ®: ${symbols.length}ä¸ªå¸ç§`);
        
        for (const symbol of symbols) {
          const cached = this.cache.get(symbol);
          if (cached) {
            try {
              // åªæ›´æ–°å®æ—¶ä»·æ ¼æ•°æ®ï¼ˆå¿«é€ŸAPIï¼‰
              const priceData = await this.fetchCurrentPrice(symbol);
              if (priceData && cached.coinGecko) {
                cached.coinGecko.currentPrice = priceData.currentPrice;
                cached.coinGecko.priceChange24h = priceData.priceChange24h;
                cached.cache.lastUpdated = Date.now();
                console.log(`[Cache] å·²æ›´æ–° ${symbol} å®æ—¶ä»·æ ¼`);
              }
            } catch (error) {
              console.error(`[Cache] æ›´æ–° ${symbol} å®æ—¶æ•°æ®å¤±è´¥:`, error);
            }
          }
        }
      }
      
      // è·å–å½“å‰ä»·æ ¼
      async fetchCurrentPrice(symbol) {
        try {
          const response = await rateLimiter.request(() => 
            fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`)
          );
          const data = await response.json();
          return {
            currentPrice: parseFloat(data.lastPrice),
            priceChange24h: parseFloat(data.priceChangePercent)
          };
        } catch (error) {
          console.error(`[Cache] è·å– ${symbol} ä»·æ ¼å¤±è´¥:`, error);
          return null;
        }
      }
      
      // å¯åŠ¨è‡ªåŠ¨æ›´æ–°
      startAutoUpdate() {
        // é«˜ä¼˜å…ˆçº§å¸ç§æ¯10ç§’åˆ·æ–°å®æ—¶æ•°æ®
        const interval1 = setInterval(() => {
          this.updateHighPriorityData();
        }, 10000);
        this.updateIntervals.push(interval1);
        
        // æ¯5åˆ†é’Ÿæ£€æŸ¥å¹¶åˆ·æ–°è¿‡æœŸç¼“å­˜
        const interval2 = setInterval(() => {
          this.checkAndRefreshExpired();
        }, 300000);
        this.updateIntervals.push(interval2);
        
        // æ¯å°æ—¶æ¸…ç†è¿‡æœŸç¼“å­˜
        const interval3 = setInterval(() => {
          this.cleanupExpired();
        }, 3600000);
        this.updateIntervals.push(interval3);
        
        console.log('[Cache] è‡ªåŠ¨æ›´æ–°å·²å¯åŠ¨');
      }
      
      // æ£€æŸ¥å¹¶åˆ·æ–°è¿‡æœŸç¼“å­˜
      async checkAndRefreshExpired() {
        const now = Date.now();
        
        for (const [symbol, data] of this.cache) {
          // ç¼“å­˜è¶…è¿‡5åˆ†é’Ÿï¼Œåå°åˆ·æ–°
          if (now - data.cache.lastUpdated > 300000) {
            console.log(`[Cache] ${symbol} ç¼“å­˜å·²è¿‡æœŸï¼Œåå°åˆ·æ–°...`);
            this.refreshInBackground(symbol);
          }
        }
      }
      
      // åå°åˆ·æ–°ç¼“å­˜
      async refreshInBackground(symbol) {
        try {
          const newData = await this.loadCoinDetailData(symbol);
          if (newData) {
            this.set(symbol, newData, highPrioritySymbols.has(symbol) ? 'high' : 'normal');
            console.log(`[Cache] ${symbol} åå°åˆ·æ–°å®Œæˆ`);
          }
        } catch (error) {
          console.error(`[Cache] ${symbol} åå°åˆ·æ–°å¤±è´¥:`, error);
        }
      }
      
      // åŠ è½½å¸ç§è¯¦æƒ…æ•°æ®ï¼ˆä¸å†è·å–å¸‚å€¼æ•°æ®ï¼‰
      async loadCoinDetailData(symbol) {
        try {
          const [fundingRateData, openInterestData] = await Promise.all([
            fetchBinanceFundingRate(symbol).catch(() => null),
            fetchOpenInterestWithFallback(symbol).catch(() => null)
          ]);
          
          return {
            coinGecko: null, // ä¸å†è·å–å¸‚å€¼æ•°æ®
            volume: null,
            fundingRate: fundingRateData,
            openInterest: openInterestData
          };
        } catch (error) {
          console.error(`[Cache] åŠ è½½ ${symbol} è¯¦æƒ…æ•°æ®å¤±è´¥:`, error);
          return null;
        }
      }
      
      // é¢„åŠ è½½çƒ­é—¨å¸ç§
      async preloadHotSymbols(symbols) {
        console.log(`[Cache] é¢„åŠ è½½çƒ­é—¨å¸ç§: ${symbols.length}ä¸ª`);
        
        for (const symbol of symbols) {
          // æ£€æŸ¥æ˜¯å¦å·²ç¼“å­˜ä¸”æœªè¿‡æœŸ
          if (this.isValid(symbol)) {
            console.log(`[Cache] ${symbol} å·²ç¼“å­˜ï¼Œè·³è¿‡`);
            continue;
          }
          
          // åå°åŠ è½½ï¼ˆä¸é˜»å¡UIï¼‰
          setTimeout(async () => {
            try {
              const data = await this.loadCoinDetailData(symbol);
              if (data) {
                this.set(symbol, data, 'normal');
                console.log(`[Cache] ${symbol} é¢„åŠ è½½å®Œæˆ`);
              }
            } catch (error) {
              console.error(`[Cache] ${symbol} é¢„åŠ è½½å¤±è´¥:`, error);
            }
          }, Math.random() * 5000);  // éšæœºå»¶è¿Ÿï¼Œé¿å…å¹¶å‘è¿‡å¤š
        }
      }
      
      // åœæ­¢è‡ªåŠ¨æ›´æ–°
      stopAutoUpdate() {
        this.updateIntervals.forEach(interval => clearInterval(interval));
        this.updateIntervals = [];
        console.log('[Cache] è‡ªåŠ¨æ›´æ–°å·²åœæ­¢');
      }
    }
    
    // åˆ›å»ºå…¨å±€ç¼“å­˜ç®¡ç†å™¨å®ä¾‹
    const cacheManager = new DataCacheManager();

    // ==================== å¤šæ•°æ®æºè·å–å’Œå»é‡ ====================
    
    // æ•°æ®æºæ˜ å°„ï¼ˆå¸ç§ç¬¦å· -> CryptoCompareç¬¦å·ï¼‰
    const SYMBOL_MAP = {
      'BTCUSDT': 'BTC',
      'ETHUSDT': 'ETH',
      'BNBUSDT': 'BNB',
      'SOLUSDT': 'SOL',
      'XRPUSDT': 'XRP',
      'ADAUSDT': 'ADA',
      'AVAXUSDT': 'AVAX',
      'DOGEUSDT': 'DOGE',
      'DOTUSDT': 'DOT',
      'LINKUSDT': 'LINK',
      'MATICUSDT': 'MATIC',
      'LTCUSDT': 'LTC',
      'UNIUSDT': 'UNI',
      'ATOMUSDT': 'ATOM'
    };
    
    // å°†Binanceç¬¦å·è½¬æ¢ä¸ºCryptoCompareç¬¦å·
    function binanceToCryptoCompare(symbol) {
      return SYMBOL_MAP[symbol] || symbol.replace('USDT', '');
    }
    
    // ä»Binanceè·å–ä»·æ ¼å†å²æ•°æ®
    async function fetchPriceHistoryFromBinance(symbol, interval, limit) {
      const cacheKey = `binance_price_${symbol}_${interval}_${limit}`;
      
      try {
        // ä½¿ç”¨åˆçº¦APIè·å–ä»·æ ¼æ•°æ®
        const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
        
        if (!response.ok) {
          throw new Error(`Binance API error: ${response.status}`);
        }
        
        const klines = await response.json();
        
        const data = klines.map(kline => ({
          timestamp: kline[0],
          price: parseFloat(kline[4]), // æ”¶ç›˜ä»·
          volume: parseFloat(kline[5]), // æˆäº¤é‡
          source: DATA_SOURCES.BINANCE
        }));
        
        return { data, source: DATA_SOURCES.BINANCE };
        
      } catch (error) {
        console.error('[Binance] è·å–ä»·æ ¼å†å²å¤±è´¥:', error);
        recordDataSourceError(DATA_SOURCES.BINANCE, error);
        throw error;
      }
    }
    
    // ä»CryptoCompareè·å–ä»·æ ¼å†å²æ•°æ®
    async function fetchPriceHistoryFromCryptoCompare(symbol, interval, limit) {
      const ccSymbol = binanceToCryptoCompare(symbol);
      
      // æ˜ å°„å‘¨æœŸ
      const intervalMap = {
        '5m': 'minute',
        '15m': 'minute',
        '30m': 'minute',
        '1h': 'hour',
        '4h': 'hour',
        '1d': 'day'
      };
      
      const ccInterval = intervalMap[interval] || 'day';
      
      // è®¡ç®—æ•°æ®ç‚¹æ•°
      const dataPoints = Math.min(limit, 2000); // CryptoCompareæœ€å¤š2000ä¸ªæ•°æ®ç‚¹
      
      try {
        const response = await fetch(
          `https://min-api.cryptocompare.com/data/v2/histo${ccInterval}?fsym=${ccSymbol}&tsym=USDT&limit=${dataPoints}`
        );
        
        if (!response.ok) {
          throw new Error(`CryptoCompare API error: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.Response !== 'Success') {
          throw new Error(`CryptoCompare: ${result.Message}`);
        }
        
        const data = result.Data.Data.map(item => ({
          timestamp: item.time * 1000, // è½¬æ¢ä¸ºæ¯«ç§’
          price: item.close,
          volume: item.volumeto,
          source: DATA_SOURCES.CRYPTOCOMPARE
        }));
        
        return { data, source: DATA_SOURCES.CRYPTOCOMPARE };
        
      } catch (error) {
        console.error('[CryptoCompare] è·å–ä»·æ ¼å†å²å¤±è´¥:', error);
        recordDataSourceError(DATA_SOURCES.CRYPTOCOMPARE, error);
        throw error;
      }
    }
    
    // ä»OKXè·å–ä»·æ ¼å†å²æ•°æ®
    async function fetchPriceHistoryFromOKX(symbol, interval, limit) {
      const okxSymbol = symbol.replace('USDT', '-USDT-SWAP'); // ä½¿ç”¨åˆçº¦æ ¼å¼
      
      // æ˜ å°„å‘¨æœŸ
      const intervalMap = {
        '5m': '5m',
        '15m': '15m',
        '30m': '30m',
        '1h': '1H',
        '4h': '4H',
        '1d': '1D'
      };
      
      const okxInterval = intervalMap[interval] || '1D';
      const dataPoints = Math.min(limit, 300); // OKXæœ€å¤š300ä¸ªæ•°æ®ç‚¹
      
      try {
        const response = await fetch(
          `https://www.okx.com/api/v5/market/candles?instId=${okxSymbol}&bar=${okxInterval}&limit=${dataPoints}&instType=SWAP`
        );
        
        if (!response.ok) {
          throw new Error(`OKX API error: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.code !== '0') {
          throw new Error(`OKX: ${result.msg}`);
        }
        
        const data = result.data.reverse().map(item => ({
          timestamp: parseInt(item[0]), // æ—¶é—´æˆ³
          price: parseFloat(item[4]), // æ”¶ç›˜ä»·
          volume: parseFloat(item[5]), // æˆäº¤é‡
          source: DATA_SOURCES.OKX
        }));
        
        return { data, source: DATA_SOURCES.OKX };
        
      } catch (error) {
        console.error('[OKX] è·å–ä»·æ ¼å†å²å¤±è´¥:', error);
        recordDataSourceError(DATA_SOURCES.OKX, error);
        throw error;
      }
    }
    
    // ä»Bybitè·å–ä»·æ ¼å†å²æ•°æ®
    async function fetchPriceHistoryFromBybit(symbol, interval, limit) {
      const bybitSymbol = symbol;
      
      // æ˜ å°„å‘¨æœŸ
      const intervalMap = {
        '5m': '5',
        '15m': '15',
        '30m': '30',
        '1h': '60',
        '4h': '240',
        '1d': 'D'
      };
      
      const bybitInterval = intervalMap[interval] || 'D';
      const dataPoints = Math.min(limit, 200); // Bybitæœ€å¤š200ä¸ªæ•°æ®ç‚¹
      
      try {
        const response = await fetch(
          `https://api.bybit.com/v5/market/kline?category=linear&symbol=${bybitSymbol}&interval=${bybitInterval}&limit=${dataPoints}`
        );
        
        if (!response.ok) {
          throw new Error(`Bybit API error: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.retCode !== 0) {
          throw new Error(`Bybit: ${result.retMsg}`);
        }
        
        const data = result.result.list.reverse().map(item => ({
          timestamp: parseInt(item[0]), // æ—¶é—´æˆ³
          price: parseFloat(item[4]), // æ”¶ç›˜ä»·
          volume: parseFloat(item[5]), // æˆäº¤é‡
          source: DATA_SOURCES.BYBIT
        }));
        
        return { data, source: DATA_SOURCES.BYBIT };
        
      } catch (error) {
        console.error('[Bybit] è·å–ä»·æ ¼å†å²å¤±è´¥:', error);
        recordDataSourceError(DATA_SOURCES.BYBIT, error);
        throw error;
      }
    }
    
    // ä»Binanceè·å–æŒä»“é‡å†å²æ•°æ®
    async function fetchOpenInterestHistoryFromBinance(symbol, period, limit) {
      try {
        const response = await fetch(
          `https://fapi.binance.com/futures/data/openInterestHist?symbol=${symbol}&period=${period}&limit=${limit}`
        );
        
        if (!response.ok) {
          throw new Error(`Binance Futures API error: ${response.status}`);
        }
        
        const data = await response.json();
        
        const oiData = data.map(item => ({
          timestamp: item.timestamp,
          openInterest: parseFloat(item.sumOpenInterest),
          source: DATA_SOURCES.BINANCE
        }));
        
        return { data: oiData, source: DATA_SOURCES.BINANCE };
        
      } catch (error) {
        console.error('[Binance Futures] è·å–æŒä»“é‡å†å²å¤±è´¥:', error);
        recordDataSourceError(DATA_SOURCES.BINANCE, error);
        throw error;
      }
    }
    
    // å¤šæºæ•°æ®å»é‡ï¼ˆåŸºäºæ—¶é—´æˆ³ï¼‰
    function deduplicateDataByTimestamp(dataArray) {
      const dataMap = new Map();
      
      for (const item of dataArray) {
        const key = item.timestamp;
        const config = DATA_SOURCE_CONFIG[item.source];
        
        // è·³è¿‡æ ‡è®°ä¸ºå»é‡æ—¶å¿½ç•¥çš„æ•°æ®æº
        if (config && config.skipDedup) {
          continue;
        }
        
        // æ ¹æ®æ•°æ®æºè´¨é‡è¯„åˆ†å†³å®šä¿ç•™å“ªä¸ªæ•°æ®
        if (!dataMap.has(key)) {
          dataMap.set(key, item);
        } else {
          const existingItem = dataMap.get(key);
          const existingConfig = DATA_SOURCE_CONFIG[existingItem.source];
          
          // ä¼˜å…ˆä¿ç•™è´¨é‡æ›´é«˜çš„æ•°æ®æº
          if (config && existingConfig && config.quality > existingConfig.quality) {
            dataMap.set(key, item);
          }
        }
      }
      
      // æŒ‰æ—¶é—´æˆ³æ’åº
      return Array.from(dataMap.values()).sort((a, b) => a.timestamp - b.timestamp);
    }
    
    // ==================== Kçº¿èšåˆå‡½æ•° ====================
    
    // è·å–å‘¨æœŸå¯¹åº”çš„åˆ†é’Ÿæ•°
    function getIntervalMinutes(interval) {
      const map = {
        '5m': 5,
        '15m': 15,
        '30m': 30,
        '1h': 60,
        '4h': 240,
        '1d': 1440
      };
      return map[interval] || 60;
    }
    
    // è·å–å‘¨æœŸæ¯”ä¾‹ï¼ˆç›®æ ‡å‘¨æœŸ / æºå‘¨æœŸï¼‰
    function getIntervalRatio(sourceInterval, targetInterval) {
      return getIntervalMinutes(targetInterval) / getIntervalMinutes(sourceInterval);
    }
    
    // èšåˆKçº¿æ•°æ®
    function aggregateKlines(klines, targetInterval, sourceInterval) {
      if (!klines || klines.length === 0) {
        return [];
      }
      
      const ratio = Math.round(getIntervalRatio(sourceInterval, targetInterval));
      
      if (ratio <= 1) {
        return klines; // ä¸éœ€è¦èšåˆ
      }
      
      const aggregated = [];
      
      for (let i = 0; i < klines.length; i += ratio) {
        const chunk = klines.slice(i, i + ratio);
        
        if (chunk.length === 0) {
          continue;
        }
        
        // è®¡ç®—èšåˆåçš„Kçº¿æ•°æ®
        const open = chunk[0].price || chunk[0].open;
        const high = Math.max(...chunk.map(k => k.price !== undefined ? k.price : k.high));
        const low = Math.min(...chunk.map(k => k.price !== undefined ? k.price : k.low));
        const close = chunk[chunk.length - 1].price || chunk[chunk.length - 1].close;
        const volume = chunk.reduce((sum, k) => sum + (k.volume || 0), 0);
        const timestamp = chunk[chunk.length - 1].timestamp;
        
        // ä¿ç•™æ•°æ®æºä¿¡æ¯ï¼ˆå¦‚æœæ•°æ®æ¥è‡ªå¤šä¸ªæºï¼Œæ ‡è®°ä¸ºèšåˆï¼‰
        const sources = new Set();
        chunk.forEach(k => {
          if (k.source) sources.add(k.source);
        });
        
        aggregated.push({
          timestamp: timestamp,
          price: close, // ä½¿ç”¨æ”¶ç›˜ä»·ä½œä¸ºpriceå­—æ®µ
          open: open,
          high: high,
          low: low,
          close: close,
          volume: volume,
          source: sources.size === 1 ? Array.from(sources)[0] : 'aggregated'
        });
      }
      
      return aggregated;
    }
    
    // åˆå¹¶å¤šæºæ•°æ®
    function mergeMultiSourceData(results) {
      const allData = [];
      const sources = new Set();
      
      for (const result of results) {
        if (result && result.data) {
          allData.push(...result.data);
          if (result.source) {
            sources.add(result.source);
          }
        }
      }
      
      // å»é‡å¹¶æ’åº
      const deduplicated = deduplicateDataByTimestamp(allData);
      
      return {
        data: deduplicated,
        sources: Array.from(sources)
      };
    }
    
    // å¸¦é™çº§ç­–ç•¥çš„ä»·æ ¼å†å²è·å–
    async function fetchPriceHistoryWithFallback(symbol, interval, limit) {
      const cacheKey = `price_${symbol}_${interval}_${limit}`;
      
      // æ£€æŸ¥ç¼“å­˜
      if (priceHistoryCache.has(cacheKey)) {
        const cached = priceHistoryCache.get(cacheKey);
        const cacheTime = CACHE_TIME[interval] || 60000;
        
        if (Date.now() - cached.timestamp < cacheTime) {
          return cached.data;
        }
      }
      
      // ===== èšåˆç­–ç•¥ï¼š4hæ•°æ®åŸºäº1hæ•°æ®èšåˆ =====
      if (interval === '4h') {
        console.log(`[Aggregation] ${symbol} ä½¿ç”¨èšåˆç­–ç•¥è·å–4hæ•°æ®`);
        
        try {
          // è·å–1hæ•°æ®ï¼ˆéœ€è¦limit * 4æ ¹ï¼‰
          const oneHourLimit = Math.min(limit * 4, 1000); // é™åˆ¶æœ€å¤§1000æ ¹
          const oneHourResult = await fetchPriceHistoryFromBinance(symbol, '1h', oneHourLimit);
          
          if (oneHourResult && oneHourResult.data && oneHourResult.data.length >= limit) {
            // èšåˆåˆ°4h
            const aggregatedData = aggregateKlines(oneHourResult.data, '4h', '1h');
            
            // æˆªå–æŒ‡å®šæ•°é‡
            const finalData = aggregatedData.slice(-limit);
            
            const result = {
              data: finalData,
              sources: ['Binance (aggregated)']
            };
            
            // ç¼“å­˜æ•°æ®
            priceHistoryCache.set(cacheKey, {
              data: result,
              timestamp: Date.now()
            });
            
            addLog('success', `${symbol} èšåˆæˆåŠŸ: ${oneHourResult.data.length}æ ¹1h â†’ ${finalData.length}æ ¹4h`);
            return result;
          }
        } catch (error) {
          console.error('[Aggregation] èšåˆå¤±è´¥ï¼Œé™çº§åˆ°ç›´æ¥è·å–:', error);
          // èšåˆå¤±è´¥ï¼Œç»§ç»­ä¸‹é¢çš„ç›´æ¥è·å–é€»è¾‘
        }
      }
      // ===== èšåˆç­–ç•¥ç»“æŸ =====
      
      // å°è¯•ä»å¤šä¸ªæ•°æ®æºè·å–
      const results = [];
      
      for (const source of DATA_SOURCE_PRIORITY) {
        if (!isDataSourceAvailable(source)) {
          console.log(`[MultiSource] è·³è¿‡ä¸å¯ç”¨çš„æ•°æ®æº: ${source}`);
          continue;
        }
        
        try {
          let result;
          
          if (source === DATA_SOURCES.BINANCE) {
            result = await fetchPriceHistoryFromBinance(symbol, interval, limit);
          } else if (source === DATA_SOURCES.OKX) {
            result = await fetchPriceHistoryFromOKX(symbol, interval, limit);
          } else if (source === DATA_SOURCES.BYBIT) {
            result = await fetchPriceHistoryFromBybit(symbol, interval, limit);
          } else if (source === DATA_SOURCES.CRYPTOCOMPARE) {
            result = await fetchPriceHistoryFromCryptoCompare(symbol, interval, limit);
          }
          
          if (result && result.data && result.data.length > 0) {
            results.push(result);
            addLog('success', `${source} æˆåŠŸè·å– ${result.data.length} æ¡æ•°æ®`);
            
            // å¦‚æœæ•°æ®è¶³å¤Ÿï¼Œåœæ­¢å°è¯•å…¶ä»–æ•°æ®æº
            if (result.data.length >= limit * 0.9) {
              break;
            }
          }
        } catch (error) {
          console.error(`[MultiSource] ${source} å¤±è´¥:`, error);
        }
      }
      
      // åˆå¹¶æ•°æ®
      const merged = mergeMultiSourceData(results);
      
      if (merged.data.length === 0) {
        throw new Error('æ‰€æœ‰æ•°æ®æºå‡å¤±è´¥');
      }
      
      // ç¼“å­˜æ•°æ®
      priceHistoryCache.set(cacheKey, {
        data: merged,
        timestamp: Date.now()
      });
      
      return merged;
    }
    
    // å¸¦é™çº§ç­–ç•¥çš„æŒä»“é‡å†å²è·å–
    async function fetchOpenInterestHistoryWithFallback(symbol, period, limit) {
      const cacheKey = `oi_${symbol}_${period}_${limit}`;
      
      // æ£€æŸ¥ç¼“å­˜
      if (openInterestHistoryCache.has(cacheKey)) {
        const cached = openInterestHistoryCache.get(cacheKey);
        const cacheTime = CACHE_TIME[period] || 60000;
        
        if (Date.now() - cached.timestamp < cacheTime) {
          return cached.data;
        }
      }
      
      // å°è¯•ä»å¤šä¸ªæ•°æ®æºè·å–
      const results = [];
      
      for (const source of DATA_SOURCE_PRIORITY) {
        if (!isDataSourceAvailable(source)) {
          console.log(`[MultiSource] è·³è¿‡ä¸å¯ç”¨çš„æ•°æ®æº: ${source}`);
          continue;
        }
        
        try {
          let result;
          
          if (source === DATA_SOURCES.BINANCE) {
            result = await fetchOpenInterestHistoryFromBinance(symbol, period, limit);
          }
          
          // CryptoCompareç›®å‰ä¸æä¾›æŒä»“é‡æ•°æ®ï¼Œè·³è¿‡
          
          if (result && result.data && result.data.length > 0) {
            results.push(result);
            addLog('success', `${source} æˆåŠŸè·å– ${result.data.length} æ¡æŒä»“é‡æ•°æ®`);
            break;
          }
        } catch (error) {
          console.error(`[MultiSource] ${source} å¤±è´¥:`, error);
        }
      }
      
      // åˆå¹¶æ•°æ®
      const merged = mergeMultiSourceData(results);
      
      if (merged.data.length === 0) {
        throw new Error('æ‰€æœ‰æ•°æ®æºå‡å¤±è´¥');
      }
      
      // ç¼“å­˜æ•°æ®
      openInterestHistoryCache.set(cacheKey, {
        data: merged,
        timestamp: Date.now()
      });
      
      return merged;
    }
    
    // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨ç¼“å­˜ç®¡ç†å™¨
    window.addEventListener('DOMContentLoaded', () => {
      // åˆå§‹åŒ–æ•°æ®æºçŠ¶æ€
      initDataSourceStatus();
      
      // å¯åŠ¨ç¼“å­˜ç®¡ç†å™¨
      cacheManager.startAutoUpdate();
    });

    // CoinGecko IDæœç´¢ç¼“å­˜ (symbol -> coinId)
    const coinIdCache = new Map();

    // æ± å­è¯¦æƒ…ç¼“å­˜
    let poolDetailCache = {};

    // ==================== æ–°é—»å…¨æ–‡å¼¹çª— ====================
    function showNewsDetail(item, type) {
      const modal = document.getElementById('newsDetailModal');
      const titleEl = document.getElementById('newsDetailTitle');
      const timeEl = document.getElementById('newsDetailTime');
      const sourceEl = document.getElementById('newsDetailSource');
      const contentEl = document.getElementById('newsDetailContent');
      const tagsEl = document.getElementById('newsDetailTags');

      // è®¾ç½®æ ‡é¢˜
      titleEl.textContent = item.title || 'æ— æ ‡é¢˜';

      // è®¾ç½®å‘å¸ƒæ—¶é—´
      timeEl.textContent = `å‘å¸ƒæ—¶é—´: ${formatPublishTime(item.publish_time)}`;

      // è®¾ç½®æ¥æº/ä½œè€…
      let sourceText = '';
      let sourceClass = '';
      if (type === 'hot' && item.source_name) {
        sourceText = item.source_name;
        sourceClass = 'bg-rose-500/20 text-rose-300';
      } else if (type === 'latest' && item.nickname) {
        sourceText = item.nickname;
        sourceClass = 'bg-blue-500/20 text-blue-300';
      } else if (type === 'kol' && item.nickname) {
        sourceText = item.nickname;
        sourceClass = 'bg-amber-500/20 text-amber-300';
      } else if (type === 'trending') {
        sourceText = 'çƒ­é—¨è¶‹åŠ¿';
        sourceClass = 'bg-cyan-500/20 text-cyan-300';
      } else {
        sourceText = 'æœªçŸ¥æ¥æº';
        sourceClass = 'bg-slate-500/20 text-slate-300';
      }
      sourceEl.textContent = sourceText;
      sourceEl.className = `px-2 py-1 rounded-md font-medium ${sourceClass}`;

      // è®¾ç½®å†…å®¹
      contentEl.textContent = item.content || 'æš‚æ— å†…å®¹';

      // è®¾ç½®æ ‡ç­¾
      if (item.tags && item.tags.length > 0) {
        tagsEl.innerHTML = item.tags.slice(0, 5).map(tag => `
          <span class="px-2 py-1 bg-slate-700 text-slate-300 rounded-md">${tag.symbol || tag.name || tag}</span>
        `).join('');
      } else {
        tagsEl.innerHTML = '';
      }

      // æ˜¾ç¤ºå¼¹çª—
      modal.classList.remove('hidden');
      document.body.style.overflow = 'hidden'; // ç¦æ­¢èƒŒæ™¯æ»šåŠ¨
    }

    function hideNewsDetail() {
      const modal = document.getElementById('newsDetailModal');
      modal.classList.add('hidden');
      document.body.style.overflow = ''; // æ¢å¤èƒŒæ™¯æ»šåŠ¨
    }

    // ==================== å¸ç§è¯¦æƒ…å¼¹çª— ====================

    // æ ¼å¼åŒ–å¤§æ•°å­—
    function formatLargeNumber(num) {
      if (num >= 1000000000000) {
        return `$${(num / 1000000000000).toFixed(2)}T`;
      } else if (num >= 1000000000) {
        return `$${(num / 1000000000).toFixed(2)}B`;
      } else if (num >= 1000000) {
        return `$${(num / 1000000).toFixed(2)}M`;
      } else if (num >= 1000) {
        return `$${(num / 1000).toFixed(2)}K`;
      } else {
        return `$${num.toFixed(2)}`;
      }
    }

    // æ ¼å¼åŒ–ä»·æ ¼ï¼ˆç²¾ç¡®æ˜¾ç¤ºï¼Œä¸ä½¿ç”¨K/M/Bå•ä½ï¼‰
    function formatPriceExact(price) {
      if (price === null || price === undefined || isNaN(price)) {
        return '$0.00';
      }

      // æ ¹æ®ä»·æ ¼å¤§å°é€‰æ‹©åˆé€‚çš„å°æ•°ä½æ•°
      if (price >= 1) {
        // å¤§äºç­‰äº1ç¾å…ƒï¼Œæ˜¾ç¤º2ä½å°æ•°
        return `$${price.toFixed(2)}`;
      } else if (price >= 0.01) {
        // å¤§äºç­‰äº0.01ç¾å…ƒï¼Œæ˜¾ç¤º4ä½å°æ•°
        return `$${price.toFixed(4)}`;
      } else {
        // å°äº0.01ç¾å…ƒï¼Œæ˜¾ç¤º6ä½å°æ•°
        return `$${price.toFixed(6)}`;
      }
    }

    // æ ¼å¼åŒ–ä¾›åº”é‡
    function formatSupply(num) {
      if (num >= 1000000000) {
        return `${(num / 1000000000).toFixed(2)}B`;
      } else if (num >= 1000000) {
        return `${(num / 1000000).toFixed(2)}M`;
      } else {
        return `${num.toLocaleString(undefined, { maximumFractionDigits: 0 })}`;
      }
    }

    // å±•å¼€/æ”¶èµ·å¸ç§ç®€ä»‹
    function toggleCoinDetailDesc() {
      const descEl = document.getElementById('coinDetailDesc');
      const toggleBtn = document.getElementById('coinDetailDescToggle');
      
      if (descEl.classList.contains('line-clamp-3')) {
        descEl.classList.remove('line-clamp-3');
        toggleBtn.textContent = 'æ”¶èµ· â†‘';
      } else {
        descEl.classList.add('line-clamp-3');
        toggleBtn.textContent = 'å±•å¼€å…¨éƒ¨ â†“';
      }
    }

    // æ˜¾ç¤ºå¸ç§è¯¦æƒ…å¼¹çª—
    async function showCoinDetail(symbol) {
      const modal = document.getElementById('coinDetailModal');

      // é‡ç½®å¼¹çª—å†…å®¹ï¼ˆç®€åŒ–ç‰ˆï¼‰
      document.getElementById('coinDetailName').textContent = symbol;
      document.getElementById('coinDetailPrice').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailChange').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailVolume').textContent = '$åŠ è½½ä¸­...';
      document.getElementById('coinDetailOpenInterest').textContent = '$åŠ è½½ä¸­...';
      document.getElementById('coinDetailOpenInterestCount').textContent = '';
      document.getElementById('coinDetailFundingRate').textContent = 'åŠ è½½ä¸­...';
      document.getElementById('coinDetailFundingTime').textContent = '';

      // æ˜¾ç¤ºå¼¹çª—
      modal.classList.remove('hidden');
      document.body.style.overflow = 'hidden';

      // ä½¿ç”¨æ–°çš„ç¼“å­˜ç®¡ç†å™¨æ£€æŸ¥ç¼“å­˜
      let cachedData = cacheManager.get(symbol);

      if (!cachedData) {
        // ç¼“å­˜ä¸å­˜åœ¨ï¼Œè·å–æ•°æ®
        addLog('info', 'ç¼“å­˜æœªå‘½ä¸­ï¼Œè·å– ' + symbol + ' å¸ç§è¯¦æƒ…æ•°æ®...');

        // å¹¶è¡Œè·å–èµ„é‡‘è´¹ç‡å’ŒæŒä»“é‡ï¼ˆä¸å†è·å–å¸‚å€¼æ•°æ®ï¼‰
        const [fundingRateData, openInterestData] = await Promise.all([
          fetchBinanceFundingRate(symbol).catch(() => null),
          fetchOpenInterestWithFallback(symbol).catch(() => null)
        ]);

        // ç¼“å­˜æ•°æ®
        cachedData = {
          coinGecko: null, // ä¸å†è·å–å¸‚å€¼æ•°æ®
          volume: null,
          fundingRate: fundingRateData,
          openInterest: openInterestData,
          timestamp: Date.now()
        };
        
        // ä½¿ç”¨ç¼“å­˜ç®¡ç†å™¨ä¿å­˜ï¼ˆåˆ¤æ–­æ˜¯å¦ä¸ºé«˜ä¼˜å…ˆçº§ï¼‰
        const priority = highPrioritySymbols.has(symbol) ? 'high' : 'normal';
        cacheManager.set(symbol, cachedData, priority);
        
        addLog('success', symbol + ' å¸ç§è¯¦æƒ…æ•°æ®è·å–å®Œæˆ');
      } else {
        addLog('info', 'ç¼“å­˜å‘½ä¸­ï¼Œä½¿ç”¨ ' + symbol + ' å¸ç§è¯¦æƒ…æ•°æ®');
        
        // åå°åˆ·æ–°ï¼ˆå¦‚æœç¼“å­˜è¶…è¿‡1åˆ†é’Ÿï¼‰
        if (Date.now() - cachedData.cache.lastUpdated > 60000) {
          console.log(`[Detail] ${symbol} ç¼“å­˜è¾ƒæ—§ï¼Œåå°åˆ·æ–°...`);
          cacheManager.refreshInBackground(symbol);
        }
      }

      // æ›´æ–°å¼¹çª—å†…å®¹
      updateCoinDetailModal(symbol, cachedData);
      
      // å¦‚æœæ˜¯ä¿¡å·ç›‘æ§ä¸­çš„å¸ç§ï¼Œä¼˜å…ˆé¢„åŠ è½½å›¾è¡¨æ•°æ®
      if (isHighPrioritySymbol(symbol)) {
        addLog('info', `${symbol} æ˜¯ä¿¡å·ç›‘æ§å¸ç§ï¼Œä¼˜å…ˆåŠ è½½å›¾è¡¨æ•°æ®...`);
        
        // ä¼˜å…ˆåŠ è½½å›¾è¡¨æ•°æ®ï¼ˆä¸é˜»å¡UIï¼‰
        Promise.all([
          fetchPriceHistoryWithFallback(symbol, currentPricePeriod, 100).catch(() => null),
          isFuturesSymbol(symbol) ? fetchOpenInterestHistoryWithFallback(symbol, '1h', 100).catch(() => null) : Promise.resolve(null)
        ]).then(([priceData, oiData]) => {
          if (priceData && priceData.data.length > 0) {
            addLog('success', `${symbol} ä»·æ ¼æ•°æ®é¢„åŠ è½½å®Œæˆ: ${priceData.data.length} æ¡`);
          }
          if (oiData && oiData.data.length > 0) {
            addLog('success', `${symbol} æŒä»“é‡æ•°æ®é¢„åŠ è½½å®Œæˆ: ${oiData.data.length} æ¡`);
          }
        }).catch(err => {
          console.error(`é¢„åŠ è½½å›¾è¡¨æ•°æ®å¤±è´¥:`, err);
        });
      }
    }

    // ==================== è¾…åŠ©å‡½æ•° ====================
    
    // æ ¼å¼åŒ–ä»·æ ¼å˜åŒ–
    function formatPriceChange(value) {
      if (value === null || value === undefined || isNaN(value)) {
        return '0.00%';
      }
      const sign = value >= 0 ? '+' : '';
      return sign + value.toFixed(2) + '%';
    }

    // è·å–Twitteræœç´¢URL
    function getTwitterSearchUrl(symbol) {
      return `https://x.com/search?q=%24${symbol}&src=cashtag_click`;
    }
    
    // æ›´æ–°ä»·æ ¼å˜åŒ–å…ƒç´ 
    function updatePriceChange(elementId, value) {
      const el = document.getElementById(elementId);
      if (!el) return;
      
      const val = parseFloat(value) || 0;
      const text = formatPriceChange(val);
      
      el.textContent = text;
      el.className = 'text-white font-bold ' + (val >= 0 ? 'text-red-400' : 'text-green-400'); // çº¢æ¶¨ç»¿è·Œï¼ˆä¸­å›½è‚¡å¸‚æ ‡å‡†ï¼‰
    }

    // æ›´æ–°å¸ç§è¯¦æƒ…å¼¹çª—å†…å®¹
    function updateCoinDetailModal(symbol, data) {
      // æ›´æ–°å½“å‰å¸ç§ç¬¦å·
      currentCoinDetailSymbol = symbol;

      const coinGecko = data.coinGecko;
      const openInterestData = data.openInterest;
      const fundingRateData = data.fundingRate;

      let currentPrice = 0;
      let change24h = 0;
      let volume24h = 0;
      let coinName = symbol;
      let coinSymbol = symbol.replace('USDT', '');

      // ä» binancePrices è·å–å®æ—¶æ•°æ®
      const tickerData = binancePrices.find(p => p.symbol === symbol);
      if (tickerData) {
        currentPrice = parseFloat(tickerData.price);
        change24h = parseFloat(tickerData.priceChangePercent);
        volume24h = parseFloat(tickerData.quoteVolume);
      }

      // è·å–CoinGeckoæ•°æ®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      if (coinGecko) {
        // å¦‚æœ binancePrices ä¸­æ²¡æœ‰æ•°æ®ï¼Œåˆ™ä½¿ç”¨ CoinGecko æ•°æ®
        if (currentPrice === 0) {
          currentPrice = coinGecko.currentPrice?.usd || 0;
        }
        if (change24h === 0) {
          change24h = coinGecko.priceChange24h || 0;
        }
        if (volume24h === 0) {
          volume24h = coinGecko.totalVolume?.usd || 0;
        }
        coinName = coinGecko.name || symbol;
        coinSymbol = coinGecko.symbol || coinSymbol;
      }

      // æ›´æ–°å¸ç§åç§°
      document.getElementById('coinDetailName').textContent = symbol;

      // æ›´æ–°ä»·æ ¼å’Œæ¶¨è·Œ
      document.getElementById('coinDetailPrice').textContent = formatLargeNumber(currentPrice);
      const changeEl = document.getElementById('coinDetailChange');
      changeEl.textContent = (change24h >= 0 ? '+' : '') + change24h.toFixed(2) + '%';
      changeEl.className = 'text-sm font-bold ' + (change24h >= 0 ? 'text-green-600' : 'text-red-600'); // ç»¿æ¶¨çº¢è·Œï¼ˆå›½é™…æ ‡å‡†ï¼‰

      // æ›´æ–°24häº¤æ˜“é‡
      document.getElementById('coinDetailVolume').textContent = formatLargeNumber(volume24h);

      // æ›´æ–°æŒä»“é‡
      if (openInterestData && openInterestData.openInterest) {
        const oiAmount = openInterestData.openInterest;
        document.getElementById('coinDetailOpenInterest').textContent = formatLargeNumber(oiAmount);

        // è®¡ç®—æŒä»“é‡å¼ æ•°ï¼ˆå¼ æ•° = æŒä»“é‡‘é¢ / å½“å‰ä»·æ ¼ï¼‰
        if (currentPrice > 0) {
          const oiCount = oiAmount / currentPrice;
          let countText = '';
          if (oiCount >= 1000000) {
            countText = `(${(oiCount / 1000000).toFixed(1)}Må¼ )`;
          } else if (oiCount >= 1000) {
            countText = `(${(oiCount / 1000).toFixed(1)}Kå¼ )`;
          } else {
            countText = `(${oiCount.toFixed(0)}å¼ )`;
          }
          document.getElementById('coinDetailOpenInterestCount').textContent = countText;
        }
      } else {
        // æŒä»“é‡æ•°æ®ä¸ºnullï¼Œå¯èƒ½æ˜¯æ— åˆçº¦äº¤æ˜“æˆ–APIé™åˆ¶
        document.getElementById('coinDetailOpenInterest').textContent = 'æš‚æ— æ•°æ®';
        document.getElementById('coinDetailOpenInterestCount').textContent = '(æ— åˆçº¦)';
      }

      // æ›´æ–°èµ„é‡‘è´¹ç‡
      if (fundingRateData) {
        const ratePercent = fundingRateData.ratePercent;
        const fundingEl = document.getElementById('coinDetailFundingRate');
        fundingEl.textContent = ratePercent.toFixed(4) + '%';
        fundingEl.className = 'text-sm font-bold ' + (ratePercent >= 0 ? 'text-red-600' : 'text-green-600'); // çº¢æ¶¨ç»¿è·Œï¼ˆä¸­å›½è‚¡å¸‚æ ‡å‡†ï¼‰

        // æ·»åŠ æ–¹å‘ç®­å¤´
        const arrow = ratePercent >= 0 ? 'â†‘' : 'â†“';
        fundingEl.textContent = arrow + ' ' + ratePercent.toFixed(4) + '%';

        // è®¡ç®—ä¸‹æ¬¡ç»“ç®—æ—¶é—´
        if (fundingRateData.fundingTime) {
          const nextFundingTime = new Date(fundingRateData.fundingTime);
          const now = new Date();
          const hoursLeft = Math.floor((nextFundingTime - now) / (1000 * 60 * 60));
          if (hoursLeft > 0) {
            document.getElementById('coinDetailFundingTime').textContent = `ä¸‹æ¬¡ï¼š${hoursLeft}å°æ—¶å`;
          } else if (hoursLeft > -1) {
            document.getElementById('coinDetailFundingTime').textContent = `ä¸‹æ¬¡ï¼š< 1å°æ—¶`;
          } else {
            document.getElementById('coinDetailFundingTime').textContent = '';
          }
        }
      } else {
        document.getElementById('coinDetailFundingRate').textContent = 'N/A';
        document.getElementById('coinDetailFundingTime').textContent = '';
      }

      // æ›´æ–°å¤–éƒ¨é“¾æ¥
      const twitterSearchUrl = `https://x.com/search?q=%24${coinSymbol}&src=cashtag_click`;
      const twitterEl = document.getElementById('coinDetailTwitter');
      if (twitterEl) twitterEl.href = twitterSearchUrl;
      
      const twitterSearchEl = document.getElementById('coinDetailTwitterSearch');
      if (twitterSearchEl) twitterSearchEl.href = twitterSearchUrl;

      // æ¸²æŸ“ä»·æ ¼Kçº¿å›¾
      renderPriceChart(symbol, coinGecko);

      // æ¸²æŸ“æˆäº¤é‡å†å²è¶‹åŠ¿å›¾
      renderVolumeChart(symbol);
    }

    // æ¸²æŸ“ä»·æ ¼Kçº¿å›¾
    async function renderPriceChart(symbol, coinGecko) {
      const canvas = document.getElementById('priceChart');
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      
      // è®¾ç½®canvaså°ºå¯¸
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      // æ¸…ç©ºç”»å¸ƒ
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // æ˜¾ç¤ºåŠ è½½ä¸­
      ctx.fillStyle = '#94a3b8';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('åŠ è½½ä¸­...', canvas.width / 2, canvas.height / 2);

      try {
        // è·å–ä»·æ ¼å†å²æ•°æ®ï¼ˆä½¿ç”¨å¤šæºè·å–ï¼‰
        const result = await fetchPriceHistoryWithFallback(symbol, currentPricePeriod, 100);
        const priceHistory = result.data;
        const sources = result.sources || [];
        
        if (!priceHistory || priceHistory.length === 0) {
          ctx.fillStyle = '#94a3b8';
          ctx.fillText('æš‚æ— æ•°æ®', canvas.width / 2, canvas.height / 2);
          
          // æ¸…ç©ºå³ä¾§ä»·æ ¼æ ‡ç­¾å®¹å™¨
          const priceLabelsContainer = document.getElementById('priceLabelsContainer');
          if (priceLabelsContainer) {
            priceLabelsContainer.innerHTML = '<div class="text-xs text-slate-400 text-center">æš‚æ— æ•°æ®</div>';
          }
          return;
        }

        // æ¸…ç©ºç”»å¸ƒå¹¶ç»˜åˆ¶å›¾è¡¨
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // è®¡ç®—æ•°æ®èŒƒå›´
        const prices = priceHistory.map(p => p.price);
        const minPrice = Math.min(...prices);
        const maxPrice = Math.max(...prices);
        const priceRange = maxPrice - minPrice;

        // ç»˜åˆ¶ä»·æ ¼çº¿
        ctx.beginPath();
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2;

        priceHistory.forEach((point, index) => {
          const x = (index / (priceHistory.length - 1)) * (canvas.width - 10) + 5;
          const y = canvas.height - 30 - ((point.price - minPrice) / priceRange) * (canvas.height - 60);

          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });

        ctx.stroke();

        // ç»˜åˆ¶æ¸å˜å¡«å……
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, 'rgba(59, 130, 246, 0.2)');
        gradient.addColorStop(1, 'rgba(59, 130, 246, 0)');

        ctx.lineTo(canvas.width - 5, canvas.height - 30);
        ctx.lineTo(5, canvas.height - 30);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        // ç»˜åˆ¶ç½‘æ ¼çº¿
        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;
        
        // æ¨ªå‘ç½‘æ ¼çº¿
        for (let i = 0; i <= 4; i++) {
          const y = 30 + (i / 4) * (canvas.height - 60);
          ctx.beginPath();
          ctx.moveTo(5, y);
          ctx.lineTo(canvas.width - 5, y);
          ctx.stroke();
        }

        // çºµå‘ç½‘æ ¼çº¿ï¼ˆèµ·ç‚¹ã€ä¸­é—´ã€ç»ˆç‚¹ï¼‰
        const timePoints = [0, Math.floor(priceHistory.length / 2), priceHistory.length - 1];
        timePoints.forEach(index => {
          const x = (index / (priceHistory.length - 1)) * (canvas.width - 10) + 5;
          ctx.beginPath();
          ctx.moveTo(x, 30);
          ctx.lineTo(x, canvas.height - 30);
          ctx.stroke();

          // ç»˜åˆ¶æ—¶é—´æ ‡ç­¾
          const date = new Date(priceHistory[index].timestamp);
          ctx.fillStyle = '#64748b';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`${date.getMonth() + 1}/${date.getDate()}`, x, canvas.height - 5);
        });

        // æ˜¾ç¤ºå½“å‰ä»·æ ¼
        const lastPrice = priceHistory[priceHistory.length - 1].price;
        ctx.fillStyle = '#0f172a';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('å½“å‰: ' + formatPriceExact(lastPrice), 5, 15);

        // æ˜¾ç¤ºæ¶¨è·Œå¹…
        const firstPrice = priceHistory[0].price;
        const change = ((lastPrice - firstPrice) / firstPrice * 100);
        const changeText = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
        ctx.fillStyle = change >= 0 ? '#dc2626' : '#16a34a'; // çº¢æ¶¨ç»¿è·Œï¼ˆä¸­å›½è‚¡å¸‚æ ‡å‡†ï¼‰
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(changeText, canvas.width - 5, 15);

        // åœ¨å³ä¾§å®¹å™¨æ˜¾ç¤ºä»·æ ¼æ ‡ç­¾
        const priceLabelsContainer = document.getElementById('priceLabelsContainer');
        if (priceLabelsContainer) {
          // ç”Ÿæˆ5ä¸ªä»·æ ¼æ ‡ç­¾ï¼ˆä»é«˜åˆ°ä½ï¼‰
          let labelsHTML = '';
          for (let i = 0; i <= 4; i++) {
            const priceLabel = minPrice + (1 - i / 4) * priceRange;
            labelsHTML += `
              <div class="text-xs text-slate-600 font-medium">
                ${formatPriceExact(priceLabel)}
              </div>
            `;
          }
          priceLabelsContainer.innerHTML = labelsHTML;
        }

        // ç»˜åˆ¶æ•°æ®æºæ ‡è®°
        if (sources.length > 0) {
          const sourceMap = {
            'binance': 'Binance',
            'okx': 'OKX',
            'bybit': 'Bybit',
            'cryptocompare': 'CryptoCompare'
          };
          const sourceText = sources.map(s => sourceMap[s] || s).join(' + ');
          ctx.fillStyle = '#64748b';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`ğŸ“Š ${sourceText}`, canvas.width / 2, canvas.height - 8);
        }

      } catch (error) {
        console.error('æ¸²æŸ“ä»·æ ¼Kçº¿å›¾å¤±è´¥:', error);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ef4444';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('åŠ è½½å¤±è´¥', canvas.width / 2, canvas.height / 2);
        
        // æ¸…ç©ºå³ä¾§ä»·æ ¼æ ‡ç­¾å®¹å™¨
        const priceLabelsContainer = document.getElementById('priceLabelsContainer');
        if (priceLabelsContainer) {
          priceLabelsContainer.innerHTML = '<div class="text-xs text-red-400 text-center">åŠ è½½å¤±è´¥</div>';
        }
      }
    }

    // è·å–ä»·æ ¼å†å²æ•°æ®
    async function fetchPriceHistory(symbol, days = 30) {
      const cacheKey = `priceHistory_${symbol}_${days}`;
      
      // æ£€æŸ¥ç¼“å­˜
      if (priceHistoryCache.has(cacheKey)) {
        const cached = priceHistoryCache.get(cacheKey);
        if (Date.now() - cached.timestamp < 60000) { // 1åˆ†é’Ÿç¼“å­˜
          return cached.data;
        }
      }

      try {
        // ä½¿ç”¨Binance Kçº¿APIè·å–å†å²ä»·æ ¼æ•°æ®
        const interval = '1d'; // æ—¥çº¿
        const limit = days;
        
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
        
        if (!response.ok) {
          throw new Error('è·å–ä»·æ ¼å†å²å¤±è´¥');
        }

        const klines = await response.json();

        // è½¬æ¢ä¸ºä»·æ ¼å†å²æ ¼å¼
        const priceHistory = klines.map(kline => ({
          timestamp: kline[0],
          price: parseFloat(kline[4]) // æ”¶ç›˜ä»·
        }));

        // ç¼“å­˜æ•°æ®
        priceHistoryCache.set(cacheKey, {
          data: priceHistory,
          timestamp: Date.now()
        });

        return priceHistory;

      } catch (error) {
        console.error('è·å–ä»·æ ¼å†å²å¤±è´¥:', error);
        return null;
      }
    }

    // æ¸²æŸ“æˆäº¤é‡å†å²è¶‹åŠ¿å›¾
    let currentVolumePeriod = '1h';
    let volumeChartData = null;

    async function renderVolumeChart(symbol, period = currentVolumePeriod) {
      const canvas = document.getElementById('volumeChart');
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      
      // è®¾ç½®canvaså°ºå¯¸
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      // æ¸…ç©ºç”»å¸ƒ
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // æ˜¾ç¤ºåŠ è½½ä¸­
      ctx.fillStyle = '#94a3b8';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('åŠ è½½ä¸­...', canvas.width / 2, canvas.height / 2);

      try {
        // è·å–Kçº¿æ•°æ®ï¼ˆæˆäº¤é‡åŒ…å«åœ¨Kçº¿æ•°æ®ä¸­ï¼‰
        let klineData;
        try {
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 5000)
          );
          klineData = await Promise.race([
            fetchRawKlineData(symbol, period),
            timeoutPromise
          ]);
        } catch (error) {
          addLog('warning', `è·å– ${symbol} Kçº¿æ•°æ®è¶…æ—¶`);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#94a3b8';
          ctx.fillText('åŠ è½½è¶…æ—¶', canvas.width / 2, canvas.height / 2);
          document.getElementById('volumeInsight').textContent = 'âš ï¸ æ•°æ®åŠ è½½è¶…æ—¶ï¼Œè¯·ç¨ååˆ·æ–°é‡è¯•';
          return;
        }

        if (!klineData || klineData.length === 0) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#94a3b8';
          ctx.fillText('æš‚æ— æ•°æ®', canvas.width / 2, canvas.height / 2);
          document.getElementById('volumeInsight').textContent = 'âš ï¸ è¯¥å¸ç§å¯èƒ½æœªåœ¨ç°è´§å¸‚åœºä¸Šçº¿æˆ–æš‚æ— äº¤æ˜“æ•°æ®';
          return;
        }

        // ä»Kçº¿æ•°æ®ä¸­æå–æˆäº¤é‡
        const volumeData = klineData.map(k => ({
          timestamp: k.time,
          volume: k.volume
        }));

        // æ¸…ç©ºç”»å¸ƒå¹¶ç»˜åˆ¶å›¾è¡¨
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // è®¡ç®—æ•°æ®èŒƒå›´
        const volumeValues = volumeData.map(d => d.volume);
        const minVolume = Math.min(...volumeValues);
        const maxVolume = Math.max(...volumeValues);
        const volumeRange = maxVolume - minVolume;

        // ç»˜åˆ¶æˆäº¤é‡çº¿
        ctx.beginPath();
        ctx.strokeStyle = '#8b5cf6';
        ctx.lineWidth = 2;

        volumeData.forEach((point, index) => {
          const x = (index / (volumeData.length - 1)) * (canvas.width - 40) + 20;
          const y = canvas.height - 20 - ((point.volume - minVolume) / volumeRange) * (canvas.height - 40);

          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });

        ctx.stroke();

        // ç»˜åˆ¶æ¸å˜å¡«å……
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, 'rgba(139, 92, 246, 0.2)');
        gradient.addColorStop(1, 'rgba(139, 92, 246, 0)');

        ctx.lineTo(canvas.width - 20, canvas.height - 20);
        ctx.lineTo(20, canvas.height - 20);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        // ç»˜åˆ¶ç½‘æ ¼çº¿
        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;
        
        // æ¨ªå‘ç½‘æ ¼çº¿
        for (let i = 0; i <= 4; i++) {
          const y = 20 + (i / 4) * (canvas.height - 40);
          ctx.beginPath();
          ctx.moveTo(20, y);
          ctx.lineTo(canvas.width - 20, y);
          ctx.stroke();

          // ç»˜åˆ¶æˆäº¤é‡æ ‡ç­¾
          const volumeLabel = minVolume + (1 - i / 4) * volumeRange;
          ctx.fillStyle = '#64748b';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(formatLargeNumber(volumeLabel), canvas.width - 80, y + 3);
        }

        // çºµå‘ç½‘æ ¼çº¿
        const timePoints = [0, Math.floor(volumeData.length / 2), volumeData.length - 1];
        timePoints.forEach(index => {
          const x = (index / (volumeData.length - 1)) * (canvas.width - 40) + 20;
          ctx.beginPath();
          ctx.moveTo(x, 20);
          ctx.lineTo(x, canvas.height - 20);
          ctx.stroke();

          // ç»˜åˆ¶æ—¶é—´æ ‡ç­¾
          const date = new Date(volumeData[index].timestamp);
          ctx.fillStyle = '#64748b';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`${date.getMonth() + 1}/${date.getDate()}`, x, canvas.height - 5);
        });

        // æ˜¾ç¤ºå½“å‰æˆäº¤é‡
        const lastVolume = volumeData[volumeData.length - 1].volume;
        ctx.fillStyle = '#0f172a';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('å½“å‰: ' + formatLargeNumber(lastVolume), 20, 15);

        // è®¡ç®—æˆäº¤é‡å˜åŒ–
        const firstVolume = volumeData[0].volume;
        const volumeChange = ((lastVolume - firstVolume) / firstVolume * 100);
        const volumeChangeText = (volumeChange >= 0 ? '+' : '') + volumeChange.toFixed(2) + '%';
        ctx.fillStyle = volumeChange >= 0 ? '#16a34a' : '#dc2626';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(volumeChangeText, canvas.width - 20, 15);

        // æ›´æ–°æˆäº¤é‡æ´å¯Ÿ
        const insight = analyzeVolumeTrend(volumeData);
        document.getElementById('volumeInsight').textContent = insight;

        // ç»˜åˆ¶æ•°æ®æºæ ‡è®°
        ctx.fillStyle = '#64748b';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`ğŸ“Š ${currentApiProvider.toUpperCase()}`, canvas.width / 2, canvas.height - 8);

        // ä¿å­˜æ•°æ®
        volumeChartData = volumeData;

      } catch (error) {
        console.error('æ¸²æŸ“æˆäº¤é‡å›¾è¡¨å¤±è´¥:', error);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ef4444';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('åŠ è½½å¤±è´¥', canvas.width / 2, canvas.height / 2);
        document.getElementById('volumeInsight').textContent = 'âš ï¸ å›¾è¡¨æ¸²æŸ“å¤±è´¥: ' + error.message;
      }
    }

    // åˆ†ææˆäº¤é‡è¶‹åŠ¿
    function analyzeVolumeTrend(volumeData) {
      if (!volumeData || volumeData.length < 2) return '';
      
      const lastVolume = volumeData[volumeData.length - 1].volume;
      const firstVolume = volumeData[0].volume;
      const change = ((lastVolume - firstVolume) / firstVolume * 100);
      
      // è®¡ç®—å¹³å‡æˆäº¤é‡
      const avgVolume = volumeData.reduce((sum, d) => sum + d.volume, 0) / volumeData.length;
      const aboveAvg = volumeData.filter(d => d.volume > avgVolume).length;
      
      let trend = '';
      if (change > 20) {
        trend = 'ğŸ“ˆ æˆäº¤é‡æ˜¾è‘—å¢åŠ ';
      } else if (change > 5) {
        trend = 'ğŸ“Š æˆäº¤é‡æ¸©å’Œå¢é•¿';
      } else if (change < -20) {
        trend = 'ğŸ“‰ æˆäº¤é‡æ˜¾è‘—å‡å°‘';
      } else if (change < -5) {
        trend = 'ğŸ“Š æˆäº¤é‡æ¸©å’Œä¸‹é™';
      } else {
        trend = 'â¡ï¸ æˆäº¤é‡ç›¸å¯¹ç¨³å®š';
      }
      
      return `${trend} (${change >= 0 ? '+' : ''}${change.toFixed(1)}%)`;
    }

    // åˆ‡æ¢æˆäº¤é‡å‘¨æœŸ
    // å…¨å±€å˜é‡
    let currentCoinDetailSymbol = null;  // å½“å‰å¼¹çª—æ˜¾ç¤ºçš„å¸ç§
    // currentVolumePeriod å’Œ volumeChartData å·²åœ¨å‰é¢å®šä¹‰ï¼ˆç¬¬2359è¡Œï¼‰

    function changeVolumePeriod(period) {
      currentVolumePeriod = period;

      // æ›´æ–°æŒ‰é’®æ ·å¼
      const buttons = ['volumePeriod5m', 'volumePeriod15m', 'volumePeriod1h', 'volumePeriod4h', 'volumePeriod1d'];
      const periodMap = { '5m': 'volumePeriod5m', '15m': 'volumePeriod15m', '1h': 'volumePeriod1h', '4h': 'volumePeriod4h', '1d': 'volumePeriod1d' };

      buttons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
          if (btnId === periodMap[period]) {
            btn.className = 'px-2 py-0.5 text-xs bg-sky-500 text-white rounded';
          } else {
            btn.className = 'px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300';
          }
        }
      });

      // é‡æ–°æ¸²æŸ“å›¾è¡¨
      if (currentCoinDetailSymbol) {
        renderVolumeChart(currentCoinDetailSymbol, period);
      }
    }

    // è·å–æŒä»“é‡å†å²æ•°æ®ï¼ˆå·²åºŸå¼ƒï¼Œä¿ç•™ç”¨äºå‘åå…¼å®¹ï¼‰
    async function fetchOpenInterestHistory(symbol, period = '1d') {
      const cacheKey = `oiHistory_${symbol}_${period}`;
      
      // æ£€æŸ¥ç¼“å­˜
      if (openInterestHistoryCache.has(cacheKey)) {
        const cached = openInterestHistoryCache.get(cacheKey);
        if (Date.now() - cached.timestamp < 60000) { // 1åˆ†é’Ÿç¼“å­˜
          return cached.data;
        }
      }

      try {
        // æ˜ å°„å‘¨æœŸåˆ°Binance APIå‚æ•°
        const periodMap = {
          '1d': { interval: '1h', limit: 24 },
          '1w': { interval: '1d', limit: 7 },
          '1m': { interval: '1d', limit: 30 }
        };

        const params = periodMap[period] || periodMap['1d'];
        
        const response = await fetch(`https://fapi.binance.com/futures/data/openInterestHist?symbol=${symbol}&period=${params.interval}&limit=${params.limit}`);
        
        if (!response.ok) {
          throw new Error('è·å–æŒä»“é‡å†å²å¤±è´¥');
        }

        const data = await response.json();

        // è½¬æ¢ä¸ºæŒä»“é‡å†å²æ ¼å¼
        const oiHistory = data.map(item => ({
          timestamp: item.timestamp,
          openInterest: parseFloat(item.sumOpenInterest)
        }));

        // ç¼“å­˜æ•°æ®
        openInterestHistoryCache.set(cacheKey, {
          data: oiHistory,
          timestamp: Date.now()
        });

        return oiHistory;

      } catch (error) {
        console.error('è·å–æŒä»“é‡å†å²å¤±è´¥:', error);
        return null;
      }
    }

    // åˆ†ææŒä»“é‡è¶‹åŠ¿
    function analyzeOpenInterestTrend(oiData) {
      if (!oiData || oiData.length < 2) return '';

      const firstOI = oiData[0].openInterest;
      const lastOI = oiData[oiData.length - 1].openInterest;
      const change = ((lastOI - firstOI) / firstOI * 100);

      // è®¡ç®—è¶‹åŠ¿æ–œç‡
      let upCount = 0;
      let downCount = 0;
      
      for (let i = 1; i < oiData.length; i++) {
        if (oiData[i].openInterest > oiData[i-1].openInterest) {
          upCount++;
        } else if (oiData[i].openInterest < oiData[i-1].openInterest) {
          downCount++;
        }
      }

      const trend = upCount > downCount ? 'ä¸Šå‡' : 'ä¸‹é™';
      const strength = Math.abs(change) > 10 ? 'å¼ºåŠ²' : 'æ¸©å’Œ';
      
      let sentiment = '';
      if (trend === 'ä¸Šå‡') {
        sentiment = change > 20 ? 'èµ„é‡‘å¤§é‡æµå…¥ï¼Œå¯èƒ½é¢„ç¤ºç‰›å¸‚' : 'èµ„é‡‘é€æ­¥æµå…¥ï¼Œå¸‚åœºæƒ…ç»ªå¥½è½¬';
      } else {
        sentiment = change < -20 ? 'èµ„é‡‘å¤§é‡æµå‡ºï¼Œéœ€è­¦æƒ•é£é™©' : 'èµ„é‡‘é€æ­¥æµå‡ºï¼Œå¸‚åœºæƒ…ç»ªè°¨æ…';
      }

      return `${strength}${trend} (${change >= 0 ? '+' : ''}${change.toFixed(2)}%) Â· ${sentiment}`;
    }

    // å½“å‰ä»·æ ¼Kçº¿å›¾å‘¨æœŸ
    let currentPricePeriod = '4h';

    // åˆ‡æ¢ä»·æ ¼Kçº¿å›¾å‘¨æœŸ
    function changePricePeriod(period) {
      currentPricePeriod = period;
      
      // æ›´æ–°æŒ‰é’®æ ·å¼
      ['5m', '15m', '1h', '4h', '1d'].forEach(p => {
        const btn = document.getElementById(`pricePeriod${p}`);
        
        if (p === period) {
          btn.className = 'px-2 py-0.5 text-xs bg-sky-500 text-white rounded';
        } else {
          btn.className = 'px-2 py-0.5 text-xs bg-slate-200 text-slate-600 rounded hover:bg-slate-300';
        }
      });

      // é‡æ–°æ¸²æŸ“å›¾è¡¨
      const symbol = document.getElementById('coinDetailName').textContent;
      if (symbol) {
        renderPriceChart(symbol);
      }
    }

    // éšè—å¸ç§è¯¦æƒ…å¼¹çª—
    function hideCoinDetail() {
      const modal = document.getElementById('coinDetailModal');
      modal.classList.add('hidden');
      document.body.style.overflow = ''; // æ¢å¤èƒŒæ™¯æ»šåŠ¨
    }

    // ==================== æ± å­è¯¦æƒ…ç³»ç»Ÿ ====================

    // æ˜¾ç¤ºæ± å­è¯¦æƒ…å¼¹çª—
    async function showPoolDetail(poolAddress, baseTokenAddress, network) {
      const modal = document.getElementById('poolDetailModal');

      // æ£€æŸ¥ç¼“å­˜
      const cacheKey = `${network}-${poolAddress}`;
      if (poolDetailCache[cacheKey]) {
        updatePoolDetailModal(poolDetailCache[cacheKey]);
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        return;
      }

      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      modal.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
      document.getElementById('poolDetailName').innerHTML = 'åŠ è½½ä¸­...';
      document.getElementById('poolDetailTVL').innerHTML = '--';

      try {
        // è·å–æ± å­è¯¦æƒ…
        const apiUrl = `https://api.geckoterminal.com/api/v2/networks/${network}/pools/${poolAddress}`;

        const response = await fetchWithRetry(apiUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        }, 2, false);

        if (!response.ok) {
          throw new Error(`APIè¿”å›é”™è¯¯: ${response.status}`);
        }

        const json = await response.json();

        if (!json || !json.data) {
          throw new Error('æ•°æ®ä¸ºç©º');
        }

        const poolData = json.data;
        const attributes = poolData.attributes;

        // ä¿å­˜åˆ°ç¼“å­˜
        poolDetailCache[cacheKey] = {
          network,
          poolAddress,
          baseTokenAddress,
          attributes
        };

        // æ›´æ–°å¼¹çª—å†…å®¹
        updatePoolDetailModal(poolDetailCache[cacheKey]);

        addLog('success', `æ± å­è¯¦æƒ…å·²åŠ è½½: ${attributes.name}`);
      } catch (error) {
        addLog('error', 'æ± å­è¯¦æƒ…è·å–å¤±è´¥', error.message);
        
        // æ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯å’Œå¤–éƒ¨é“¾æ¥ï¼ˆå³ä½¿APIå¤±è´¥ï¼‰
        const baseTokenSymbol = poolAddress.substring(0, 6);
        const twitterUrl = getTwitterSearchUrl(baseTokenSymbol);
        const geckoTerminalUrl = `https://www.geckoterminal.com/${network}/pools/${poolAddress}`;
        const dexscreenerUrl = `https://dexscreener.com/${network}/${poolAddress}`;
        
        document.getElementById('poolDetailName').innerHTML = `æ± å­è¯¦æƒ… (æ•°æ®è·å–å¤±è´¥)`;
        document.getElementById('poolDetailTVL').innerHTML = '--';
        document.getElementById('poolDetailBaseToken').innerHTML = baseTokenSymbol;
        document.getElementById('poolDetailQuoteToken').innerHTML = '--';
        document.getElementById('poolDetailTVLMetric').innerHTML = '--';
        document.getElementById('poolDetailVolume24h').innerHTML = '--';
        document.getElementById('poolDetailPrice').innerHTML = '--';
        document.getElementById('poolDetailDex').innerHTML = network.toUpperCase();
        document.getElementById('poolDetailNetwork').innerHTML = network.toUpperCase();
        document.getElementById('poolDetailAddress').innerHTML = poolAddress;
        document.getElementById('poolDetailTwitter').href = twitterUrl;
        document.getElementById('poolDetailGeckoTerminal').href = geckoTerminalUrl;
        document.getElementById('poolDetailDexscreener').href = dexscreenerUrl;
        
        // æ˜¾ç¤ºæç¤ºä¿¡æ¯
        document.getElementById('poolDetailBadges').innerHTML =
          '<span class="bg-red-500/20 text-red-400 px-2 py-1 rounded text-xs">æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¯·é€šè¿‡å¤–éƒ¨é“¾æ¥æŸ¥çœ‹</span>';
      }
    }

    // æ›´æ–°æ± å­è¯¦æƒ…å¼¹çª—å†…å®¹
    function updatePoolDetailModal(data) {
      const { network, poolAddress, baseTokenAddress, attributes } = data;

      // æ± å­ä¿¡æ¯å¤´éƒ¨
      document.getElementById('poolDetailName').innerHTML = attributes.name || 'æœªçŸ¥æ± å­';
      document.getElementById('poolDetailTVL').innerHTML = formatNumber(attributes.reserve_in_usd || 0, 'USD', 2);

      // å¾½ç« 
      const badgesHtml = [
        `<span class="bg-cyan-500/20 text-cyan-400 px-2 py-1 rounded text-xs">${network.toUpperCase()}</span>`,
        `<span class="bg-purple-500/20 text-purple-400 px-2 py-1 rounded text-xs">${attributes.dex?.name || 'Unknown'}</span>`,
        attributes.is_verified ? '<span class="bg-green-500/20 text-green-400 px-2 py-1 rounded text-xs">âœ“ å·²éªŒè¯</span>' : ''
      ].filter(Boolean).join('');
      document.getElementById('poolDetailBadges').innerHTML = badgesHtml;

      // äº¤æ˜“å¯¹ä¿¡æ¯
      document.getElementById('poolDetailBaseToken').innerHTML = attributes.base_token?.symbol || '--';
      document.getElementById('poolDetailBaseTokenAddress').innerHTML = attributes.base_token?.address || '--';
      document.getElementById('poolDetailQuoteToken').innerHTML = attributes.quote_token?.symbol || '--';
      document.getElementById('poolDetailQuoteTokenAddress').innerHTML = attributes.quote_token?.address || '--';

      // å…³é”®æŒ‡æ ‡
      document.getElementById('poolDetailTVLMetric').innerHTML = formatNumber(attributes.reserve_in_usd || 0, 'USD', 2);
      document.getElementById('poolDetailVolume24h').innerHTML = formatNumber(attributes.volume_usd?.h24 || 0, 'USD', 2);
      document.getElementById('poolDetailTxCount').innerHTML = formatNumber(attributes.tx_count?.h24 || 0, 'number', 0);
      document.getElementById('poolDetailPrice').innerHTML = formatNumber(attributes.base_token_price_usd || 0, 'USD', 6);
      document.getElementById('poolDetailDex').innerHTML = attributes.dex?.name || '--';
      document.getElementById('poolDetailNetwork').innerHTML = network.toUpperCase();

      // æ± å­åœ°å€
      document.getElementById('poolDetailAddress').innerHTML = poolAddress;

      // ä»·æ ¼å˜åŒ–æ•°æ®
      const change1h = attributes.price_change_percentage?.h1 || 0;
      const change6h = attributes.price_change_percentage?.h6 || 0;
      const change24h = attributes.price_change_percentage?.h24 || 0;
      const change7d = attributes.price_change_percentage?.d7 || 0;

      document.getElementById('poolDetailChange1h').innerHTML = formatPriceChange(change1h);
      document.getElementById('poolDetailChange1h').className = `font-bold ${change1h >= 0 ? 'text-green-400' : 'text-red-400'}`;

      document.getElementById('poolDetailChange6h').innerHTML = formatPriceChange(change6h);
      document.getElementById('poolDetailChange6h').className = `font-bold ${change6h >= 0 ? 'text-green-400' : 'text-red-400'}`;

      document.getElementById('poolDetailChange24h').innerHTML = formatPriceChange(change24h);
      document.getElementById('poolDetailChange24h').className = `font-bold ${change24h >= 0 ? 'text-green-400' : 'text-red-400'}`;

      document.getElementById('poolDetailChange7d').innerHTML = formatPriceChange(change7d);
      document.getElementById('poolDetailChange7d').className = `font-bold ${change7d >= 0 ? 'text-green-400' : 'text-red-400'}`;

      // å¤–éƒ¨é“¾æ¥
      const baseTokenSymbol = attributes.base_token?.symbol || '';
      const geckoTerminalUrl = `https://www.geckoterminal.com/${network}/pools/${poolAddress}`;
      const dexscreenerUrl = `https://dexscreener.com/${network}/${poolAddress}`;
      const twitterUrl = baseTokenSymbol ? getTwitterSearchUrl(baseTokenSymbol) : '#';

      document.getElementById('poolDetailTwitter').href = twitterUrl;
      document.getElementById('poolDetailGeckoTerminal').href = geckoTerminalUrl;
      document.getElementById('poolDetailDexscreener').href = dexscreenerUrl;
    }

    // éšè—æ± å­è¯¦æƒ…å¼¹çª—
    function hidePoolDetail() {
      const modal = document.getElementById('poolDetailModal');
      modal.classList.add('hidden');
      document.body.style.overflow = ''; // æ¢å¤èƒŒæ™¯æ»šåŠ¨
    }

    // ==================== ä¿¡å·æ ‡ç­¾é¡µåˆ‡æ¢ ====================
    let currentSignalTab = 'anomaly';

    // ä¸å†éœ€è¦åˆ‡æ¢æ ‡ç­¾é¡µåŠŸèƒ½ï¼Œä»…ä¿ç•™å¼‚åŠ¨ç›‘æ§

    // ==================== å¸ƒæ—å¸¦æŒ‡æ ‡è®¡ç®— ====================
    // å‚æ•°: Length=20, MA Type=SMA, StdDev=2.0
    async function fetchKlineDataForAnalysis(symbol, interval, limit) {
      const endpoints = {
        binance: `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`,
        okx: `https://www.okx.com/api/v5/market/candles?instId=${symbol.replace('USDT', '-USDT')}&bar=${interval}&limit=${limit}`,
        bybit: `https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=${interval}&limit=${limit}`
      };

      // ä¼˜å…ˆä½¿ç”¨å½“å‰APIæä¾›å•†
      let endpoint = endpoints[currentApiProvider];

      try {
        const response = await fetchWithRetry(endpoint, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        }, 2, false);

        if (!response.ok) {
          throw new Error(`APIè¿”å›é”™è¯¯: ${response.status}`);
        }

        const data = await response.json();

        // æ ¹æ®ä¸åŒAPIæ ¼å¼è§£æKçº¿æ•°æ®
        let klines = [];

        if (currentApiProvider === 'binance') {
          klines = data.map(k => ({
            time: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
          }));
        } else if (currentApiProvider === 'okx') {
          if (data.data && data.data.length > 0) {
            klines = data.data.map(k => ({
              time: k[0],
              open: parseFloat(k[1]),
              high: parseFloat(k[2]),
              low: parseFloat(k[3]),
              close: parseFloat(k[4]),
              volume: parseFloat(k[5])
            }));
          }
        } else if (currentApiProvider === 'bybit') {
          if (data.result && data.result.list && data.result.list.length > 0) {
            klines = data.result.list.reverse().map(k => ({
              time: k[0],
              open: parseFloat(k[1]),
              high: parseFloat(k[2]),
              low: parseFloat(k[3]),
              close: parseFloat(k[4]),
              volume: parseFloat(k[5])
            }));
          }
        }

        return klines;
      } catch (error) {
        addLog('error', `Kçº¿æ•°æ®è·å–å¤±è´¥ (${currentApiProvider})`, error.message);

        // å°è¯•ä½¿ç”¨å¤‡ç”¨API
        for (const provider of ['binance', 'okx']) {
          if (provider !== currentApiProvider) {
            try {
              addLog('info', `å°è¯•ä½¿ç”¨${provider}è·å–Kçº¿æ•°æ®...`);
              const response = await fetchWithRetry(endpoints[provider], {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' }
              }, 2, false);

              if (response.ok) {
                const data = await response.json();
                let klines = [];

                if (provider === 'binance') {
                  klines = data.map(k => ({
                    time: k[0],
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    volume: parseFloat(k[5])
                  }));
                } else if (provider === 'okx') {
                  if (data.data && data.data.length > 0) {
                    klines = data.data.map(k => ({
                      time: k[0],
                      open: parseFloat(k[1]),
                      high: parseFloat(k[2]),
                      low: parseFloat(k[3]),
                      close: parseFloat(k[4]),
                      volume: parseFloat(k[5])
                    }));
                  }
                }

                if (klines.length > 0) {
                  addLog('success', `æˆåŠŸä½¿ç”¨${provider}è·å–Kçº¿æ•°æ®`);
                  return klines;
                }
              }
            } catch (e) {
              continue;
            }
          }
        }

        throw error;
      }
    }

    // ==================== æ—¥å¿—ç³»ç»Ÿ ====================
    let logEntries = [];
    let logsExpanded = false;
    let logFilter = 'all'; // å½“å‰æ—¥å¿—ç­›é€‰ç±»å‹: 'all', 'normal', 'error', 'warning'

    function filterLogs(filterType) {
      logFilter = filterType;
      
      // æ›´æ–°æŒ‰é’®æ ·å¼
      const buttons = {
        all: document.getElementById('filterAll'),
        normal: document.getElementById('filterNormal'),
        error: document.getElementById('filterError'),
        warning: document.getElementById('filterWarning')
      };
      
      // é‡ç½®æ‰€æœ‰æŒ‰é’®æ ·å¼
      Object.keys(buttons).forEach(key => {
        const btn = buttons[key];
        if (btn) {
          btn.className = 'px-2 py-1 text-xs text-slate-300 hover:bg-slate-600 rounded transition-all';
        }
      });
      
      // è®¾ç½®å½“å‰æ¿€æ´»æŒ‰é’®æ ·å¼
      const activeBtn = buttons[filterType];
      if (activeBtn) {
        const activeClass = {
          all: 'bg-blue-600 text-white',
          normal: 'bg-green-600 text-white',
          error: 'bg-red-600 text-white',
          warning: 'bg-yellow-600 text-white'
        };
        activeBtn.className = `px-2 py-1 text-xs ${activeClass[filterType]} rounded transition-all`;
      }
      
      // é‡æ–°æ¸²æŸ“æ—¥å¿—
      updateLogView();
    }

    function addLog(type, message, details = null) {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = {
        timestamp,
        type,
        message,
        details
      };

      logEntries.push(logEntry);
      // åªä¿ç•™æœ€è¿‘50æ¡æ—¥å¿—
      if (logEntries.length > 50) {
        logEntries = logEntries.slice(-50);
      }

      updateLogView();
      saveLogs();
    }

    function updateLogView() {
      const container = document.getElementById('logContainer');
      if (!container) return;

      // æ ¹æ®ç­›é€‰ç±»å‹è¿‡æ»¤æ—¥å¿—
      let filteredEntries = logEntries;
      if (logFilter !== 'all') {
        const typeMap = {
          normal: ['info', 'success', 'api'],  // æ­£å¸¸æ—¥å¿—ç±»å‹
          error: ['error'],  // æŠ¥é”™æ—¥å¿—ç±»å‹
          warning: ['warning']  // é”™è¯¯æç¤ºæ—¥å¿—ç±»å‹
        };
        const allowedTypes = typeMap[logFilter] || [];
        filteredEntries = logEntries.filter(entry => allowedTypes.includes(entry.type));
      }

      const logHTML = filteredEntries.map(entry => {
        const typeStyles = {
          info: 'text-blue-400',
          success: 'text-green-400',
          warning: 'text-yellow-400',
          error: 'text-red-400',
          api: 'text-purple-400'
        };

        const typeIcons = {
          info: 'â„¹ï¸',
          success: 'âœ…',
          warning: 'âš ï¸',
          error: 'âŒ',
          api: 'ğŸ“¡'
        };

        const styleClass = typeStyles[entry.type] || 'text-slate-400';
        const icon = typeIcons[entry.type] || 'ğŸ“Œ';

        let detailHTML = '';
        if (entry.details) {
          detailHTML = `<div class="text-slate-500 mt-0.5 pl-4 border-l border-slate-700">${entry.details}</div>`;
        }

        return `
          <div class="mb-1 hover:bg-slate-700/30 px-1 py-0.5 rounded transition-colors">
            <div class="flex items-start gap-2">
              <span class="text-slate-500 shrink-0">[${entry.timestamp}]</span>
              <span class="shrink-0">${icon}</span>
              <span class="${styleClass} flex-1">${entry.message}</span>
            </div>
            ${detailHTML}
          </div>
        `;
      }).join('');

      container.innerHTML = logHTML || '<div class="text-slate-500 text-center py-2">æš‚æ— æ—¥å¿—</div>';

      // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
      container.scrollTop = container.scrollHeight;
    }

    function clearLogs() {
      logEntries = [];
      updateLogView();
      addLog('info', 'æ—¥å¿—å·²æ¸…ç©º');
    }

    function toggleLogs() {
      logsExpanded = !logsExpanded;
      const container = document.getElementById('logContainer');
      const btn = document.getElementById('logToggleBtn');

      if (logsExpanded) {
        container.style.display = 'block';
        btn.textContent = 'æ”¶èµ·';
      } else {
        container.style.display = 'none';
        btn.textContent = 'å±•å¼€';
      }
    }

    // ==================== çŠ¶æ€ç®¡ç† ====================
    let binancePrices = [];
    let anomalySignals = [];
    let news = [];
    let hotNews = [];
    let kolOpinions = [];
    let currentTab = 'latest';
    let currentApiProvider = 'bybit'; // é»˜è®¤ä½¿ç”¨Bybit API

    // é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹é›†åˆï¼ˆç»“åˆä¿¡å·ç›‘æ§å’Œå¸‚åœºçƒ­åº¦ï¼‰
    let importantSymbols = new Set();

    let lastNewsCleanTime = Date.now();
    const NEWS_CLEAN_INTERVAL = 3600000; // 1å°æ—¶æ¸…ç†ä¸€æ¬¡
    const NEWS_CLEAN_COUNT = 12; // æ¯æ¬¡æ¸…ç†12æ¡

    // æ•°æ®æŒä¹…åŒ–é…ç½®
    const DATA_EXPIRE_TIME = 86400000; // 24å°æ—¶è¿‡æœŸ
    const STORAGE_KEYS = {
      anomalySignals: 'anomaly_signals_data',
      news: 'news_data',
      hotNews: 'hot_news_data',
      kolOpinions: 'kol_opinions_data',
      logEntries: 'log_entries_data',
      tickerData: 'ticker_data_data',
      trendingCoins: 'trending_coins_data',
      theme: 'theme_preference'
    };

    // ==================== é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹ç®¡ç† ====================

    // æ›´æ–°é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹é›†åˆ
    function updateImportantSymbols() {
      const newSymbols = new Set();

      // 1. æ·»åŠ å¼‚åŠ¨ä¿¡å·ä¸­çš„äº¤æ˜“å¯¹ï¼ˆéƒ½ç¬¦åˆ >10M æ¡ä»¶ï¼‰
      anomalySignals.forEach(signal => {
        newSymbols.add(signal.symbol);
      });

      // 2. æ·»åŠ æ‰€æœ‰ç¬¦åˆ >10M æ¡ä»¶çš„äº¤æ˜“å¯¹
      binancePrices.forEach(item => {
        const volumeInM = parseFloat(item.quoteVolume) / 1000000;
        if (volumeInM > 10) {
          newSymbols.add(item.symbol);
        }
      });

      // 3. æ·»åŠ å¸‚åœºçƒ­åº¦æ¦œå• TOP10 çš„äº¤æ˜“å¯¹
      // æ¶¨å¹…æ¦œ TOP10
      const topGainers = [...binancePrices]
        .sort((a, b) => b.priceChangePercent - a.priceChangePercent)
        .slice(0, 10);
      topGainers.forEach(item => newSymbols.add(item.symbol));

      // æˆäº¤é‡æ¦œ TOP10
      const topVolume = [...binancePrices]
        .sort((a, b) => b.quoteVolume - a.quoteVolume)
        .slice(0, 10);
      topVolume.forEach(item => newSymbols.add(item.symbol));

      // æ›´æ–°é›†åˆ
      importantSymbols = newSymbols;

      addLog('info', `é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹å·²æ›´æ–°: ${importantSymbols.size} ä¸ª`);
    }

    // è·å–é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹åˆ—è¡¨
    function getImportantSymbols() {
      return importantSymbols; // è¿”å› Set å¯¹è±¡ï¼Œè€Œä¸æ˜¯æ•°ç»„
    }

    // æ£€æŸ¥äº¤æ˜“å¯¹æ˜¯å¦ä¸ºé‡ç‚¹å…³æ³¨
    function isImportantSymbol(symbol) {
      return importantSymbols.has(symbol);
    }

    // ==================== ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½ ====================
    let currentTheme = 'light'; // 'light' or 'dark'

    // ä¿å­˜ä¸»é¢˜åå¥½
    function saveTheme() {
      try {
        localStorage.setItem(STORAGE_KEYS.theme, currentTheme);
      } catch (error) {
        console.error('ä¿å­˜ä¸»é¢˜åå¥½å¤±è´¥:', error);
      }
    }

    // åŠ è½½ä¸»é¢˜åå¥½
    function loadTheme() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.theme);
        if (saved) {
          currentTheme = saved === 'dark' ? 'dark' : 'light';
        }
      } catch (error) {
        console.error('åŠ è½½ä¸»é¢˜åå¥½å¤±è´¥:', error);
      }
    }

    // åº”ç”¨ä¸»é¢˜
    function applyTheme() {
      const sunIcon = document.getElementById('sunIcon');
      const moonIcon = document.getElementById('moonIcon');
      const body = document.body;

      if (currentTheme === 'dark') {
        body.classList.add('dark');
        sunIcon.classList.add('hidden');
        moonIcon.classList.remove('hidden');
      } else {
        body.classList.remove('dark');
        sunIcon.classList.remove('hidden');
        moonIcon.classList.add('hidden');
      }
    }

    // åˆ‡æ¢ä¸»é¢˜
    function toggleTheme() {
      currentTheme = currentTheme === 'light' ? 'dark' : 'light';
      applyTheme();
      saveTheme();
      addLog('info', `å·²åˆ‡æ¢åˆ°${currentTheme === 'dark' ? 'æš—è‰²' : 'äº®è‰²'}ä¸»é¢˜`);
    }

    // åˆå§‹åŒ–ä¸»é¢˜
    function initTheme() {
      loadTheme();
      applyTheme();

      // ç»‘å®šåˆ‡æ¢æŒ‰é’®äº‹ä»¶
      const themeToggle = document.getElementById('themeToggle');
      if (themeToggle) {
        themeToggle.addEventListener('click', toggleTheme);
      }
    }

    // ==================== æŒä¹…åŒ–å‡½æ•° ====================

    // ä¿å­˜å¼‚åŠ¨ä¿¡å·
    function saveAnomalySignals() {
      try {
        const data = {
          signals: anomalySignals,
          timestamp: Date.now()
        };
        localStorage.setItem(STORAGE_KEYS.anomalySignals, JSON.stringify(data));
      } catch (error) {
        console.error('ä¿å­˜å¼‚åŠ¨ä¿¡å·å¤±è´¥:', error);
      }
    }

    // åŠ è½½å¼‚åŠ¨ä¿¡å·
    function loadAnomalySignals() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.anomalySignals);
        if (saved) {
          const data = JSON.parse(saved);
          // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
          if (Date.now() - data.timestamp < DATA_EXPIRE_TIME) {
            anomalySignals = data.signals || [];
            addLog('info', `å·²åŠ è½½ ${anomalySignals.length} æ¡å†å²å¼‚åŠ¨ä¿¡å·`);
          } else {
            localStorage.removeItem(STORAGE_KEYS.anomalySignals);
          }
        }
      } catch (error) {
        console.error('åŠ è½½å¼‚åŠ¨ä¿¡å·å¤±è´¥:', error);
      }
    }

    // ä¿å­˜æ–°é—»æ•°æ®
    function saveNewsData() {
      try {
        const now = Date.now();
        localStorage.setItem(STORAGE_KEYS.news, JSON.stringify({ data: news, timestamp: now }));
        localStorage.setItem(STORAGE_KEYS.hotNews, JSON.stringify({ data: hotNews, timestamp: now }));
        localStorage.setItem(STORAGE_KEYS.kolOpinions, JSON.stringify({ data: kolOpinions, timestamp: now }));
      } catch (error) {
        console.error('ä¿å­˜æ–°é—»æ•°æ®å¤±è´¥:', error);
      }
    }

    // åŠ è½½æ–°é—»æ•°æ®
    function loadNewsData() {
      try {
        const now = Date.now();
        const keys = [
          { key: STORAGE_KEYS.news, varName: 'news' },
          { key: STORAGE_KEYS.hotNews, varName: 'hotNews' },
          { key: STORAGE_KEYS.kolOpinions, varName: 'kolOpinions' }
        ];

        keys.forEach(({ key, varName }) => {
          const saved = localStorage.getItem(key);
          if (saved) {
            const data = JSON.parse(saved);
            if (now - data.timestamp < DATA_EXPIRE_TIME) {
              window[varName] = data.data || [];
            } else {
              localStorage.removeItem(key);
            }
          }
        });

        const totalCount = news.length + hotNews.length + kolOpinions.length;
        if (totalCount > 0) {
          addLog('info', `å·²åŠ è½½å†å²æ–°é—»æ•°æ®: æœ€æ–°${news.length}æ¡, çƒ­é—¨${hotNews.length}æ¡, KOL${kolOpinions.length}æ¡`);
          // æ›´æ–°æ–°é—»è§†å›¾
          updateNewsView();
        }
      } catch (error) {
        console.error('åŠ è½½æ–°é—»æ•°æ®å¤±è´¥:', error);
      }
    }

    // ä¿å­˜äº¤æ˜“å¯¹æ•°æ®
    function saveTickerData() {
      try {
        const data = {
          tickers: binancePrices,
          apiProvider: currentApiProvider,
          timestamp: Date.now()
        };
        localStorage.setItem(STORAGE_KEYS.tickerData, JSON.stringify(data));
      } catch (error) {
        console.error('ä¿å­˜äº¤æ˜“å¯¹æ•°æ®å¤±è´¥:', error);
      }
    }

    // åŠ è½½äº¤æ˜“å¯¹æ•°æ®
    function loadTickerData() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.tickerData);
        if (saved) {
          const data = JSON.parse(saved);
          // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
          if (Date.now() - data.timestamp < DATA_EXPIRE_TIME) {
            binancePrices = data.tickers || [];
            if (data.apiProvider && data.apiProvider !== currentApiProvider) {
              addLog('info', `å·²åŠ è½½å†å²äº¤æ˜“å¯¹æ•°æ®ï¼ˆæ¥æº: ${data.apiProvider.toUpperCase()}ï¼‰ï¼Œå½“å‰ä½¿ç”¨: ${currentApiProvider.toUpperCase()}`);
            } else {
              addLog('info', `å·²åŠ è½½ ${binancePrices.length} ä¸ªå†å²äº¤æ˜“å¯¹æ•°æ®`);
            }
          } else {
            localStorage.removeItem(STORAGE_KEYS.tickerData);
          }
        }
      } catch (error) {
        console.error('åŠ è½½äº¤æ˜“å¯¹æ•°æ®å¤±è´¥:', error);
      }
    }

    // ä¿å­˜æ—¥å¿—
    function saveLogs() {
      try {
        const data = {
          entries: logEntries,
          timestamp: Date.now()
        };
        localStorage.setItem(STORAGE_KEYS.logEntries, JSON.stringify(data));
      } catch (error) {
        console.error('ä¿å­˜æ—¥å¿—å¤±è´¥:', error);
      }
    }

    // åŠ è½½æ—¥å¿—
    function loadLogs() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.logEntries);
        if (saved) {
          const data = JSON.parse(saved);
          if (Date.now() - data.timestamp < DATA_EXPIRE_TIME) {
            logEntries = data.entries || [];
            if (logEntries.length > 0) {
              addLog('info', `å·²åŠ è½½ ${logEntries.length} æ¡å†å²æ—¥å¿—`);
            }
          } else {
            localStorage.removeItem(STORAGE_KEYS.logEntries);
          }
        }
      } catch (error) {
        console.error('åŠ è½½æ—¥å¿—å¤±è´¥:', error);
      }
    }

    // æ¸…ç†æ‰€æœ‰è¿‡æœŸæ•°æ®

    // ä¿å­˜ç»¼åˆä¿¡æ¯æ•°æ®
    function saveMarketData(trendingCoins) {
      try {
        const now = Date.now();
        localStorage.setItem(STORAGE_KEYS.trendingCoins, JSON.stringify({ data: trendingCoins, timestamp: now }));
      } catch (error) {
        console.error('ä¿å­˜ç»¼åˆä¿¡æ¯æ•°æ®å¤±è´¥:', error);
      }
    }

    // åŠ è½½ç»¼åˆä¿¡æ¯æ•°æ®
    function loadMarketData() {
      try {
        const now = Date.now();
        const result = {};
        ['trendingCoins'].forEach(varName => {
          const key = STORAGE_KEYS[varName];
          if (!key) return;
          const saved = localStorage.getItem(key);
          if (saved) {
            const data = JSON.parse(saved);
            if (now - data.timestamp < DATA_EXPIRE_TIME) {
              result[varName] = data.data;
            } else {
              localStorage.removeItem(key);
            }
          }
        });
        return result;
      } catch (error) {
        console.error('åŠ è½½ç»¼åˆä¿¡æ¯æ•°æ®å¤±è´¥:', error);
        return {};
      }
    }

    function cleanExpiredData() {
      const now = Date.now();
      Object.values(STORAGE_KEYS).forEach(key => {
        // è·³è¿‡ä¸»é¢˜æ•°æ®ï¼Œå› ä¸ºå®ƒæ˜¯å­—ç¬¦ä¸²è€ŒéJSONå¯¹è±¡
        if (key === STORAGE_KEYS.theme) return;

        try {
          const saved = localStorage.getItem(key);
          if (saved) {
            const data = JSON.parse(saved);
            if (now - data.timestamp >= DATA_EXPIRE_TIME) {
              localStorage.removeItem(key);
            }
          }
        } catch (error) {
          console.error(`æ¸…ç†æ•°æ®å¤±è´¥: ${key}`, error);
        }
      });
    }

    // æ¸…é™¤æ‰€æœ‰å†å²æ•°æ®
    function clearAllHistory() {
      Object.values(STORAGE_KEYS).forEach(key => {
        localStorage.removeItem(key);
      });
      anomalySignals = [];
      news = [];
      hotNews = [];
      kolOpinions = [];
      logEntries = [];
      addLog('info', 'å·²æ¸…é™¤æ‰€æœ‰å†å²æ•°æ®');
      updateAnomalyView();
      updateNewsView();
      updateLogView();
    }

    function cleanupNews() {
      const now = Date.now();
      if (now - lastNewsCleanTime > NEWS_CLEAN_INTERVAL) {
        // æ¸…ç†æœ€æ—§çš„12æ¡æ–°é—»
        if (news.length > NEWS_CLEAN_COUNT) {
          news = news.slice(NEWS_CLEAN_COUNT);
        }
        if (hotNews.length > NEWS_CLEAN_COUNT) {
          hotNews = hotNews.slice(NEWS_CLEAN_COUNT);
        }
        if (kolOpinions.length > NEWS_CLEAN_COUNT) {
          kolOpinions = kolOpinions.slice(NEWS_CLEAN_COUNT);
        }
        lastNewsCleanTime = now;
        addLog('info', 'æ–°é—»æ‰¹é‡æ¸…ç†å®Œæˆï¼Œåˆ é™¤æœ€æ—§12æ¡');
      }
    }

    // å¼‚åŠ¨ä¿¡å·æ’åºçŠ¶æ€
    let anomalySortColumn = 'time';
    let anomalySortDirection = 'desc';

    // å¸ç§ç¬¦å·æ˜ å°„è¡¨ (äº¤æ˜“å¯¹ç¬¦å· -> CoinGecko coin ID)
    const COIN_SYMBOL_MAP = {
      'BTC': 'bitcoin',
      'ETH': 'ethereum',
      'BNB': 'binancecoin',
      'XRP': 'ripple',
      'ADA': 'cardano',
      'DOGE': 'dogecoin',
      'SOL': 'solana',
      'DOT': 'polkadot',
      'MATIC': 'matic-network',
      'SHIB': 'shiba-inu',
      'LTC': 'litecoin',
      'AVAX': 'avalanche-2',
      'TRX': 'tron',
      'LINK': 'chainlink',
      'ATOM': 'cosmos',
      'UNI': 'uniswap',
      'XLM': 'stellar',
      'XMR': 'monero',
      'ETC': 'ethereum-classic',
      'BCH': 'bitcoin-cash',
      'ALGO': 'algorand',
      'VET': 'vechain',
      'FIL': 'filecoin',
      'ICP': 'internet-computer',
      'NEAR': 'near',
      'APE': 'apecoin',
      'APT': 'aptos',
      'ARB': 'arbitrum',
      'OP': 'optimism',
      'PEPE': 'pepe',
      'FLOKI': 'floki',
      'ORDI': 'ordi',
      'SATS': 'sats-100k'
    };

    // ==================== API è°ƒç”¨å‡½æ•° ====================

    // CORSä»£ç†é…ç½®ï¼ˆä½¿ç”¨å…¬å…±ä»£ç†ï¼Œæ— éœ€æœ¬åœ°æœåŠ¡å™¨ï¼‰
    // ç›´æ¥åŒå‡»HTMLæ–‡ä»¶å³å¯ä½¿ç”¨
    const CORS_PROXIES = [
      'https://corsproxy.io/?',                // å…¬å…±ä»£ç†1
      'https://api.allorigins.win/raw?url=',  // å…¬å…±ä»£ç†2
      'https://api.codetabs.com/v1/proxy?quest=',  // å…¬å…±ä»£ç†3
      'https://thingproxy.freeboard.io/fetch/',    // å…¬å…±ä»£ç†4
      'https://cors-anywhere.herokuapp.com/'       // å…¬å…±ä»£ç†5
    ];
    let currentProxyIndex = 0;

    // è·å–ä»£ç†URL
    function getProxiedUrl(url) {
      // éœ€è¦ä»£ç†çš„APIåˆ—è¡¨
      const needProxy = [
        'coingecko.com',    // CoinGecko API
        'mexc.com',         // MEXC API (CORSé”™è¯¯)
        'gate.io'           // Gate.io API (SSLè¯ä¹¦é”™è¯¯)
      ];

      // æ£€æŸ¥æ˜¯å¦éœ€è¦ä»£ç†
      const needsProxy = needProxy.some(domain => url.includes(domain));

      if (needsProxy) {
        const proxy = CORS_PROXIES[currentProxyIndex % CORS_PROXIES.length];
        // å…¬å…±ä»£ç†éœ€è¦URLç¼–ç 
        return proxy + encodeURIComponent(url);
      }

      // å…¶ä»–APIä¸éœ€è¦ä»£ç†ï¼ˆBinanceã€Bybitã€OKXã€Followinã€Coinloreã€CoinCapç­‰æ”¯æŒCORSï¼‰
      return url;
    }

    // é€šç”¨APIé‡è¯•å‡½æ•°ï¼ˆå¸¦CORSä»£ç†å’Œ429ç‰¹æ®Šå¤„ç†ï¼‰
    async function fetchWithRetry(url, options = {}, maxRetries = 2, useProxy = true) {
      let lastError;
      let actualUrl = useProxy ? getProxiedUrl(url) : url;

      for (let i = 0; i <= maxRetries; i++) {
        try {
          const response = await fetch(actualUrl, options);

          if (response.ok) {
            return response;
          }

          // 429é”™è¯¯ï¼šCoinGeckoé™æµï¼Œä½¿ç”¨æŒ‡æ•°é€€é¿
          if (response.status === 429) {
            const waitTime = Math.min(60000 * Math.pow(2, i), 120000); // æœ€å¤šç­‰å¾…2åˆ†é’Ÿ
            addLog('warning', `APIé™æµï¼ˆ429ï¼‰ï¼Œç­‰å¾… ${waitTime / 1000} ç§’åé‡è¯•...`);

            if (i < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
            continue;
          }

          // å¦‚æœæ˜¯4xxé”™è¯¯ï¼ˆå®¢æˆ·ç«¯é”™è¯¯ï¼‰ï¼Œä¸é‡è¯•ï¼ˆé™¤äº†429ï¼‰
          if (response.status >= 400 && response.status < 500) {
            return response;
          }

          lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);

          // ä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
          if (i < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
          }
        } catch (error) {
          lastError = error;

          // å¦‚æœæ˜¯CORSé”™è¯¯ï¼Œå°è¯•ä¸‹ä¸€ä¸ªä»£ç†
          if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
            if (useProxy && currentProxyIndex < CORS_PROXIES.length - 1) {
              currentProxyIndex++;
              actualUrl = getProxiedUrl(url);
              addLog('info', `CORSé”™è¯¯ï¼Œåˆ‡æ¢ä»£ç†: ${CORS_PROXIES[currentProxyIndex]}`);
              i--; // ä¸å¢åŠ é‡è¯•æ¬¡æ•°
              continue;
            }
          }

          // ä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
          if (i < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
          }
        }
      }

      throw lastError;
    }

    // é€šè¿‡CoinGeckoæœç´¢APIæŸ¥æ‰¾å¸ç§ID
    async function searchCoinGeckoId(symbol) {
      const coinSymbol = symbol.replace('USDT', '').toUpperCase();

      try {
        addLog('api', `æ­£åœ¨é€šè¿‡CoinGeckoæœç´¢APIæŸ¥æ‰¾ ${coinSymbol}...`);

        const response = await fetchWithRetry(
          `https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(coinSymbol)}`,
          { method: 'GET' },
          3, // å¢åŠ é‡è¯•æ¬¡æ•°
          true // ä½¿ç”¨ä»£ç†
        );

        if (!response.ok) {
          return null;
        }

        const data = await response.json();

        if (data.coins && data.coins.length > 0) {
          // æŸ¥æ‰¾æœ€åŒ¹é…çš„ç»“æœï¼ˆä¼˜å…ˆç¬¦å·å®Œå…¨åŒ¹é…ï¼‰
          const bestMatch = data.coins.find(coin =>
            coin.symbol.toUpperCase() === coinSymbol
          ) || data.coins[0];

          addLog('success', `CoinGeckoæœç´¢æ‰¾åˆ° ${coinSymbol} -> ${bestMatch.id}`);

          // ç¼“å­˜ç»“æœ
          coinIdCache.set(symbol, bestMatch.id);

          return bestMatch.id;
        }

        return null;
      } catch (error) {
        addLog('error', `CoinGeckoæœç´¢å¤±è´¥`, error.message);
        return null;
      }
    }

    // ==================== CoinCap API è·å–å›¾æ ‡ ====================
    // è·å–å¸ç§å›¾æ ‡ï¼ˆä¼˜å…ˆä½¿ç”¨CoinCap APIï¼Œå…è´¹æ— éœ€API Keyï¼‰
    async function fetchCoinCapIcon(symbol) {
      const coinSymbol = symbol.replace('USDT', '').toLowerCase();

      try {
        // CoinCap API - /api/v2/assets ç«¯ç‚¹
        const response = await fetchWithRetry(
          `https://api.coincap.io/v2/assets?search=${coinSymbol}&limit=1`,
          { method: 'GET' },
          2, // é‡è¯•2æ¬¡
          true // ä½¿ç”¨ä»£ç†
        );

        if (!response.ok) {
          return null;
        }

        const data = await response.json();

        if (data.data && data.data.length > 0) {
          const coin = data.data[0];
          addLog('success', `CoinCapè·å– ${symbol} å›¾æ ‡æˆåŠŸ`);
          return coin.symbol; // è¿”å›æ ‡å‡†åŒ–çš„symbolï¼ˆå¤§å†™ï¼‰
        }

        return null;
      } catch (error) {
        addLog('warning', `CoinCapè·å–å›¾æ ‡å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å–å¸å®‰ç°è´§äº¤æ˜“é‡æ•°æ®ï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰
    async function fetchBinanceSpotVolume(symbol) {
      try {
        addLog('api', `å°è¯•è¿æ¥å¸å®‰ç°è´§APIè·å– ${symbol} äº¤æ˜“é‡æ•°æ®...`);

        // å…ˆéªŒè¯äº¤æ˜“å¯¹æ˜¯å¦å­˜åœ¨
        const verifyResponse = await fetchWithRetry(
          `https://api.binance.com/api/v3/exchangeInfo?symbol=${symbol}`,
          { method: 'GET' },
          1, // éªŒè¯è¯·æ±‚åªéœ€1æ¬¡é‡è¯•
          true // ä½¿ç”¨ä»£ç†
        );

        if (verifyResponse.status === 400) {
          addLog('warning', `å¸å®‰ç°è´§ä¸å­˜åœ¨äº¤æ˜“å¯¹: ${symbol}ï¼Œè·³è¿‡è·å–äº¤æ˜“é‡æ•°æ®`);
          return null;
        }

        if (!verifyResponse.ok) {
          addLog('warning', `å¸å®‰ç°è´§éªŒè¯å¤±è´¥: ${verifyResponse.status}ï¼Œä»å°è¯•è·å–äº¤æ˜“é‡`);
        }

        const response = await fetchWithRetry(
          `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1m&limit=300`,
          { method: 'GET' },
          2,
          true // ä½¿ç”¨ä»£ç†
        );

        if (!response.ok) {
          if (response.status === 400) {
            addLog('warning', `å¸å®‰ç°è´§ä¸å­˜åœ¨äº¤æ˜“å¯¹: ${symbol}`);
          } else {
            addLog('warning', `å¸å®‰ç°è´§APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`);
          }
          return null;
        }

        const klines = await response.json();

        // Kçº¿æ•°æ®ç»“æ„ï¼š[æ—¶é—´æˆ³, å¼€ç›˜ä»·, æœ€é«˜ä»·, æœ€ä½ä»·, æ”¶ç›˜ä»·, æˆäº¤é‡, æˆäº¤æ—¶é—´, æˆäº¤ç¬”æ•°, ...]
        // index[7] = æˆäº¤é¢ï¼ˆå•ä½ï¼šUSDTï¼‰
        const volume5m = klines.slice(0, 5).reduce((sum, k) => sum + parseFloat(k[7]), 0);
        const volume15m = klines.slice(0, 15).reduce((sum, k) => sum + parseFloat(k[7]), 0);
        const volume1h = klines.slice(0, 60).reduce((sum, k) => sum + parseFloat(k[7]), 0);
        const volume4h = klines.slice(0, 240).reduce((sum, k) => sum + parseFloat(k[7]), 0);

        addLog('success', `å¸å®‰ç°è´§è·å– ${symbol} äº¤æ˜“é‡æ•°æ®æˆåŠŸ`);

        return {
          '5m': volume5m,
          '15m': volume15m,
          '1h': volume1h,
          '4h': volume4h
        };
      } catch (error) {
        addLog('warning', `å¸å®‰ç°è´§è·å– ${symbol} äº¤æ˜“é‡æ•°æ®å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å– Bybit ç°è´§äº¤æ˜“é‡æ•°æ®
    async function fetchBybitVolume(symbol) {
      try {
        addLog('api', `æ­£åœ¨è¿æ¥Bybit APIè·å– ${symbol} äº¤æ˜“é‡æ•°æ®...`);

        const response = await fetchWithRetry(
          `https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=1&limit=300`,
          { method: 'GET' },
          2,
          true // ä½¿ç”¨ä»£ç†
        );

        if (!response.ok) {
          addLog('warning', `Bybit APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}ï¼Œå°è¯•å¤‡é€‰æ–¹æ¡ˆ`);
          // å°è¯•å¸å®‰ç°è´§APIä½œä¸ºå¤‡é€‰
          return await fetchBinanceSpotVolume(symbol);
        }

        const data = await response.json();

        if (data.retCode !== 0) {
          addLog('warning', `Bybit APIé”™è¯¯: ${data.retMsg}ï¼Œå°è¯•å¤‡é€‰æ–¹æ¡ˆ`);
          // å°è¯•å¸å®‰ç°è´§APIä½œä¸ºå¤‡é€‰
          return await fetchBinanceSpotVolume(symbol);
        }

        const klines = data.result.list;

        // Kçº¿æ•°æ®ç»“æ„ï¼š[æ—¶é—´æˆ³, å¼€ç›˜ä»·, æœ€é«˜ä»·, æœ€ä½ä»·, æ”¶ç›˜ä»·, æˆäº¤é‡, æˆäº¤é¢, æˆäº¤ç¬”æ•°]
        // index[6] = æˆäº¤é¢ï¼ˆå•ä½ï¼šUSDTï¼‰
        const volume5m = klines.slice(0, 5).reduce((sum, k) => sum + parseFloat(k[6]), 0);
        const volume15m = klines.slice(0, 15).reduce((sum, k) => sum + parseFloat(k[6]), 0);
        const volume1h = klines.slice(0, 60).reduce((sum, k) => sum + parseFloat(k[6]), 0);
        const volume4h = klines.slice(0, 240).reduce((sum, k) => sum + parseFloat(k[6]), 0);

        addLog('success', `Bybitè·å– ${symbol} äº¤æ˜“é‡æ•°æ®æˆåŠŸ`);

        return {
          '5m': volume5m,
          '15m': volume15m,
          '1h': volume1h,
          '4h': volume4h
        };
      } catch (error) {
        addLog('warning', `Bybitè·å– ${symbol} äº¤æ˜“é‡æ•°æ®å¤±è´¥ï¼Œå°è¯•å¤‡é€‰æ–¹æ¡ˆ`, error.message);
        // å°è¯•å¸å®‰ç°è´§APIä½œä¸ºå¤‡é€‰
        return await fetchBinanceSpotVolume(symbol);
      }
    }

    // è·å–å¸å®‰åˆçº¦èµ„é‡‘è´¹ç‡
    async function fetchBinanceFundingRate(symbol) {
      try {
        // æ£€æŸ¥æ˜¯å¦åœ¨åˆçº¦ç™½åå•ä¸­ï¼ˆé¿å…æŸ¥è¯¢æ— åˆçº¦çš„å¸ç§ï¼‰
        if (!isFuturesSymbol(symbol)) {
          addLog('info', `${symbol} ä¸åœ¨åˆçº¦ç™½åå•ï¼Œè·³è¿‡èµ„é‡‘è´¹ç‡æŸ¥è¯¢`);
          return null;
        }
        
        addLog('api', `æ­£åœ¨è·å– ${symbol} èµ„é‡‘è´¹ç‡...`);

        const response = await fetchWithRetry(
          `https://fapi.binance.com/fapi/v1/fundingRate?symbol=${symbol}&limit=1`,
          { method: 'GET' },
          2,
          false // Binance APIä¸éœ€è¦ä»£ç†
        );

        if (!response.ok) {
          addLog('warning', `èµ„é‡‘è´¹ç‡APIè¿”å›é”™è¯¯: ${response.status}`);
          return null;
        }

        const data = await response.json();

        if (!data || data.length === 0) {
          addLog('warning', `æœªè·å–åˆ° ${symbol} èµ„é‡‘è´¹ç‡æ•°æ®`);
          return null;
        }

        const fundingRate = data[0];
        const rate = parseFloat(fundingRate.fundingRate) || 0;
        const nextFundingTime = fundingRate.fundingTime ? new Date(fundingRate.fundingTime).toLocaleString('zh-CN') : '--';

        addLog('success', `è·å– ${symbol} èµ„é‡‘è´¹ç‡æˆåŠŸ: ${(rate * 100).toFixed(4)}%`);

        return {
          rate: rate,
          ratePercent: rate * 100,
          fundingTime: fundingRate.fundingTime,
          nextFundingTime: nextFundingTime,
          symbol: symbol
        };
      } catch (error) {
        addLog('warning', `è·å– ${symbol} èµ„é‡‘è´¹ç‡å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å– Bitget åˆçº¦æŒä»“é‡
    async function fetchBitgetOpenInterest(symbol) {
      try {
        // Bitget çš„ symbol æ ¼å¼éœ€è¦æ·»åŠ  UMCBL åç¼€ï¼ˆUSDTæœ¬ä½æ°¸ç»­åˆçº¦ï¼‰
        const bitgetSymbol = symbol.replace('USDT', 'USDT_UMCBL');
        
        addLog('api', `æ­£åœ¨è¿æ¥ Bitget API è·å– ${symbol} æŒä»“é‡æ•°æ®...`);

        const response = await fetchWithRetry(
          `https://api.bitget.com/api/v2/mix/getOpenInterest?symbol=${bitgetSymbol}`,
          { method: 'GET' },
          2,
          false
        );

        if (!response.ok) {
          if (response.status === 400 || response.status === 404) {
            addLog('info', `${symbol} Bitgetæš‚æ— æœŸè´§åˆçº¦äº¤æ˜“`);
            return null;
          }
          addLog('warning', `BitgetæŒä»“é‡APIè¿”å›é”™è¯¯: ${response.status}`);
          return null;
        }

        const json = await response.json();

        if (!json || json.code !== '00000' || !json.data) {
          addLog('warning', `Bitgetè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸æˆ–æ— æ•°æ®`);
          return null;
        }

        // Bitget è¿”å›çš„æ•°æ®æ ¼å¼
        const openInterest = parseFloat(json.data.openInterest) || 0;
        const time = json.data.timestamp || Date.now();

        addLog('success', `Bitgetè·å– ${symbol} æŒä»“é‡æˆåŠŸ: ${openInterest.toFixed(2)} USDT`);

        return {
          openInterest: openInterest,
          time: time ? new Date(time).toLocaleString('zh-CN') : '--',
          timestamp: time,
          symbol: symbol,
          source: 'Bitget'
        };
      } catch (error) {
        addLog('warning', `Bitgetè·å– ${symbol} æŒä»“é‡å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å– MEXC åˆçº¦æŒä»“é‡
    async function fetchMEXCOpenInterest(symbol) {
      try {
        addLog('api', `æ­£åœ¨è¿æ¥ MEXC API è·å– ${symbol} æŒä»“é‡æ•°æ®...`);

        const response = await fetchWithRetry(
          `https://api.mexc.com/api/v3/contract/open_interest?symbol=${symbol}`,
          { method: 'GET' },
          2,
          true  // MEXCéœ€è¦ä»£ç†
        );

        if (!response.ok) {
          if (response.status === 400 || response.status === 404) {
            addLog('info', `${symbol} MEXCæš‚æ— æœŸè´§åˆçº¦äº¤æ˜“`);
            return null;
          }
          addLog('warning', `MEXCæŒä»“é‡APIè¿”å›é”™è¯¯: ${response.status}`);
          return null;
        }

        const json = await response.json();

        if (!json || !json.data) {
          addLog('warning', `MEXCè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸æˆ–æ— æ•°æ®`);
          return null;
        }

        // MEXC è¿”å›çš„æ•°æ®æ ¼å¼
        const openInterest = parseFloat(json.data.openInterest) || 0;
        const time = json.data.timestamp || Date.now();

        addLog('success', `MEXCè·å– ${symbol} æŒä»“é‡æˆåŠŸ: ${openInterest.toFixed(2)} USDT`);

        return {
          openInterest: openInterest,
          time: time ? new Date(time).toLocaleString('zh-CN') : '--',
          timestamp: time,
          symbol: symbol,
          source: 'MEXC'
        };
      } catch (error) {
        addLog('warning', `MEXCè·å– ${symbol} æŒä»“é‡å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å– Gate.io åˆçº¦æŒä»“é‡
    async function fetchGateOpenInterest(symbol) {
      try {
        // Gate.io çš„ settle å‚æ•°è®¾ç½®ä¸º USDT
        const gateSymbol = symbol.replace('USDT', '_USDT');
        
        addLog('api', `æ­£åœ¨è¿æ¥ Gate.io API è·å– ${symbol} æŒä»“é‡æ•°æ®...`);

        const response = await fetchWithRetry(
          `https://api.gate.io/futures/v4/contracts/${gateSymbol}/open_interest`,
          { method: 'GET' },
          2,
          false
        );

        if (!response.ok) {
          if (response.status === 400 || response.status === 404) {
            addLog('info', `${symbol} Gate.ioæš‚æ— æœŸè´§åˆçº¦äº¤æ˜“`);
            return null;
          }
          addLog('warning', `Gate.ioæŒä»“é‡APIè¿”å›é”™è¯¯: ${response.status}`);
          return null;
        }

        const json = await response.json();

        if (!json || !json.result) {
          addLog('warning', `Gate.ioè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸æˆ–æ— æ•°æ®`);
          return null;
        }

        // Gate.io è¿”å›çš„æ•°æ®æ ¼å¼
        const openInterest = parseFloat(json.result) || 0;
        const time = Date.now();

        addLog('success', `Gate.ioè·å– ${symbol} æŒä»“é‡æˆåŠŸ: ${openInterest.toFixed(2)} USDT`);

        return {
          openInterest: openInterest,
          time: time ? new Date(time).toLocaleString('zh-CN') : '--',
          timestamp: time,
          symbol: symbol,
          source: 'Gate'
        };
      } catch (error) {
        addLog('warning', `Gate.ioè·å– ${symbol} æŒä»“é‡å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å– OKX åˆçº¦æŒä»“é‡
    async function fetchOKXOpenInterest(symbol) {
      try {
        // OKX çš„ symbol æ ¼å¼éœ€è¦è½¬æ¢ä¸º INSTID
        const okxSymbol = symbol.replace('USDT', '-USDT-SWAP');
        
        addLog('api', `æ­£åœ¨è¿æ¥ OKX API è·å– ${symbol} æŒä»“é‡æ•°æ®...`);

        const response = await fetchWithRetry(
          `https://www.okx.com/api/v5/public/open-interest?instId=${okxSymbol}`,
          { method: 'GET' },
          2,
          false
        );

        if (!response.ok) {
          if (response.status === 400 || response.status === 404) {
            addLog('info', `${symbol} OKXæš‚æ— æœŸè´§åˆçº¦äº¤æ˜“`);
            return null;
          }
          addLog('warning', `OKXæŒä»“é‡APIè¿”å›é”™è¯¯: ${response.status}`);
          return null;
        }

        const json = await response.json();

        if (!json || json.code !== "0" || !json.data || json.data.length === 0) {
          addLog('warning', `OKXè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸æˆ–æ— æ•°æ®`);
          return null;
        }

        // OKX è¿”å›çš„æ•°æ®æ ¼å¼
        const data = json.data[0];
        const openInterest = parseFloat(data.oi) || 0;
        const time = data.ts || Date.now();

        addLog('success', `OKXè·å– ${symbol} æŒä»“é‡æˆåŠŸ: ${openInterest.toFixed(2)} USDT`);

        return {
          openInterest: openInterest,
          time: time ? new Date(time).toLocaleString('zh-CN') : '--',
          timestamp: time,
          symbol: symbol,
          source: 'OKX'
        };
      } catch (error) {
        addLog('warning', `OKXè·å– ${symbol} æŒä»“é‡å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å– Bybit åˆçº¦æŒä»“é‡
    async function fetchBybitOpenInterest(symbol) {
      try {
        addLog('api', `æ­£åœ¨è¿æ¥ Bybit API è·å– ${symbol} æŒä»“é‡æ•°æ®...`);

        const response = await fetchWithRetry(
          `https://api.bybit.com/v5/market/open-interest?category=linear&symbol=${symbol}`,
          { method: 'GET' },
          2,
          false
        );

        if (!response.ok) {
          if (response.status === 400 || response.status === 404) {
            addLog('info', `${symbol} Bybitæš‚æ— æœŸè´§åˆçº¦äº¤æ˜“`);
            return null;
          }
          addLog('warning', `BybitæŒä»“é‡APIè¿”å›é”™è¯¯: ${response.status}`);
          return null;
        }

        const json = await response.json();

        if (!json || json.retCode !== 0 || !json.result || !json.result.list || json.result.list.length === 0) {
          addLog('warning', `Bybitè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸æˆ–æ— æ•°æ®`);
          return null;
        }

        // Bybit è¿”å›çš„æ•°æ®æ ¼å¼
        const data = json.result.list[0];
        const openInterest = parseFloat(data.openInterest) || 0;
        const time = data.timestamp || Date.now();

        addLog('success', `Bybitè·å– ${symbol} æŒä»“é‡æˆåŠŸ: ${openInterest.toFixed(2)} USDT`);

        return {
          openInterest: openInterest,
          time: time ? new Date(time).toLocaleString('zh-CN') : '--',
          timestamp: time,
          symbol: symbol,
          source: 'Bybit'
        };
      } catch (error) {
        addLog('warning', `Bybitè·å– ${symbol} æŒä»“é‡å¤±è´¥`, error.message);
        return null;
      }
    }

    // è·å–å¸å®‰åˆçº¦æŒä»“é‡ï¼ˆå¤šæºé™çº§æ–¹æ¡ˆï¼‰
    async function fetchOpenInterestWithFallback(symbol) {
      // æ•°æ®æºä¼˜å…ˆçº§ï¼šBinance â†’ OKX â†’ Bybitï¼ˆç§»é™¤Bitgetã€MEXCã€Gateï¼‰
      const dataSources = [
        { name: 'Binance', func: fetchBinanceOpenInterest },
        { name: 'OKX', func: fetchOKXOpenInterest },
        { name: 'Bybit', func: fetchBybitOpenInterest }
      ];

      for (let i = 0; i < dataSources.length; i++) {
        const source = dataSources[i];
        try {
          addLog('info', `å°è¯•ä» ${source.name} è·å– ${symbol} æŒä»“é‡...`);
          const result = await source.func(symbol);
          
          if (result && result.openInterest > 0) {
            addLog('success', `âœ… ${source.name} æˆåŠŸè·å– ${symbol} æŒä»“é‡: ${result.openInterest.toFixed(2)} USDT`);
            return result;
          }
        } catch (error) {
          addLog('info', `${source.name} è·å–å¤±è´¥ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæ•°æ®æº`);
        }
      }

      addLog('warning', `æ‰€æœ‰æ•°æ®æºå‡æ— æ³•è·å– ${symbol} æŒä»“é‡æ•°æ®`);
      return null;
    }

    // è·å–å¸å®‰åˆçº¦æŒä»“é‡
    async function fetchBinanceOpenInterest(symbol) {
      try {
        // æ£€æŸ¥æ˜¯å¦åœ¨åˆçº¦ç™½åå•ä¸­ï¼ˆé¿å…æŸ¥è¯¢æ— åˆçº¦çš„å¸ç§ï¼‰
        if (!isFuturesSymbol(symbol)) {
          addLog('info', `${symbol} ä¸åœ¨åˆçº¦ç™½åå•ï¼Œè·³è¿‡æŒä»“é‡æŸ¥è¯¢`);
          return null;
        }
        
        addLog('api', `æ­£åœ¨è·å– ${symbol} æŒä»“é‡æ•°æ®...`);

        const response = await fetchWithRetry(
          `https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`,
          { method: 'GET' },
          2,
          false // Binance APIä¸éœ€è¦ä»£ç†
        );

        if (!response.ok) {
          // 400é”™è¯¯ï¼šå¸ç§æ— åˆçº¦äº¤æ˜“æˆ–symbolæ— æ•ˆï¼Œä¸æŠ¥é”™ï¼Œè¿”å›null
          if (response.status === 400) {
            addLog('info', `${symbol} æš‚æ— æœŸè´§åˆçº¦äº¤æ˜“`);
            return null;
          }
          addLog('warning', `æŒä»“é‡APIè¿”å›é”™è¯¯: ${response.status}`);
          return null;
        }

        const data = await response.json();

        if (!data || !data.openInterest) {
          addLog('warning', `æœªè·å–åˆ° ${symbol} æŒä»“é‡æ•°æ®`);
          return null;
        }

        const openInterest = parseFloat(data.openInterest) || 0;
        const time = data.time ? new Date(data.time).toLocaleString('zh-CN') : '--';

        addLog('success', `è·å– ${symbol} æŒä»“é‡æˆåŠŸ: ${openInterest.toFixed(2)} USDT`);

        return {
          openInterest: openInterest,
          time: time,
          timestamp: data.time,
          symbol: symbol
        };
      } catch (error) {
        addLog('warning', `è·å– ${symbol} æŒä»“é‡å¤±è´¥`, error.message);
        return null;
      }
    }

    // åˆ‡æ¢APIæä¾›å•†
    function switchApiProvider() {
      const selector = document.getElementById('apiSelector');
      if (!selector) return;

      currentApiProvider = selector.value;
      addLog('info', `åˆ‡æ¢APIæä¾›å•†ä¸º: ${currentApiProvider.toUpperCase()}`);

      // æ¸…ç©ºä»·æ ¼ç¼“å­˜æ•°æ®ï¼ˆä¿ç•™å¼‚åŠ¨ä¿¡å·ï¼Œé¿å…ä¸¢å¤±å·²ç›‘æ§çš„äº¤æ˜“å¯¹ï¼‰
      binancePrices = [];
      localStorage.removeItem(STORAGE_KEYS.tickerData); // æ¸…ç©ºäº¤æ˜“å¯¹æ•°æ®ç¼“å­˜

      // ç«‹å³åˆ·æ–°æ•°æ®
      updateAnomalyView();
      addLog('info', 'å·²ä¿ç•™å¼‚åŠ¨ä¿¡å·å†å²ï¼Œæ­£åœ¨é‡æ–°è·å–è¡Œæƒ…æ•°æ®...');

      // è§¦å‘æ•°æ®åˆ·æ–°
      refreshAll();
    }

    // è·å–æè´ªæŒ‡æ•°ï¼ˆä½¿ç”¨Alternative.me + å¤‡ç”¨æ–¹æ¡ˆï¼‰
    async function fetchFearGreedIndex() {
      // å°è¯•å¤šä¸ªAPIæº
      const apiSources = [
        {
          name: 'Alternative.me (ä¸»)',
          url: `${FEAR_GREED_API_URL}?limit=1`,
          useProxy: false
        },
        {
          name: 'Alternative.me (ä»£ç†)',
          url: `${FEAR_GREED_API_URL}?limit=1`,
          useProxy: true
        }
      ];

      for (const source of apiSources) {
        try {
          addLog('api', `æ­£åœ¨å°è¯•${source.name}è·å–æè´ªæŒ‡æ•°...`);
          
          const response = await fetchWithRetry(
            source.url,
            { method: 'GET', headers: { 'Content-Type': 'application/json' } },
            2,
            source.useProxy
          );
          
          if (!response.ok) {
            addLog('warning', `${source.name}è¿æ¥å¤±è´¥: ${response.status}`);
            continue;
          }
          
          const json = await response.json();
          
          if (!json || !json.data || json.data.length === 0) {
            addLog('warning', `${source.name}è¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸`);
            continue;
          }
          
          const fgData = json.data[0];
          addLog('success', `æè´ªæŒ‡æ•°è·å–æˆåŠŸ (${source.name})`);
          
          return {
            value: fgData.value,
            classification: fgData.value_classification,
            timestamp: fgData.timestamp
          };
        } catch (error) {
          addLog('warning', `${source.name}è·å–å¤±è´¥: ${error.message}`);
          continue;
        }
      }
      
      // æ‰€æœ‰APIéƒ½å¤±è´¥äº†ï¼Œè¿”å›é»˜è®¤å€¼
      addLog('warning', 'æ‰€æœ‰æè´ªæŒ‡æ•°APIå‡å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼');
      return {
        value: 50,
        classification: 'Neutral',
        timestamp: Date.now()
      };
    }

    // ==================== CoinGecko API è°ƒç”¨å‡½æ•° ====================

    // è·å–çƒ­é—¨æœç´¢ä»£å¸ - ä½¿ç”¨Coinlore
    async function fetchTrendingCoins() {
      // ç›´æ¥ä½¿ç”¨Coinlore APIï¼ˆå…è´¹æ— é™ï¼‰
      return await fetchCoinloreTrending();
    }

    // è·å–ä»£å¸åˆ†ç±»åˆ—è¡¨
    async function fetchCoinCategories() {
      try {
        const response = await fetchWithRetry('https://api.coingecko.com/api/v3/coins/categories', {}, 2, true);

        if (!response.ok) {
          addLog('error', 'CoinGeckoåˆ†ç±»åˆ—è¡¨è·å–å¤±è´¥');
          return [];
        }

        const data = await response.json();
        return data;
      } catch (error) {
        addLog('error', 'CoinGeckoåˆ†ç±»åˆ—è¡¨è·å–å¤±è´¥', error.message);
        return [];
      }
    }

    // ==================== æ··åˆAPIå‡½æ•°ï¼ˆ2026å¹´æ–¹æ¡ˆï¼‰====================

    // è·å–çƒ­é—¨ä»£å¸ï¼ˆä½¿ç”¨Coinloreï¼Œå…è´¹æ— é™ï¼‰
    async function fetchCoinloreTrending() {
      try {
        addLog('api', 'æ­£åœ¨è¿æ¥Coinlore APIè·å–çƒ­é—¨ä»£å¸...');
        
        // è·å–çƒ­é—¨ä»£å¸ï¼ˆå–Top 20ï¼Œè¿‡æ»¤ç¨³å®šå¸åç¡®ä¿æœ‰10ä¸ªï¼‰
        const url = `${COINLORE_API_URL}/tickers/?start=0&limit=20`;
        const response = await fetchWithRetry(url, {}, 2, true);
        
        if (!response.ok) {
          addLog('error', 'Coinlore APIè¿æ¥å¤±è´¥');
          return [];
        }
        
        const json = await response.json();
        
        if (!json || !json.data) {
          addLog('error', 'Coinlore APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸');
          return [];
        }
        
        // è¿‡æ»¤æ‰æ‰€æœ‰ç¨³å®šå¸ï¼ˆç»Ÿä¸€è½¬ä¸ºå¤§å†™åŒ¹é…ï¼‰
        const stablecoins = [
          'USDT', 'USDC', 'USDE', 'DAI', 'BUSD', 'TUSD', 'USDP', 'USDD',
          'FRAX', 'USTC', 'LUSD', 'SUSD', 'RAI', 'FEI', 'GUSD', 'PYUSD',
          'EURC', 'XAUT', 'PAXG', 'CUSDC', 'AUSDC', 'USDCE', 'FDUSD'
        ].map(s => s.toUpperCase());
        const filteredData = json.data.filter(coin => 
          !stablecoins.includes(coin.symbol.toUpperCase())
        );
        
        addLog('success', `Coinloreè·å–çƒ­é—¨ä»£å¸æˆåŠŸï¼Œå…±${json.data.length}ä¸ªï¼ˆè¿‡æ»¤ç¨³å®šå¸å${filteredData.length}ä¸ªï¼Œçƒ­é—¨æœç´¢æ¿å—æ˜¾ç¤ºTop 10ï¼‰`);
        
        // å–å‰10ä¸ªç”¨äºçƒ­é—¨æœç´¢æ¿å—
        return filteredData.slice(0, 10).map(coin => ({
          id: coin.id,
          name: coin.name,
          symbol: coin.symbol,
          thumb: coin.icon || null,
          market_cap_rank: coin.rank || null
        }));
      } catch (error) {
        addLog('error', 'Coinloreè·å–çƒ­é—¨ä»£å¸å¤±è´¥', error.message);
        return [];
      }
    }

    // è·å–ä»£å¸è¯¦æƒ…ï¼ˆç”¨äºåˆ†ç±»ï¼‰
    async function fetchCoinDetails(coinId) {
      try {
        const response = await fetchWithRetry(`https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false`, {}, 2, true);

        if (!response.ok) {
          return null;
        }

        const data = await response.json();
        return data;
      } catch (error) {
        return null;
      }
    }

    // å¼‚åŠ¨åˆ†å¸ƒç»Ÿè®¡ï¼ˆæŒ‰åˆ†ç±»åˆ†ç»„ï¼‰
    async function calculateAnomalyDistribution(signals) {
      try {
        const categoryMap = new Map();

        for (const signal of signals) {
          // è·å–ä»£å¸åˆ†ç±»
          let categories = [];
          const coinId = await searchCoinGeckoId(signal.symbol);

          if (coinId) {
            const details = await fetchCoinDetails(coinId);
            if (details && details.categories) {
              categories = details.categories;
            }
          }

          // å¦‚æœæ²¡æœ‰åˆ†ç±»ï¼Œå½’ä¸º"å…¶ä»–"
          if (categories.length === 0) {
            categories = ['å…¶ä»–'];
          }

          // ç»Ÿè®¡æ¯ä¸ªåˆ†ç±»çš„å¼‚åŠ¨æ•°é‡
          categories.forEach(category => {
            const count = categoryMap.get(category) || 0;
            categoryMap.set(category, count + 1);
          });
        }

        // è½¬æ¢ä¸ºæ•°ç»„å¹¶æ’åº
        const distribution = Array.from(categoryMap.entries())
          .map(([category, count]) => ({ category, count }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 5); // å–TOP5

        return distribution;
      } catch (error) {
        console.error('è®¡ç®—å¼‚åŠ¨åˆ†å¸ƒå¤±è´¥:', error);
        return [];
      }
    }

    // åˆ‡æ¢ç»¼åˆä¿¡æ¯æ ‡ç­¾
    function switchMarketTab(tab) {
      // æ›´æ–°æŒ‰é’®æ ·å¼
      ['Market', 'Anomaly', 'Trending', 'Pools'].forEach(name => {
        const btn = document.getElementById(`tab${name}`);
        if (name.toLowerCase() === tab) {
          btn.className = 'px-2 py-1 rounded-lg text-xs font-medium transition-all bg-blue-500 text-white';
        } else {
          btn.className = 'px-2 py-1 rounded-lg text-xs font-medium transition-all bg-slate-700 text-slate-300 hover:bg-slate-600';
        }
      });

      // åˆ‡æ¢å†…å®¹æ˜¾ç¤º
      ['Market', 'Anomaly', 'Trending', 'Pools'].forEach(name => {
        const content = document.getElementById(`content${name}`);
        if (name.toLowerCase() === tab) {
          content.classList.remove('hidden');
        } else {
          content.classList.add('hidden');
        }
      });

      // å¦‚æœåˆ‡æ¢åˆ°å¼‚åŠ¨åˆ†å¸ƒï¼Œåˆ·æ–°å¼‚åŠ¨ç»Ÿè®¡æ•°æ®
      if (tab === 'anomaly' && anomalySignals.length > 0) {
        updateAnomalyDistribution();
      }

      // å¦‚æœåˆ‡æ¢åˆ°é“¾ä¸Šæ± å­æ ‡ç­¾ï¼ŒåŠ è½½æ± å­æ•°æ®
      if (tab === 'pools') {
        fetchOnchainPools();
      }
    }

    // åˆ·æ–°å¸‚åœºæ•°æ®
    async function refreshMarketData() {
      try {
        // æ›´æ–°æ—¶é—´æˆ³
        const lastUpdateEl = document.getElementById('marketDataLastUpdate');
        if (lastUpdateEl) {
          lastUpdateEl.textContent = `æ›´æ–°: ${new Date().toLocaleTimeString('zh-CN')}`;
        }

        // è·³è¿‡å¸‚åœºæ¦‚è§ˆï¼ˆé¡µé¢æ— å¯¹åº”æ˜¾ç¤ºå…ƒç´ ï¼‰

        // è·³è¿‡æè´ªæŒ‡æ•°ï¼ˆAlternative.me APIæœ‰CORSé—®é¢˜ï¼‰
        addLog('info', 'æè´ªæŒ‡æ•°æš‚æ—¶ä¸å¯ç”¨ï¼ˆCORSé™åˆ¶ï¼‰');

        // è·å–çƒ­é—¨æœç´¢
        const trendingCoins = await fetchTrendingCoins();
        const trendingContainer = document.getElementById('marketTrending');
        
        addLog('info', `çƒ­é—¨ä»£å¸æ•°é‡: ${trendingCoins.length}`);

        if (trendingCoins.length > 0 && trendingContainer) {
          trendingContainer.innerHTML = trendingCoins.map((item, index) => {
            // Coinloreè¿”å›çš„æ•°æ®ç»“æ„æ˜¯æ‰å¹³çš„ï¼Œç›´æ¥ä½¿ç”¨item
            // CoinGeckoè¿”å›çš„æ•°æ®ç»“æ„æ˜¯ { item: { ... } }
            const coin = item.item || item;  // å…¼å®¹ä¸¤ç§æ ¼å¼
            
            if (!coin) return '';
            
            const coinSymbol = coin.symbol || '';
            const coinName = coin.name || '';
            const coinThumb = coin.thumb || coin.icon || '';
            
            // è·å–å®æ—¶ä»·æ ¼
            const coinSymbolUSDT = coinSymbol + 'USDT';
            const ticker = binancePrices.find(p => p.symbol === coinSymbolUSDT);
            const currentPrice = ticker ? parseFloat(ticker.price) : null;
            const priceDisplay = currentPrice ? `$${currentPrice.toFixed(currentPrice < 1 ? 6 : 2)}` : '--';
            
            const isAnomaly = anomalySignals.some(signal => 
              coinSymbol && signal.symbol.toLowerCase().includes(coinSymbol.toLowerCase())
            );

            return `
              <div class="flex items-center justify-between w-full ${isAnomaly ? 'bg-yellow-500/20' : ''} hover:bg-slate-200 cursor-pointer rounded px-1 py-0.5 transition-colors" onclick="showCoinDetail('${coinSymbol}USDT')">
                <div class="flex items-center gap-1.5">
                  <span class="text-black font-medium">${index + 1}.${coinSymbol}</span>
                  ${isAnomaly ? '<span class="text-yellow-400">âš¡</span>' : ''}
                </div>
                <span class="text-black font-mono text-right">${priceDisplay}</span>
              </div>
            `;
          }).join('');
          addLog('success', 'çƒ­é—¨ä»£å¸åˆ—è¡¨å·²æ›´æ–°');
        } else if (trendingContainer) {
          trendingContainer.innerHTML = '<div class="text-black text-center py-2">æš‚æ— æ•°æ®</div>';
          addLog('warning', 'çƒ­é—¨ä»£å¸åˆ—è¡¨ä¸ºç©º');
        } else {
          addLog('error', 'æ‰¾ä¸åˆ°marketTrendingå…ƒç´ ');
        }

        // æ›´æ–°æ’è¡Œæ¦œï¼ˆæ¶¨å¹…æ¦œã€æˆäº¤é‡æ¦œã€å¼‚åŠ¨æ¦œï¼‰
        if (binancePrices.length > 0) {
          // 24hæ¶¨å¹…æ¦œTOP10
          const topGainersContainer = document.getElementById('topGainers');
          const topGainersData = [...binancePrices]
            .sort((a, b) => b.priceChangePercent - a.priceChangePercent)
            .slice(0, 10);
          
          if (topGainersContainer) {
            topGainersContainer.innerHTML = topGainersData.map((item, index) => {
              const isAnomaly = anomalySignals.some(s => s.symbol === item.symbol);
              const priceChangePercent = parseFloat(item.priceChangePercent) || 0;
              return `
                <div class="flex items-center justify-between ${isAnomaly ? 'bg-yellow-500/20' : ''} hover:bg-slate-200 cursor-pointer rounded px-1 py-0.5 transition-colors" onclick="showCoinDetail('${item.symbol}')">
                  <div class="flex items-center gap-1.5">
                    <span class="text-black">${index + 1}.</span>
                    <span class="text-black font-medium">${item.symbol.replace('USDT', '')}</span>
                    ${isAnomaly ? '<span class="text-yellow-400">âš¡</span>' : ''}
                  </div>
                  <span class="text-green-500 font-medium">+${priceChangePercent.toFixed(2)}%</span>
                </div>
              `;
            }).join('');
            addLog('success', '24hæ¶¨å¹…æ¦œå·²æ›´æ–°');
          }

          // 24hæˆäº¤é‡æ¦œTOP10ï¼ˆä½¿ç”¨quoteVolumeï¼Œå³æˆäº¤é‡‘é¢ï¼‰
          const topVolumeContainer = document.getElementById('topVolume');
          const topVolumeData = [...binancePrices]
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, 10);

          if (topVolumeContainer) {
            topVolumeContainer.innerHTML = topVolumeData.map((item, index) => {
              const quoteVolume = item.quoteVolume; // æˆäº¤é‡‘é¢ï¼ˆä»¥USDTè®¡ä»·ï¼‰
              const isAnomaly = anomalySignals.some(s => s.symbol === item.symbol);

              // æ ¼å¼åŒ–é‡‘é¢æ˜¾ç¤º
              let volumeFormatted;
              if (quoteVolume >= 1e9) {
                volumeFormatted = `$${(quoteVolume / 1e9).toFixed(2)}B`;
              } else if (quoteVolume >= 1e6) {
                volumeFormatted = `$${(quoteVolume / 1e6).toFixed(0)}M`;
              } else {
                volumeFormatted = `$${quoteVolume.toLocaleString()}`;
              }

              return `
                <div class="flex items-center justify-between ${isAnomaly ? 'bg-yellow-500/20' : ''} hover:bg-slate-200 cursor-pointer rounded px-1 py-0.5 transition-colors" onclick="showCoinDetail('${item.symbol}')">
                  <div class="flex items-center gap-1.5">
                    <span class="text-black">${index + 1}.</span>
                    <span class="text-black font-medium">${item.symbol.replace('USDT', '')}</span>
                    ${isAnomaly ? '<span class="text-yellow-400">âš¡</span>' : ''}
                  </div>
                  <span class="text-black font-medium">${volumeFormatted}</span>
                </div>
              `;
            }).join('');
            addLog('success', '24hæˆäº¤é‡æ¦œå·²æ›´æ–°');
          }

          // å¼‚åŠ¨æ¦œTOP10ï¼ˆæŒ‰å¼‚åŠ¨æ¬¡æ•°æ’åºï¼‰
          const topAnomaliesContainer = document.getElementById('topAnomalies');
          if (topAnomaliesContainer) {
            if (anomalySignals.length > 0) {
              const sortedAnomalies = [...anomalySignals]
                .sort((a, b) => (b.count || 1) - (a.count || 1))
                .slice(0, 10);
              
              topAnomaliesContainer.innerHTML = sortedAnomalies.map((signal, index) => {
                const directionIcon = signal.direction === 'up' ? 'ğŸ“ˆ' : 'ğŸ“‰';
                return `
                  <div class="flex items-center justify-between hover:bg-slate-200 cursor-pointer rounded px-1 py-0.5 transition-colors" onclick="showCoinDetail('${signal.symbol}')">
                    <div class="flex items-center gap-1.5">
                      <span class="text-black">${index + 1}.</span>
                      <span class="text-black font-medium">${signal.symbol.replace('USDT', '')}</span>
                    </div>
                    <div class="flex items-center gap-1">
                      <span class="text-sm">${directionIcon}</span>
                      <span class="text-black text-xs font-medium">Ã—${signal.count || 1}</span>
                    </div>
                  </div>
                `;
              }).join('');
              addLog('success', 'å¼‚åŠ¨æ¦œå·²æ›´æ–°');
            } else {
              topAnomaliesContainer.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨</div>';
            }
          }
        } else {
          // äº¤æ˜“å¯¹æ•°æ®ä¸ºç©ºï¼Œæ˜¾ç¤ºæç¤º
          const containers = ['topGainers', 'topVolume', 'topAnomalies'];
          containers.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
              el.innerHTML = '<div class="text-slate-500 text-center py-2">ç­‰å¾…äº¤æ˜“å¯¹æ•°æ®...</div>';
            }
          });
          addLog('warning', 'äº¤æ˜“å¯¹æ•°æ®ä¸ºç©ºï¼Œè¯·åˆ·æ–°é¡µé¢');
        }

        // æ›´æ–°å¼‚åŠ¨åˆ†å¸ƒ
        if (anomalySignals.length > 0) {
          // æŒ‰åˆ†ç±»ç»Ÿè®¡
          const categoryMap = new Map();
          // æŒ‰å¼‚åŠ¨ç±»å‹ç»Ÿè®¡
          const typeMap = new Map();
          // æŒ‰ä»·æ ¼åŒºé—´ç»Ÿè®¡
          const priceRangeMap = new Map();

          for (const signal of anomalySignals) {
            // è·å–ä»£å¸åˆ†ç±»ï¼ˆç®€åŒ–ç‰ˆï¼Œä¸è°ƒç”¨CoinGecko APIï¼‰
            // æ ¹æ®å¸ç§åç§°è¿›è¡Œç®€å•åˆ†ç±»
            let categories = ['å…¶ä»–'];
            const symbol = signal.symbol.replace('USDT', '').toUpperCase();
            
            // ç®€å•åˆ†ç±»è§„åˆ™
            if (['BTC', 'ETH', 'BNB', 'SOL', 'ADA', 'XRP', 'DOT', 'MATIC', 'AVAX', 'LINK'].includes(symbol)) {
              categories = ['ä¸»æµå¸'];
            } else if (symbol.includes('MEME') || symbol.includes('DOGE') || symbol.includes('SHIB') || symbol.includes('PEPE') || symbol.includes('FLOKI')) {
              categories = ['Meme'];
            } else if (symbol.includes('AI') || symbol.includes('FET') || symbol.includes('RNDR') || symbol.includes('WLD')) {
              categories = ['AI'];
            } else if (symbol.includes('GAMING') || symbol.includes('GAME') || symbol.includes('IMX') || symbol.includes('SAND')) {
              categories = ['GameFi'];
            } else if (symbol.includes('DEFI') || symbol.includes('UNI') || symbol.includes('AAVE') || symbol.includes('CRV')) {
              categories = ['DeFi'];
            } else if (symbol.includes('L2') || symbol.includes('OP') || symbol.includes('ARB') || symbol.includes('MANTLE')) {
              categories = ['Layer 2'];
            }

            // ç»Ÿè®¡åˆ†ç±»
            categories.forEach(category => {
              const count = categoryMap.get(category) || 0;
              categoryMap.set(category, count + 1);
            });

            // ç»Ÿè®¡å¼‚åŠ¨ç±»å‹
            const typeKey = signal.strategy || 'unknown';
            const typeCount = typeMap.get(typeKey) || 0;
            typeMap.set(typeKey, typeCount + 1);

            // ç»Ÿè®¡ä»·æ ¼åŒºé—´
            const price = parseFloat(signal.price);
            let priceRange;
            if (price < 0.01) priceRange = '< $0.01';
            else if (price < 0.1) priceRange = '$0.01-$0.1';
            else if (price < 1) priceRange = '$0.1-$1';
            else if (price < 10) priceRange = '$1-$10';
            else if (price < 100) priceRange = '$10-$100';
            else priceRange = '> $100';
            
            const priceCount = priceRangeMap.get(priceRange) || 0;
            priceRangeMap.set(priceRange, priceCount + 1);
          }

          // æ›´æ–°æŒ‰åˆ†ç±»ç»Ÿè®¡
          const anomalyByCategoryEl = document.getElementById('anomalyByCategory');
          if (anomalyByCategoryEl) {
            const categoryDistribution = Array.from(categoryMap.entries())
              .map(([category, count]) => ({ category, count }))
              .sort((a, b) => b.count - a.count);
            
            if (categoryDistribution.length > 0) {
              const maxCount = categoryDistribution[0].count;
              anomalyByCategoryEl.innerHTML = categoryDistribution.map(({ category, count }) => {
                const percentage = (count / maxCount) * 100;
                return `
                  <div>
                    <div class="flex items-center justify-between mb-0.5">
                      <span class="text-slate-400">${category}</span>
                      <span class="text-white">${count}ä¸ª</span>
                    </div>
                    <div class="w-full bg-slate-700 rounded-full h-1">
                      <div class="bg-gradient-to-r from-purple-500 to-pink-600 h-1 rounded-full" style="width: ${percentage}%"></div>
                    </div>
                  </div>
                `;
              }).join('');
            } else {
              anomalyByCategoryEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— åˆ†ç±»æ•°æ®</div>';
            }
          }

          // æ›´æ–°æŒ‰ç±»å‹ç»Ÿè®¡
          const anomalyByTypeEl = document.getElementById('anomalyByType');
          if (anomalyByTypeEl) {
            const typeDistribution = Array.from(typeMap.entries())
              .map(([type, count]) => ({ type, count }))
              .sort((a, b) => b.count - a.count);

            const typeLabels = {
              'main_up': 'ä¸»åŠ›æ‹‰ç›˜',
              'main_down': 'ä¸»åŠ›ç ¸ç›˜',
              'fund_up': 'èµ„é‡‘æ‹‰ç›˜',
              'fund_down': 'èµ„é‡‘ç ¸ç›˜',
              'unknown': 'æœªçŸ¥'
            };

            if (typeDistribution.length > 0) {
              const maxCount = typeDistribution[0].count;
              anomalyByTypeEl.innerHTML = typeDistribution.map(({ type, count }) => {
                const percentage = (count / maxCount) * 100;
                const label = typeLabels[type] || type;
                return `
                  <div>
                    <div class="flex items-center justify-between mb-0.5">
                      <span class="text-slate-400">${label}</span>
                      <span class="text-white">${count}ä¸ª</span>
                    </div>
                    <div class="w-full bg-slate-700 rounded-full h-1">
                      <div class="bg-gradient-to-r from-blue-500 to-cyan-600 h-1 rounded-full" style="width: ${percentage}%"></div>
                    </div>
                  </div>
                `;
              }).join('');
            } else {
              anomalyByTypeEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— ç±»å‹æ•°æ®</div>';
            }
          }

          // æ›´æ–°æŒ‰ä»·æ ¼åŒºé—´ç»Ÿè®¡
          const anomalyByPriceEl = document.getElementById('anomalyByPrice');
          if (anomalyByPriceEl) {
            const priceDistribution = Array.from(priceRangeMap.entries())
              .map(([range, count]) => ({ range, count }))
              .sort((a, b) => b.count - a.count);

            if (priceDistribution.length > 0) {
              const maxCount = priceDistribution[0].count;
              anomalyByPriceEl.innerHTML = priceDistribution.map(({ range, count }) => {
                const percentage = (count / maxCount) * 100;
                return `
                  <div>
                    <div class="flex items-center justify-between mb-0.5">
                      <span class="text-slate-400">${range}</span>
                      <span class="text-white">${count}ä¸ª</span>
                    </div>
                    <div class="w-full bg-slate-700 rounded-full h-1">
                      <div class="bg-gradient-to-r from-yellow-500 to-orange-600 h-1 rounded-full" style="width: ${percentage}%"></div>
                    </div>
                  </div>
                `;
              }).join('');
            } else {
              anomalyByPriceEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— ä»·æ ¼æ•°æ®</div>';
            }
          }

          // æ›´æ–°ä»Šæ—¥å¼‚åŠ¨æ±‡æ€»
          const todayAnomalySummaryEl = document.getElementById('todayAnomalySummary');
          if (todayAnomalySummaryEl) {
            const todaySignals = anomalySignals.filter(s => {
              const signalDate = new Date(s.timestamp);
              const today = new Date();
              return signalDate.getDate() === today.getDate() && 
                     signalDate.getMonth() === today.getMonth() && 
                     signalDate.getFullYear() === today.getFullYear();
            });

            const summaryData = {
              totalCount: todaySignals.length,
              upCount: todaySignals.filter(s => s.direction === 'up').length,
              downCount: todaySignals.filter(s => s.direction === 'down').length,
              fundCount: todaySignals.filter(s => s.strategy && s.strategy.includes('fund')).length,
              mainCount: todaySignals.filter(s => s.strategy && s.strategy.includes('main')).length
            };

            todayAnomalySummaryEl.innerHTML = `
              <div class="grid grid-cols-2 gap-2">
                <div class="bg-slate-800/50 rounded p-2 text-center">
                  <div class="text-lg font-bold text-white">${summaryData.totalCount}</div>
                  <div class="text-xs text-slate-400">æ€»å¼‚åŠ¨</div>
                </div>
                <div class="bg-slate-800/50 rounded p-2 text-center">
                  <div class="text-lg font-bold text-green-500">${summaryData.upCount}</div>
                  <div class="text-xs text-slate-400">å‘ä¸Šå¼‚åŠ¨</div>
                </div>
                <div class="bg-slate-800/50 rounded p-2 text-center">
                  <div class="text-lg font-bold text-red-500">${summaryData.downCount}</div>
                  <div class="text-xs text-slate-400">å‘ä¸‹å¼‚åŠ¨</div>
                </div>
                <div class="bg-slate-800/50 rounded p-2 text-center">
                  <div class="text-lg font-bold text-yellow-500">${summaryData.fundCount}</div>
                  <div class="text-xs text-slate-400">èµ„é‡‘å¼‚åŠ¨</div>
                </div>
              </div>
            `;
          }

          addLog('success', 'å¼‚åŠ¨åˆ†å¸ƒå·²æ›´æ–°');
        } else {
          // å¼‚åŠ¨ä¿¡å·ä¸ºç©ºæ—¶ï¼Œæ˜¾ç¤ºæç¤ºï¼ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼‰
          const categoryEl = document.getElementById('anomalyByCategory');
          if (categoryEl) categoryEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨æ•°æ®</div>';

          const typeEl = document.getElementById('anomalyByType');
          if (typeEl) typeEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨æ•°æ®</div>';

          const priceEl = document.getElementById('anomalyByPrice');
          if (priceEl) priceEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨æ•°æ®</div>';

          const summaryEl = document.getElementById('todayAnomalySummary');
          if (summaryEl) summaryEl.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— å¼‚åŠ¨æ•°æ®</div>';
        }

      } catch (error) {
        console.error('åˆ·æ–°å¸‚åœºæ•°æ®å¤±è´¥:', error);
      }

      // æ›´æ–°é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹é›†åˆ
      updateImportantSymbols();
    }

    // è·å–é“¾ä¸Šæ± å­æ•°æ®
    async function fetchOnchainPools() {
      try {
        addLog('info', 'å¼€å§‹åŠ è½½é“¾ä¸Šæ± å­æ•°æ®...');

        // è·å–ä»¥å¤ªåŠçƒ­é—¨æ± 
        await fetchNetworkPools('eth', 'ethTopPools');

        // è·å–BSCçƒ­é—¨æ± 
        await fetchNetworkPools('bsc', 'bscTopPools');

        addLog('success', 'é“¾ä¸Šæ± å­æ•°æ®åŠ è½½å®Œæˆ');
      } catch (error) {
        addLog('error', 'é“¾ä¸Šæ± å­æ•°æ®åŠ è½½å¤±è´¥', error.message);
      }
    }

    // è·å–æŒ‡å®šç½‘ç»œçš„æ± å­æ•°æ®
    async function fetchNetworkPools(network, containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        addLog('error', `æ‰¾ä¸åˆ°${containerId}å…ƒç´ `);
        return;
      }

      try {
        // ä½¿ç”¨CoinGeckoé“¾ä¸ŠAPI
        const apiUrl = `https://api.geckoterminal.com/api/v2/networks/${network}/trending_pools`;

        const response = await fetchWithRetry(apiUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        }, 2, false); // GeckoTerminalä¸éœ€è¦ä»£ç†

        if (!response.ok) {
          addLog('warning', `${network.toUpperCase()}æ± å­APIè¿”å›é”™è¯¯: ${response.status}`);
          container.innerHTML = '<div class="text-slate-500 text-center py-2">åŠ è½½å¤±è´¥</div>';
          return;
        }

        const json = await response.json();

        if (!json || !json.data) {
          addLog('warning', `${network.toUpperCase()}æ± å­æ•°æ®ä¸ºç©º`);
          container.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— æ•°æ®</div>';
          return;
        }

        const pools = json.data;

        if (pools.length === 0) {
          container.innerHTML = '<div class="text-slate-500 text-center py-2">æš‚æ— æ•°æ®</div>';
          return;
        }

        // æ˜¾ç¤ºå‰10ä¸ªæ± å­
        const topPools = pools.slice(0, 10);

        container.innerHTML = topPools.map((pool, index) => {
          const attributes = pool.attributes;
          const poolAddress = attributes.address || '';
          const name = attributes.name || attributes.address?.substring(0, 8) + '...' || 'æœªçŸ¥æ± å­';
          const dex = attributes.dex?.name || attributes.exchange_name || 'Unknown';
          const dexName = attributes.dex?.address || '';
          
          // æ”¯æŒå¤šç§æ•°æ®ç»“æ„æå–ä»£å¸ç¬¦å·
          let baseToken = '?';
          let quoteToken = '?';
          let baseTokenAddress = '';
          let baseTokenName = '';

          if (attributes.base_token) {
            baseToken = attributes.base_token.symbol || attributes.base_token.name || '?';
            baseTokenAddress = attributes.base_token.address || '';
            baseTokenName = attributes.base_token.name || baseToken;
          } else if (attributes.token0) {
            baseToken = attributes.token0.symbol || attributes.token0.name || '?';
            baseTokenAddress = attributes.token0.address || '';
            baseTokenName = attributes.token0.name || baseToken;
          }

          if (attributes.quote_token) {
            quoteToken = attributes.quote_token.symbol || attributes.quote_token.name || '?';
          } else if (attributes.token1) {
            quoteToken = attributes.token1.symbol || attributes.token1.name || '?';
          }

          // ä»åç§°ä¸­æå–äº¤æ˜“å¯¹ï¼ˆå¦‚æœAPIæ•°æ®ä¸å®Œæ•´ï¼‰
          if ((baseToken === '?' || quoteToken === '?') && name.includes('/')) {
            const parts = name.split('/');
            if (parts.length >= 2) {
              if (baseToken === '?') baseToken = parts[0].trim();
              if (quoteToken === '?') quoteToken = parts[1].trim();
            }
          }

          const reserveInUsd = attributes.reserve_in_usd || 0;
          const volume24h = attributes.volume_usd?.h24 || 0;
          const txCount = attributes.tx_count?.h24 || 0;

          const tvlInM = reserveInUsd / 1000000;
          const volume24hInM = volume24h / 1000000;

          return `
            <div class="bg-slate-800/50 rounded p-2 cursor-pointer hover:bg-slate-700/50 transition-colors" onclick="showPoolDetail('${poolAddress}', '${baseTokenAddress}', '${network}')">
              <div class="flex items-center justify-between mb-1">
                <div class="flex items-center gap-1">
                  <span class="text-slate-500">${index + 1}.</span>
                  <span class="text-white text-xs font-medium">${name}</span>
                  <span class="text-xs text-cyan-400">ğŸ”</span>
                </div>
                <span class="text-xs text-slate-400">${dex}</span>
              </div>
              <div class="flex items-center gap-1 text-xs mb-1">
                <span class="text-slate-400">${baseToken}/${quoteToken}</span>
              </div>
              <div class="grid grid-cols-2 gap-2 text-xs">
                <div>
                  <span class="text-slate-500">TVL:</span>
                  <span class="text-white ml-1">$${tvlInM.toFixed(2)}M</span>
                </div>
                <div class="text-right">
                  <span class="text-slate-500">24hé‡:</span>
                  <span class="text-white">$${volume24hInM.toFixed(2)}M</span>
                </div>
              </div>
            </div>
          `;
        }).join('');

        addLog('success', `${network.toUpperCase()}çƒ­é—¨æ± å·²æ›´æ–°ï¼Œå…±${topPools.length}ä¸ª`);
      } catch (error) {
        addLog('error', `${network.toUpperCase()}æ± å­æ•°æ®è·å–å¤±è´¥`, error.message);
        container.innerHTML = '<div class="text-slate-500 text-center py-2">åŠ è½½å¤±è´¥</div>';
      }
    }

    // è·å–åˆçº¦è¡Œæƒ…æ•°æ®ï¼ˆæ”¯æŒå¤šä¸ªAPIæä¾›å•†ï¼‰
    async function fetchBinancePrices() {
      try {
        let apiUrl, apiName, response, data;

        addLog('api', `æ­£åœ¨è¿æ¥${currentApiProvider.toUpperCase()}å…¬å…±API...`);
        
        if (currentApiProvider === 'okx') {
          // OKX API
          apiUrl = 'https://www.okx.com/api/v5/market/tickers?instType=SWAP';
          apiName = 'OKX';

          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, false);  // OKXæ”¯æŒCORSï¼Œä¸éœ€è¦ä»£ç†

          if (!response.ok) {
            const errorMsg = `OKX APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`;
            addLog('error', errorMsg);
            if (response.status >= 400 && response.status < 600) {
              addLog('warning', 'å°è¯•åˆ‡æ¢å…¬å…±ä»£ç†æœåŠ¡å™¨...');
            }
            return;
          }

          const json = await response.json();

          if (!json || json.code !== "0") {
            addLog('error', `OKX APIè¿”å›é”™è¯¯: ${json.msg || 'æœªçŸ¥é”™è¯¯'}`, `é”™è¯¯ç : ${json.code}`);
            return;
          }

          data = json.data;

          if (!Array.isArray(data)) {
            addLog('error', 'OKX APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', 'æœŸæœ›æ•°ç»„æ ¼å¼ï¼Œå®é™…: ' + typeof data);
            return;
          }

          addLog('success', `OKX APIè¿æ¥æˆåŠŸï¼Œè·å–åˆ° ${data.length} ä¸ªåˆçº¦äº¤æ˜“å¯¹`);

          // è¿‡æ»¤å’Œè½¬æ¢OKXæ•°æ®
          const qualifiedSymbols = data
            .filter(item =>
              item.instId.endsWith('USDT-SWAP') &&
              parseFloat(item.volCcy24h) > 10000000
            )
            .sort((a, b) => parseFloat(b.volCcy24h) - parseFloat(a.volCcy24h))
            .map(item => {
              const priceChange = parseFloat(item.last) - parseFloat(item.open24h);
              const priceChangePercent = (parseFloat(item.last) - parseFloat(item.open24h)) / parseFloat(item.open24h) * 100;

              return {
                symbol: item.instId.replace('-USDT-SWAP', 'USDT'),
                price: item.last,
                priceChange: priceChange,
                priceChangePercent: priceChangePercent,
                volume: item.vol24h,
                quoteVolume: item.volCcy24h
              };
            });

          binancePrices = qualifiedSymbols;

        } else if (currentApiProvider === 'binance') {
          // Binance API
          apiUrl = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
          apiName = 'Binance';

          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, true);

          if (!response.ok) {
            const errorMsg = `Binance APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`;
            addLog('error', errorMsg);
            if (response.status >= 400 && response.status < 600) {
              addLog('warning', 'å°è¯•åˆ‡æ¢å…¬å…±ä»£ç†æœåŠ¡å™¨...');
            }
            return;
          }

          data = await response.json();

          if (!Array.isArray(data)) {
            addLog('error', 'Binance APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', 'æœŸæœ›æ•°ç»„æ ¼å¼ï¼Œå®é™…: ' + typeof data);
            return;
          }

          addLog('success', `Binance APIè¿æ¥æˆåŠŸï¼Œè·å–åˆ° ${data.length} ä¸ªåˆçº¦äº¤æ˜“å¯¹`);

          // è¿‡æ»¤å’Œè½¬æ¢Binanceæ•°æ®
          const qualifiedSymbols = data
            .filter(item =>
              item.symbol.endsWith('USDT') &&
              parseFloat(item.quoteVolume) > 10000000
            )
            .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
            .map(item => ({
              symbol: item.symbol,
              price: item.lastPrice,
              priceChange: item.priceChange,
              priceChangePercent: item.priceChangePercent,
              volume: item.volume,
              quoteVolume: item.quoteVolume
            }));

          binancePrices = qualifiedSymbols;

        } else if (currentApiProvider === 'bybit') {
          // Bybit API
          apiUrl = 'https://api.bybit.com/v5/market/tickers?category=linear';
          apiName = 'Bybit';

          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, false);  // Bybitæ”¯æŒCORSï¼Œä¸éœ€è¦ä»£ç†

          if (!response.ok) {
            const errorMsg = `Bybit APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`;
            addLog('error', errorMsg);
            if (response.status >= 400 && response.status < 600) {
              addLog('warning', 'å°è¯•åˆ‡æ¢å…¬å…±ä»£ç†æœåŠ¡å™¨...');
            }
            return;
          }

          const json = await response.json();

          if (!json || json.retCode !== 0) {
            addLog('error', `Bybit APIè¿”å›é”™è¯¯: ${json.retMsg || 'æœªçŸ¥é”™è¯¯'}`, `é”™è¯¯ç : ${json.retCode}`);
            return;
          }

          data = json.result.list;

          if (!Array.isArray(data)) {
            addLog('error', 'Bybit APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', 'æœŸæœ›æ•°ç»„æ ¼å¼ï¼Œå®é™…: ' + typeof data);
            return;
          }

          addLog('success', `Bybit APIè¿æ¥æˆåŠŸï¼Œè·å–åˆ° ${data.length} ä¸ªåˆçº¦äº¤æ˜“å¯¹`);

          // è¿‡æ»¤å’Œè½¬æ¢Bybitæ•°æ®
          const qualifiedSymbols = data
            .filter(item =>
              item.symbol.endsWith('USDT') &&
              parseFloat(item.turnover24h) > 10000000
            )
            .sort((a, b) => parseFloat(b.turnover24h) - parseFloat(a.turnover24h))
            .map(item => {
              const priceChangePercent = parseFloat(item.price24hPcnt) * 100;
              const price = parseFloat(item.lastPrice);
              const priceChange = price * priceChangePercent / 100;

              return {
                symbol: item.symbol,
                price: item.lastPrice,
                priceChange: priceChange,
                priceChangePercent: priceChangePercent,
                volume: item.volume24h,
                quoteVolume: item.turnover24h
              };
            });

          binancePrices = qualifiedSymbols;
        }

        const logDetails = `æ€»äº¤æ˜“å¯¹: ${data.length}ä¸ª | ç¬¦åˆ>10Mæ¡ä»¶: ${binancePrices.length}ä¸ª | é¡¶éƒ¨3: ${binancePrices.slice(0, 3).map(s => s.symbol).join(', ')}`;
        addLog('info', logDetails);

        // ä¿å­˜äº¤æ˜“å¯¹æ•°æ®åˆ°localStorage
        saveTickerData();

      } catch (error) {
        const errorMsg = `${currentApiProvider.toUpperCase()} APIè¿æ¥å¤±è´¥: ${error.message}`;
        addLog('error', errorMsg);

        // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯æˆ–CORSé”™è¯¯ï¼Œç»™å‡ºæ›´è¯¦ç»†çš„æç¤º
        if (error.message.includes('CORS') || error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          addLog('warning', 'å¯èƒ½æ˜¯CORSé”™è¯¯ï¼Œå°è¯•åˆ‡æ¢å…¬å…±ä»£ç†æœåŠ¡å™¨...');
          addLog('warning', 'å½“å‰ä½¿ç”¨å…¬å…±ä»£ç†: ' + CORS_PROXIES[currentProxyIndex % CORS_PROXIES.length]);
        } else if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {
          addLog('warning', 'è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
        } else if (error.message.includes('ECONNREFUSED')) {
          addLog('warning', 'è¿æ¥è¢«æ‹’ç»ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–ä»£ç†ä¸å¯ç”¨');
        }

        // è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªAPIæä¾›å•†
        const apiProviders = ['okx', 'binance', 'bybit'];
        const currentIndex = apiProviders.indexOf(currentApiProvider);
        if (currentIndex !== -1 && currentIndex < apiProviders.length - 1) {
          const nextProvider = apiProviders[currentIndex + 1];
          addLog('info', `è‡ªåŠ¨åˆ‡æ¢åˆ° ${nextProvider.toUpperCase()} API...`);
          currentApiProvider = nextProvider;
          
          // é€’å½’è°ƒç”¨ï¼Œå°è¯•ä¸‹ä¸€ä¸ªAPI
          setTimeout(() => {
            fetchBinancePrices();
          }, 1000);
        } else {
          // æ‰€æœ‰APIéƒ½å¤±è´¥ï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®ï¼ˆå¦‚æœæœ‰ï¼‰
          if (binancePrices.length > 0) {
            addLog('warning', 'æ‰€æœ‰APIå‡å¤±è´¥ï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®');
          } else {
            addLog('error', 'æ‰€æœ‰APIå‡å¤±è´¥ä¸”æ— ç¼“å­˜æ•°æ®');
          }
        }

        console.error(`âŒ [${currentApiProvider.toUpperCase()} API] è¿æ¥å¤±è´¥:`, error);
      }
    }

    // è·å–é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹æ•°æ®ï¼ˆä¼˜å…ˆè·å–ï¼‰
    async function fetchImportantSymbolsData() {
      try {
        const importantSymbols = getImportantSymbols();

        if (importantSymbols.size === 0) {
          addLog('info', 'æš‚æ— é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹');
          return;
        }

        addLog('info', `å¼€å§‹è·å– ${importantSymbols.size} ä¸ªé‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹çš„æ•°æ®...`);

        let apiUrl, response, data;

        if (currentApiProvider === 'okx') {
          apiUrl = 'https://www.okx.com/api/v5/market/tickers?instType=SWAP';
          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, false);

          if (response.ok) {
            const json = await response.json();
            if (json && json.code === "0" && Array.isArray(json.data)) {
              data = json.data.filter(item =>
                importantSymbols.has(item.instId.replace('-USDT-SWAP', 'USDT'))
              );
            }
          }
        } else if (currentApiProvider === 'binance') {
          apiUrl = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, true);

          if (response.ok) {
            const allData = await response.json();
            if (Array.isArray(allData)) {
              data = allData.filter(item => importantSymbols.has(item.symbol));
            }
          }
        } else if (currentApiProvider === 'bybit') {
          apiUrl = 'https://api.bybit.com/v5/market/tickers?category=linear';
          response = await fetchWithRetry(apiUrl, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          }, 2, false);

          if (response.ok) {
            const json = await response.json();
            if (json && json.retCode === 0 && Array.isArray(json.result.list)) {
              data = json.result.list.filter(item => importantSymbols.has(item.symbol));
            }
          }
        }

        if (data && data.length > 0) {
          addLog('success', `é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹æ•°æ®è·å–å®Œæˆï¼Œå…± ${data.length} ä¸ª`);

          // æ›´æ–° binancePrices ä¸­çš„é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹æ•°æ®
          const importantPrices = data.map(item => {
            if (currentApiProvider === 'okx') {
              const priceChange = parseFloat(item.last) - parseFloat(item.open24h);
              const priceChangePercent = (parseFloat(item.last) - parseFloat(item.open24h)) / parseFloat(item.open24h) * 100;
              return {
                symbol: item.instId.replace('-USDT-SWAP', 'USDT'),
                price: item.last,
                priceChange: priceChange,
                priceChangePercent: priceChangePercent,
                volume: item.vol24h,
                quoteVolume: item.volCcy24h
              };
            } else if (currentApiProvider === 'binance') {
              return {
                symbol: item.symbol,
                price: item.lastPrice,
                priceChange: item.priceChange,
                priceChangePercent: item.priceChangePercent,
                volume: item.volume,
                quoteVolume: item.quoteVolume
              };
            } else if (currentApiProvider === 'bybit') {
              const priceChangePercent = parseFloat(item.price24hPcnt) * 100;
              const price = parseFloat(item.lastPrice);
              const priceChange = price * priceChangePercent / 100;
              return {
                symbol: item.symbol,
                price: item.lastPrice,
                priceChange: priceChange,
                priceChangePercent: priceChangePercent,
                volume: item.volume24h,
                quoteVolume: item.turnover24h
              };
            }
          });

          // æ›´æ–°æˆ–æ·»åŠ åˆ° binancePrices
          const priceMap = new Map();
          importantPrices.forEach(p => priceMap.set(p.symbol, p));

          // ä¿ç•™éé‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹æ•°æ®
          binancePrices.forEach(p => {
            if (!importantSymbols.has(p.symbol)) {
              priceMap.set(p.symbol, p);
            }
          });

          binancePrices = Array.from(priceMap.values());
          addLog('success', 'é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹æ•°æ®å·²æ›´æ–°');
        }

      } catch (error) {
        addLog('error', 'è·å–é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹æ•°æ®å¤±è´¥', error.message);
      }
    }

    // ä¼˜å…ˆåŠ è½½ä¿¡å·ç›‘æ§å’Œå¸‚åœºçƒ­åº¦æ¿å—çš„äº¤æ˜“å¯¹è¯¦æƒ…
    async function fetchPrioritySymbolsData() {
      try {
        addLog('info', 'ğŸš€ å¼€å§‹ä¼˜å…ˆåŠ è½½ä¿¡å·ç›‘æ§å’Œå¸‚åœºçƒ­åº¦æ¿å—çš„äº¤æ˜“å¯¹...');

        // æ”¶é›†éœ€è¦ä¼˜å…ˆåŠ è½½çš„äº¤æ˜“å¯¹ï¼ˆè‡ªåŠ¨å»é‡ï¼‰
        const prioritySymbols = new Set();

        // 1. æ·»åŠ å¼‚åŠ¨ä¿¡å·ä¸­çš„æ‰€æœ‰äº¤æ˜“å¯¹ï¼ˆä¿¡å·ç›‘æ§æ¿å—ï¼‰
        anomalySignals.forEach(signal => {
          prioritySymbols.add(signal.symbol);
        });

        // 2. æ·»åŠ å¸‚åœºçƒ­åº¦æ¿å—çš„äº¤æ˜“å¯¹ï¼ˆ3ä¸ªå­æ¿å—ï¼Œæ¯ä¸ªTop 10ï¼Œå…±æœ€å¤š30ä¸ªï¼Œå»é‡ï¼‰

        // 2.1 æ·»åŠ çƒ­é—¨æœç´¢Top 10ï¼ˆä»localStorageåŠ è½½ï¼‰
        const marketData = loadMarketData();
        const trendingCoins = marketData.trendingCoins || [];
        if (trendingCoins && trendingCoins.length > 0) {
          trendingCoins.forEach(item => {
            const symbol = item.symbol || (item.item && item.item.symbol);
            if (symbol) {
              prioritySymbols.add(symbol + 'USDT');
            }
          });
        }

        // 2.2 æ·»åŠ æ¶¨å¹…æ¦œTop 10
        if (binancePrices && binancePrices.length > 0) {
          const topGainers = binancePrices
            .sort((a, b) => b.priceChangePercent - a.priceChangePercent)
            .slice(0, 10);
          topGainers.forEach(p => prioritySymbols.add(p.symbol));
        }

        // 2.3 æ·»åŠ æˆäº¤é‡æ¦œTop 10
        if (binancePrices && binancePrices.length > 0) {
          const topVolume = binancePrices
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, 10);
          topVolume.forEach(p => prioritySymbols.add(p.symbol));
        }

        if (prioritySymbols.size === 0) {
          addLog('info', 'æš‚æ— éœ€è¦ä¼˜å…ˆåŠ è½½çš„äº¤æ˜“å¯¹');
          return;
        }

        const trendingCount = trendingCoins ? trendingCoins.length : 0;
        addLog('success', `å‘ç° ${prioritySymbols.size} ä¸ªéœ€åŠ è½½çš„äº¤æ˜“å¯¹ï¼ˆä¿¡å·ç›‘æ§: ${anomalySignals.length}ä¸ªï¼Œå¸‚åœºçƒ­åº¦æ¿å—: ${trendingCount}ä¸ªçƒ­é—¨ + 10ä¸ªæ¶¨å¹… + 10ä¸ªæˆäº¤é‡ï¼Œå·²å»é‡ï¼‰`);

        // å¹¶å‘è·å–è¿™äº›äº¤æ˜“å¯¹çš„è¯¦æƒ…æ•°æ®
        const batchSize = 10; // æ¯æ‰¹10ä¸ªå¹¶å‘
        const symbolsArray = Array.from(prioritySymbols);
        let totalCached = 0;
        let totalFailed = 0;

        for (let i = 0; i < symbolsArray.length; i += batchSize) {
          const batch = symbolsArray.slice(i, i + batchSize);
          addLog('info', `æ­£åœ¨åŠ è½½ç¬¬ ${Math.floor(i / batchSize) + 1} æ‰¹ä¼˜å…ˆäº¤æ˜“å¯¹ (${batch.length}ä¸ª)...`);

          const batchPromises = batch.map(async (symbol) => {
            // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å·²è¿‡æœŸï¼ˆ5åˆ†é’Ÿï¼‰
            if (cacheManager.isValid(symbol)) {
              return { symbol, cached: true };
            }

            // è·å–äº¤æ˜“å¯¹çš„è¯¦æƒ…æ•°æ®ï¼ˆä¸å†è·å–å¸‚å€¼æ•°æ®ï¼‰
            try {
              const [fundingRateData, openInterestData] = await Promise.all([
                fetchBinanceFundingRate(symbol).catch(() => null),
                fetchOpenInterestWithFallback(symbol).catch(() => null)
              ]);

              if (fundingRateData || openInterestData) {
                // åˆ¤æ–­æ˜¯å¦ä¸ºé«˜ä¼˜å…ˆçº§ï¼ˆå¼‚åŠ¨ä¿¡å·ä¸­çš„å¸ç§ï¼‰
                const isHighPriority = highPrioritySymbols.has(symbol);
                
                // ä½¿ç”¨ç¼“å­˜ç®¡ç†å™¨ä¿å­˜
                cacheManager.set(symbol, {
                  coinGecko: null, // ä¸å†è·å–å¸‚å€¼æ•°æ®
                  volume: null,
                  fundingRate: fundingRateData,
                  openInterest: openInterestData,
                  timestamp: Date.now()
                }, isHighPriority ? 'high' : 'normal');
                
                return { symbol, cached: false };
              }
              return { symbol, failed: true };
            } catch (error) {
              return { symbol, failed: true };
            }
          });

          const results = await Promise.all(batchPromises);

          results.forEach(result => {
            if (result.cached) {
              totalCached++;
            } else if (result.failed) {
              totalFailed++;
            }
          });

          // æ‰¹æ¬¡é—´å»¶è¿Ÿ100msï¼Œé¿å…APIé™æµ
          if (i + batchSize < symbolsArray.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }

        addLog('success', `âœ… ä¼˜å…ˆåŠ è½½å®Œæˆï¼šæ–°å¢${symbolsArray.length - totalCached - totalFailed}ä¸ªï¼Œå¤ç”¨ç¼“å­˜${totalCached}ä¸ªï¼Œå¤±è´¥${totalFailed}ä¸ªï¼ˆæ€»è®¡ï¼š${anomalySignals.length}ä¸ªå¼‚åŠ¨ä¿¡å· + æœ€å¤š30ä¸ªå¸‚åœºçƒ­åº¦æ¿å—äº¤æ˜“å¯¹ï¼Œå·²å»é‡ï¼‰`);

        // æ›´æ–°å¼‚åŠ¨ä¿¡å·è§†å›¾ï¼ˆæ˜¾ç¤ºè¯¦æƒ…æ•°æ®ï¼‰
        updateAnomalyView();

      } catch (error) {
        addLog('error', 'ä¼˜å…ˆåŠ è½½äº¤æ˜“å¯¹è¯¦æƒ…å¤±è´¥', error.message);
      }
    }

    // è·å–å¼‚åŠ¨ä¿¡å·ï¼ˆå®æ—¶åˆ†æ - ä»…åˆ†æä¼˜å…ˆäº¤æ˜“å¯¹ï¼‰
    async function fetchAnomalySignals() {
      try {
        updateAnomalyStatus('analyzing');
        addLog('info', 'å¼€å§‹åˆ†æå¸‚åœºå¼‚åŠ¨...');

        // æ”¶é›†ä¼˜å…ˆäº¤æ˜“å¯¹åˆ—è¡¨ï¼ˆå¼‚åŠ¨ä¿¡å· + å¸‚åœºçƒ­åº¦æ¿å—ï¼‰
        const prioritySymbols = new Set();

        // 1. æ·»åŠ ç°æœ‰å¼‚åŠ¨ä¿¡å·ä¸­çš„äº¤æ˜“å¯¹
        anomalySignals.forEach(signal => {
          prioritySymbols.add(signal.symbol);
        });

        // 2. æ·»åŠ å¸‚åœºçƒ­åº¦æ¿å—çš„äº¤æ˜“å¯¹
        const marketData = loadMarketData();
        
        // 2.1 çƒ­é—¨æœç´¢Top 10
        const trendingCoins = marketData.trendingCoins || [];
        if (trendingCoins && trendingCoins.length > 0) {
          trendingCoins.forEach(item => {
            const symbol = item.symbol || (item.item && item.item.symbol);
            if (symbol) {
              prioritySymbols.add(symbol + 'USDT');
            }
          });
        }

        // 2.2 æ¶¨å¹…æ¦œTop 10
        if (binancePrices && binancePrices.length > 0) {
          const topGainers = binancePrices
            .sort((a, b) => b.priceChangePercent - a.priceChangePercent)
            .slice(0, 10);
          topGainers.forEach(p => prioritySymbols.add(p.symbol));
        }

        // 2.3 æˆäº¤é‡æ¦œTop 10
        if (binancePrices && binancePrices.length > 0) {
          const topVolume = binancePrices
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, 10);
          topVolume.forEach(p => prioritySymbols.add(p.symbol));
        }

        addLog('info', `ä¼˜å…ˆäº¤æ˜“å¯¹åˆ—è¡¨å·²æ”¶é›†ï¼š${prioritySymbols.size} ä¸ªï¼ˆå¼‚åŠ¨ä¿¡å· + å¸‚åœºçƒ­åº¦æ¿å—ï¼‰`);

        // åŸºäºå®æ—¶è¡Œæƒ…æ•°æ®è¿›è¡Œåˆ†æï¼ˆä»…åˆ†æä¼˜å…ˆäº¤æ˜“å¯¹ï¼‰
        const newSignals = await analyzeAnomalies(binancePrices, prioritySymbols);

        // åˆå¹¶æ–°ä¿¡å·åˆ°ç°æœ‰ä¿¡å·ä¸­ï¼ˆå»é‡ï¼šç›¸åŒäº¤æ˜“å¯¹ç´¯åŠ æ¬¡æ•°ï¼‰
        const signalMap = new Map();

        // å…ˆæ·»åŠ æ—§ä¿¡å·
        anomalySignals.forEach(signal => {
          signalMap.set(signal.symbol, signal);
        });

        // å†æ·»åŠ æ–°ä¿¡å·ï¼ˆç›¸åŒäº¤æ˜“å¯¹ç´¯åŠ æ¬¡æ•°ï¼Œä½†5åˆ†é’Ÿå†…ä¸é‡å¤ï¼‰
        newSignals.forEach(signal => {
          const existing = signalMap.get(signal.symbol);

          // æ ‡è®°ä¸ºé«˜ä¼˜å…ˆçº§å¸ç§
          highPrioritySymbols.add(signal.symbol);

          if (existing) {
            // æ£€æŸ¥è·ç¦»ä¸Šæ¬¡å¼‚åŠ¨æ˜¯å¦è¶…è¿‡5åˆ†é’Ÿ
            const existingTime = new Date(existing.timestamp).getTime();
            const newTime = new Date(signal.timestamp).getTime();
            const timeDiff = newTime - existingTime;

            if (timeDiff >= 300000) { // 5åˆ†é’Ÿ = 300000æ¯«ç§’
              // è¶…è¿‡5åˆ†é’Ÿï¼Œç´¯åŠ æ¬¡æ•°
              existing.count = (existing.count || 1) + 1;
            }

            // å§‹ç»ˆæ›´æ–°å…¶ä»–æ•°æ®
            existing.price = signal.price;
            existing.change24h = signal.change24h;
            existing.volume = signal.volume;
            existing.timestamp = signal.timestamp;
            existing.direction = signal.direction;
            existing.signalType = signal.signalType; // æ›´æ–°ä¿¡å·ç±»å‹
            existing.signalSide = signal.signalSide; // æ›´æ–°å¤šç©ºæ–¹å‘
            existing.signalStrength = signal.signalStrength; // æ›´æ–°ä¿¡å·å¼ºåº¦
            existing.priceChange = signal.priceChange; // æ›´æ–°ä»·æ ¼å˜åŒ–
            existing.breakthrough = signal.breakthrough; // æ›´æ–°çªç ´æè¿°
            // ä¿ç•™æ—§çš„strategyå­—æ®µä»¥å…¼å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
            if (signal.strategy) {
              existing.strategy = signal.strategy;
            }
          } else {
            // æ–°ä¿¡å·ï¼Œåˆå§‹åŒ–æ¬¡æ•°ä¸º1
            signal.count = 1;
            signalMap.set(signal.symbol, signal);
          }
        });

        // è½¬æ¢å›æ•°ç»„
        anomalySignals = Array.from(signalMap.values());

        addLog('success', `å¼‚åŠ¨åˆ†æå®Œæˆï¼Œå‘ç° ${newSignals.length} ä¸ªæ–°å¼‚åŠ¨ä¿¡å·ï¼Œæ€»è®¡ ${anomalySignals.length} ä¸ª`);

        // è‡ªåŠ¨è·å–å¹¶ç¼“å­˜æ–°å¼‚åŠ¨ä¿¡å·çš„å¸ç§è¯¦æƒ…æ•°æ®ï¼ˆä¸å†è·å–å¸‚å€¼æ•°æ®ï¼‰
        if (newSignals.length > 0) {
          addLog('info', 'å¼€å§‹è·å– ' + newSignals.length + ' ä¸ªæ–°å¼‚åŠ¨ä¿¡å·çš„å¸ç§è¯¦æƒ…æ•°æ®...');
          const cachePromises = newSignals.map(async (signal) => {
            const symbol = signal.symbol;
            // æ£€æŸ¥æ˜¯å¦å·²ç¼“å­˜ï¼ˆä½¿ç”¨ cacheManagerï¼‰
            if (!cacheManager.isValid(symbol)) {
              addLog('info', 'è·å– ' + symbol + ' å¸ç§è¯¦æƒ…...');
              const [fundingRateData, openInterestData] = await Promise.all([
                fetchBinanceFundingRate(symbol).catch(() => null),
                fetchOpenInterestWithFallback(symbol).catch(() => null)
              ]);
              if (fundingRateData || openInterestData) {
                // æ ‡è®°ä¸ºé«˜ä¼˜å…ˆçº§å¸ç§
                highPrioritySymbols.add(symbol);
                
                // ä½¿ç”¨ç¼“å­˜ç®¡ç†å™¨ä¿å­˜
                cacheManager.set(symbol, {
                  coinGecko: null, // ä¸å†è·å–å¸‚å€¼æ•°æ®
                  volume: null,
                  fundingRate: fundingRateData,
                  openInterest: openInterestData,
                  timestamp: Date.now()
                }, 'high');
              }
            }
          });
          await Promise.all(cachePromises);
          addLog('success', 'æ–°å¼‚åŠ¨ä¿¡å·å¸ç§è¯¦æƒ…æ•°æ®è·å–å®Œæˆï¼ˆé«˜ä¼˜å…ˆçº§ç¼“å­˜ï¼‰');
        }

        updateAnomalyView();
        saveAnomalySignals();

        // æ›´æ–°é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹é›†åˆ
        updateImportantSymbols();

      } catch (error) {
        addLog('error', 'å¼‚åŠ¨åˆ†æå¤±è´¥', error.message);
        console.error('âŒ [å¼‚åŠ¨åˆ†æ] å¤±è´¥:', error);
      } finally {
        updateAnomalyStatus('idle');
      }
    }

    // å¼‚åŠ¨ä¿¡å·åˆ†æç®—æ³•ï¼ˆä»…åˆ†æä¼˜å…ˆäº¤æ˜“å¯¹ï¼šå¼‚åŠ¨ä¿¡å· + å¸‚åœºçƒ­åº¦æ¿å—ï¼‰
    async function analyzeAnomalies(prices, prioritySymbols = new Set()) {
      const signals = [];
      let scanned = 0;
      let analyzed = 0;

      addLog('info', `å¼€å§‹åˆ†æ ${prices.length} ä¸ªäº¤æ˜“å¯¹ï¼ˆä¼˜å…ˆäº¤æ˜“å¯¹: ${prioritySymbols.size}ä¸ªï¼‰...`);

      for (const item of prices) {
        // åªåˆ†æä¼˜å…ˆäº¤æ˜“å¯¹ï¼ˆå¼‚åŠ¨ä¿¡å·ä¸­çš„å¸ç§ + å¸‚åœºçƒ­åº¦æ¿å—ä¸­çš„å¸ç§ï¼‰
        if (!prioritySymbols.has(item.symbol)) {
          continue;
        }

        scanned++;
        const price = parseFloat(item.price);
        const change24h = parseFloat(item.priceChangePercent);
        const volume = parseFloat(item.quoteVolume);
        const volumeInM = volume / 1000000;

        analyzed++;

        // å‡å°‘æ—¥å¿—è¾“å‡ºï¼Œæå‡æ€§èƒ½ï¼ˆæ¯10ä¸ªäº¤æ˜“å¯¹è¾“å‡ºä¸€æ¬¡ï¼‰
        if (analyzed % 10 === 0) {
          addLog('info', `å·²åˆ†æ ${analyzed}/${scanned} ä¸ªäº¤æ˜“å¯¹...`);
        }

        // è·å–50æ ¹Kçº¿æ•°æ®ï¼ˆä½¿ç”¨5åˆ†é’ŸKçº¿ï¼‰ï¼Œæ·»åŠ è¶…æ—¶æ§åˆ¶
        let klineData;
        try {
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 3000)
          );
          klineData = await Promise.race([
            fetchKlineData(item.symbol, '5m'),
            timeoutPromise
          ]);
        } catch (error) {
          addLog('warning', `è·å– ${item.symbol} Kçº¿æ•°æ®è¶…æ—¶ï¼Œè·³è¿‡`);
          continue;
        }

        if (!klineData) {
          continue;
        }

        // åŸºäºå æ¯”é˜ˆå€¼çš„ä¿¡å·ç±»å‹åˆ¤æ–­
        let signalType = null;
        let signalSide = null;
        let signalStrength = 1;
        let hasAnomaly = false;
        let breakthrough = '';

        const currentPrice = price;
        const volumeSpike = klineData.volumeSpike || 1;
        const waveLevelName = klineData.waveLevelName || 'æœªçŸ¥';
        const waveVolumeSum = klineData.waveVolumeSum || 0;
        const waveStartPrice = klineData.waveStartPrice || currentPrice;
        const waveDirection = klineData.waveDirection || 'unknown';
        const recent5VolumeSum = klineData.recent5VolumeSum || 0;

        // è®¡ç®—æ”¾é‡å æ¯”ï¼ˆæœ€è¿‘5æ ¹Kçº¿æˆäº¤é‡ / æ³¢æµªæ€»æˆäº¤é‡ï¼‰
        const volumeRatio = (recent5VolumeSum / waveVolumeSum) * 100; // æ”¾é‡å æ¯”ï¼ˆç™¾åˆ†æ¯”ï¼‰
        let priceChange = 0; // ä»·æ ¼å˜åŒ–ï¼ˆçªç ´å¹…åº¦ï¼‰

        // åˆ¤æ–­æ˜¯å¦çªç ´é«˜ç‚¹2%ï¼ˆç¬¬49æ ¹æˆ–ç¬¬50æ ¹ï¼‰
        if (klineData.k49High > klineData.maxHigh48 * 1.02 || klineData.k50High > klineData.maxHigh48 * 1.02) {
          // å‘ä¸Šçªç ´
          hasAnomaly = true;
          const whichKline = klineData.k49High > klineData.maxHigh48 * 1.02 ? 'ç¬¬49æ ¹' : 'ç¬¬50æ ¹';
          const breakthroughValue = klineData.k49High > klineData.maxHigh48 * 1.02
            ? ((klineData.k49High / klineData.maxHigh48 - 1) * 100).toFixed(2)
            : ((klineData.k50High / klineData.maxHigh48 - 1) * 100).toFixed(2);
          priceChange = parseFloat(breakthroughValue); // è®°å½•çªç ´å¹…åº¦
          
          // æ ¹æ®æ”¾é‡å æ¯”åˆ¤æ–­ä¿¡å·ç±»å‹
          if (volumeRatio > 100) {
            signalType = 'ğŸš€ è¶…é¢„æœŸæ‹‰ç›˜';
            signalSide = 'å¤šå¤´';
            signalStrength = 5;
          } else if (volumeRatio > 80) {
            signalType = 'ğŸš€ å¼ºæ‹‰ç›˜';
            signalSide = 'å¤šå¤´';
            signalStrength = 4;
          } else if (volumeRatio > 50) {
            signalType = 'ğŸ“ˆ æ‹‰ç›˜';
            signalSide = 'å¤šå¤´';
            signalStrength = 3;
          } else if (volumeRatio > 20) {
            signalType = 'âš ï¸ å¯èƒ½å‡æ‹‰ç›˜';
            signalSide = 'å¤šå¤´';
            signalStrength = 2;
          } else {
            signalType = 'âŒ å‡æ‹‰ç›˜';
            signalSide = 'å¤šå¤´';
            signalStrength = 1;
          }
          breakthrough = `${whichKline}çªç ´å‰48æ ¹Kçº¿é«˜ç‚¹ ${klineData.maxHigh48.toFixed(4)} (+${breakthroughValue}%)`;
        }
        // åˆ¤æ–­æ˜¯å¦è·Œç ´ä½ç‚¹2%ï¼ˆç¬¬49æ ¹æˆ–ç¬¬50æ ¹ï¼‰
        else if (klineData.k49Low < klineData.minLow48 * 0.98 || klineData.k50Low < klineData.minLow48 * 0.98) {
          // å‘ä¸‹çªç ´
          hasAnomaly = true;
          const whichKline = klineData.k49Low < klineData.minLow48 * 0.98 ? 'ç¬¬49æ ¹' : 'ç¬¬50æ ¹';
          const breakthroughValue = klineData.k49Low < klineData.minLow48 * 0.98
            ? ((klineData.k49Low / klineData.minLow48 - 1) * 100).toFixed(2)
            : ((klineData.k50Low / klineData.minLow48 - 1) * 100).toFixed(2);
          priceChange = parseFloat(breakthroughValue); // è®°å½•çªç ´å¹…åº¦
          
          // æ ¹æ®æ”¾é‡å æ¯”åˆ¤æ–­ä¿¡å·ç±»å‹
          if (volumeRatio > 100) {
            signalType = 'ğŸ’¥ è¶…é¢„æœŸä¸‹è·Œ';
            signalSide = 'ç©ºå¤´';
            signalStrength = 5;
          } else if (volumeRatio > 80) {
            signalType = 'âš ï¸ æ´—ç›˜';
            signalSide = 'ç©ºå¤´';
            signalStrength = 4;
          } else if (volumeRatio > 50) {
            signalType = 'ğŸ”» ä¸‹è·Œ';
            signalSide = 'ç©ºå¤´';
            signalStrength = 3;
          } else if (volumeRatio > 20) {
            signalType = 'âš ï¸ å¯èƒ½å‡ç ¸ç›˜';
            signalSide = 'ç©ºå¤´';
            signalStrength = 2;
          } else {
            signalType = 'âŒ å‡ç ¸ç›˜';
            signalSide = 'ç©ºå¤´';
            signalStrength = 1;
          }
          breakthrough = `${whichKline}è·Œç ´å‰48æ ¹Kçº¿ä½ç‚¹ ${klineData.minLow48.toFixed(4)} (${breakthroughValue}%)`;
        }

        // åªä¿ç•™æœ‰å¼‚åŠ¨çš„ä¿¡å·
        if (hasAnomaly) {
          addLog('warning', `å‘ç°ä¿¡å·: ${item.symbol}`, `${signalType} | ${breakthrough}`);

          signals.push({
            symbol: item.symbol,
            price: price,
            change24h: change24h,
            volume: volumeInM,
            direction: signalSide === 'å¤šå¤´' ? 'up' : (signalSide === 'ç©ºå¤´' ? 'down' : 'neutral'),
            breakthrough: breakthrough,
            volumeSpike: volumeSpike.toFixed(1) + 'x',
            signalType: signalType,
            signalSide: signalSide,
            signalStrength: signalStrength,
            priceChange: priceChange.toFixed(2) + '%', // ä½¿ç”¨çªç ´å¹…åº¦
            // æ–°å¢æ³¢æµªçº§åˆ«ä¿¡æ¯
            waveLevel: klineData.waveLevel,
            waveLevelName: klineData.waveLevelName,
            waveVolumeSum: klineData.waveVolumeSum,
            volumeThreshold: klineData.volumeThreshold,
            timestamp: new Date().toISOString()
          });
        }
      }

      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      const scannedCountEl = document.getElementById('scannedCount');
      const analyzedCountEl = document.getElementById('analyzedCount');
      const totalSignalsEl = document.getElementById('totalSignals');

      // ç»Ÿè®¡ä¿¡å·ç±»å‹ï¼ˆåŸºäºå æ¯”é˜ˆå€¼ + çªç ´2%ï¼‰
      const signalTypeCounts = {
        'ğŸš€ è¶…é¢„æœŸæ‹‰ç›˜': 0,
        'ğŸš€ å¼ºæ‹‰ç›˜': 0,
        'ğŸ“ˆ æ‹‰ç›˜': 0,
        'âš ï¸ å¯èƒ½å‡æ‹‰ç›˜': 0,
        'âŒ å‡æ‹‰ç›˜': 0,
        'âš ï¸ å‡ºè´§': 0,
        'ğŸ’¥ è¶…é¢„æœŸä¸‹è·Œ': 0,
        'âš ï¸ æ´—ç›˜': 0,
        'ğŸ”» ä¸‹è·Œ': 0,
        'âš ï¸ å¯èƒ½å‡ç ¸ç›˜': 0,
        'âŒ å‡ç ¸ç›˜': 0
      };

      signals.forEach(signal => {
        if (signalTypeCounts.hasOwnProperty(signal.signalType)) {
          signalTypeCounts[signal.signalType]++;
        }
      });

      // æ›´æ–°æ—§ç»Ÿè®¡ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
      const mainUpCount = signalTypeCounts['ğŸš€ æ‹‰ç›˜'] + signalTypeCounts['ğŸ“ˆ ä¸Šæ¶¨'];
      const mainDownCount = signalTypeCounts['ğŸ’¥ ç ¸ç›˜'] + signalTypeCounts['ğŸ”» ä¸‹è·Œ'];
      const fundUpCount = signalTypeCounts['ğŸš€ æ‹‰ç›˜'];
      const fundDownCount = signalTypeCounts['ğŸ’¥ ç ¸ç›˜'];

      if (scannedCountEl) scannedCountEl.textContent = scanned;
      if (analyzedCountEl) analyzedCountEl.textContent = analyzed;
      if (totalSignalsEl) totalSignalsEl.textContent = signals.length;

      // æ›´æ–°æ—§ç»Ÿè®¡å…ƒç´ ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      const mainUpCountEl = document.getElementById('mainUpCount');
      const mainDownCountEl = document.getElementById('mainDownCount');
      const fundUpCountEl = document.getElementById('fundUpCount');
      const fundDownCountEl = document.getElementById('fundDownCount');
      if (mainUpCountEl) mainUpCountEl.textContent = mainUpCount;
      if (mainDownCountEl) mainDownCountEl.textContent = mainDownCount;
      if (fundUpCountEl) fundUpCountEl.textContent = fundUpCount;
      if (fundDownCountEl) fundDownCountEl.textContent = fundDownCount;

      const analysisStats = document.getElementById('analysisStats');
      if (analysisStats) {
        analysisStats.classList.remove('hidden');
      }

      return signals;
    }

    // è·å–åŸå§‹Kçº¿æ•°æ®ï¼ˆç”¨äºå›¾è¡¨æ¸²æŸ“ï¼Œè¿”å›å®Œæ•´Kçº¿æ•°æ®æ•°ç»„ï¼‰
    async function fetchRawKlineData(symbol, interval) {
      const cacheKey = `${symbol}_${interval}`;
      const now = Date.now();
      const klineWindowSize = 51; // æ»‘åŠ¨çª—å£å¤§å°

      try {
        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
        if (klineCache.has(cacheKey)) {
          const cached = klineCache.get(cacheKey);

          // æ£€æŸ¥æœ€æ–°Kçº¿æ˜¯å¦å·²è¿‡æœŸï¼ˆè¶…è¿‡ä¸€ä¸ªKçº¿å‘¨æœŸï¼‰
          const latestKlineTime = cached.data[cached.data.length - 1][0];
          const nextKlineTime = latestKlineTime + (interval === '5m' ? 5 * 60 * 1000 : 60 * 1000);

          if (now < nextKlineTime) {
            // æœ€æ–°Kçº¿è¿˜æœªè¿‡æœŸï¼Œç›´æ¥è¿”å›ç¼“å­˜æ•°æ®
            return cached.data.map(k => ({
              time: parseInt(k[0]),
              open: parseFloat(k[1]),
              high: parseFloat(k[2]),
              low: parseFloat(k[3]),
              close: parseFloat(k[4]),
              volume: parseFloat(k[5])
            }));
          }

          // å¢é‡æ›´æ–°ï¼šè·å–1æ ¹æœ€æ–°Kçº¿
          try {
            let apiUrl;
            if (currentApiProvider === 'okx') {
              const instId = symbol.replace('USDT', '-USDT');
              apiUrl = `https://www.okx.com/api/v5/market/candles?instId=${instId}&bar=${interval}&limit=1`;
            } else if (currentApiProvider === 'binance') {
              apiUrl = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=1`;
            } else if (currentApiProvider === 'bybit') {
              apiUrl = `https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=${interval}&limit=1`;
            }

            const response = await fetch(apiUrl, { method: 'GET' });

            if (!response.ok) {
              return null;
            }

            let newData;
            if (currentApiProvider === 'okx') {
              const json = await response.json();
              newData = json.data;
            } else if (currentApiProvider === 'bybit') {
              const json = await response.json();
              newData = json.result.list;
            } else {
              newData = await response.json();
            }

            if (newData && newData.length > 0) {
              // OKXå’ŒBybitè¿”å›çš„æ˜¯å€’åºï¼Œéœ€è¦è½¬æ¢
              let newKline;
              if (currentApiProvider === 'okx' || currentApiProvider === 'bybit') {
                newKline = [
                  parseInt(newData[0][0]),
                  parseFloat(newData[0][1]),
                  parseFloat(newData[0][2]),
                  parseFloat(newData[0][3]),
                  parseFloat(newData[0][4]),
                  parseFloat(newData[0][5])
                ];
              } else {
                newKline = newData[0];
              }

              const newKlineTime = newKline[0];
              const lastCachedTime = cached.data[cached.data.length - 1][0];

              // æ£€æŸ¥æ–°Kçº¿æ˜¯å¦ä¸ç¼“å­˜æœ€åä¸€æ¡é‡å¤
              if (newKlineTime === lastCachedTime) {
                cached.data[cached.data.length - 1] = newKline;
              } else if (newKlineTime > lastCachedTime) {
                cached.data.push(newKline);
                if (cached.data.length > klineWindowSize) {
                  cached.data.shift();
                }
              } else {
                console.warn(`Kçº¿æ—¶é—´æˆ³å¼‚å¸¸: ${symbol}, é‡æ–°åˆå§‹åŒ–`);
                return await initializeRawKlineCache(symbol, interval);
              }

              cached.timestamp = now;

              return cached.data.map(k => ({
                time: parseInt(k[0]),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
              }));
            }
          } catch (error) {
            console.error(`å¢é‡æ›´æ–°Kçº¿å¤±è´¥: ${symbol}`, error);
            return cached.data.map(k => ({
              time: parseInt(k[0]),
              open: parseFloat(k[1]),
              high: parseFloat(k[2]),
              low: parseFloat(k[3]),
              close: parseFloat(k[4]),
              volume: parseFloat(k[5])
            }));
          }
        }

        // ç¼“å­˜ä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–è·å–51æ ¹Kçº¿
        return await initializeRawKlineCache(symbol, interval);

      } catch (error) {
        console.error(`è·å–Kçº¿æ•°æ®å¤±è´¥: ${symbol}`, error);
        return null;
      }
    }

    // åˆå§‹åŒ–åŸå§‹Kçº¿ç¼“å­˜ï¼ˆè·å–51æ ¹Kçº¿ï¼‰
    async function initializeRawKlineCache(symbol, interval) {
      const cacheKey = `${symbol}_${interval}`;
      const now = Date.now();

      try {
        let apiUrl;
        if (currentApiProvider === 'okx') {
          const instId = symbol.replace('USDT', '-USDT');
          apiUrl = `https://www.okx.com/api/v5/market/candles?instId=${instId}&bar=${interval}&limit=51`;
        } else if (currentApiProvider === 'binance') {
          apiUrl = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=51`;
        } else if (currentApiProvider === 'bybit') {
          apiUrl = `https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=${interval}&limit=51`;
        }

        const response = await fetch(apiUrl, { method: 'GET' });

        if (!response.ok) {
          return null;
        }

        let data;
        if (currentApiProvider === 'okx') {
          const json = await response.json();
          data = json.data;
          // æ£€æŸ¥æ•°æ®æ˜¯å¦å­˜åœ¨
          if (!data || !Array.isArray(data) || data.length === 0) {
            addLog('warning', `${symbol} OKXç°è´§æ•°æ®ä¸ºç©º`);
            return null;
          }
          data = data.reverse().map(k => [
            parseInt(k[0]),
            parseFloat(k[1]),
            parseFloat(k[2]),
            parseFloat(k[3]),
            parseFloat(k[4]),
            parseFloat(k[5])
          ]);
        } else if (currentApiProvider === 'bybit') {
          const json = await response.json();
          data = json.result?.list;
          // æ£€æŸ¥æ•°æ®æ˜¯å¦å­˜åœ¨
          if (!data || !Array.isArray(data) || data.length === 0) {
            addLog('warning', `${symbol} Bybitç°è´§æ•°æ®ä¸ºç©º`);
            return null;
          }
          data = data.reverse().map(k => [
            parseInt(k[0]),
            parseFloat(k[1]),
            parseFloat(k[2]),
            parseFloat(k[3]),
            parseFloat(k[4]),
            parseFloat(k[5])
          ]);
        } else {
          data = await response.json();
        }

        if (data && data.length >= 51) {
          klineCache.set(cacheKey, {
            data: data,
            timestamp: now
          });

          if (klineCache.size > 100) {
            const keys = Array.from(klineCache.keys());
            const oldestKey = keys.reduce((oldest, key) => {
              return klineCache.get(key).timestamp < klineCache.get(oldest).timestamp ? key : oldest;
            }, keys[0]);
            klineCache.delete(oldestKey);
          }

          addLog('info', `åˆå§‹åŒ–Kçº¿ç¼“å­˜: ${symbol}, ${data.length}æ ¹Kçº¿`);
          return data.map(k => ({
            time: parseInt(k[0]),
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
          }));
        }

        return null;
      } catch (error) {
        console.error(`åˆå§‹åŒ–Kçº¿ç¼“å­˜å¤±è´¥: ${symbol}`, error);
        return null;
      }
    }

    // è·å–Kçº¿æ•°æ®ï¼ˆå¢é‡æ›´æ–°æ¨¡å¼ï¼Œä¿æŒ51æ ¹æ»‘åŠ¨çª—å£ï¼‰
    async function fetchKlineData(symbol, interval) {
      const cacheKey = `${symbol}_${interval}`;
      const now = Date.now();
      const klineWindowSize = 51; // æ»‘åŠ¨çª—å£å¤§å°

      try {
        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
        if (klineCache.has(cacheKey)) {
          const cached = klineCache.get(cacheKey);

          // æ£€æŸ¥æœ€æ–°Kçº¿æ˜¯å¦å·²è¿‡æœŸï¼ˆè¶…è¿‡ä¸€ä¸ªKçº¿å‘¨æœŸï¼‰
          const latestKlineTime = cached.data[cached.data.length - 1][0];
          const nextKlineTime = latestKlineTime + (interval === '5m' ? 5 * 60 * 1000 : 60 * 1000);

          if (now < nextKlineTime) {
            // æœ€æ–°Kçº¿è¿˜æœªè¿‡æœŸï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜
            return calculateKlineMetrics(cached.data);
          }

          // å¢é‡æ›´æ–°ï¼šè·å–1æ ¹æœ€æ–°Kçº¿
          try {
            let apiUrl;
            if (currentApiProvider === 'okx') {
              // OKX åˆçº¦Kçº¿API (æ°¸ç»­åˆçº¦)
              const instId = symbol.replace('USDT', '-USDT-SWAP');
              apiUrl = `https://www.okx.com/api/v5/market/candles?instId=${instId}&bar=${interval}&limit=1&instType=SWAP`;
            } else if (currentApiProvider === 'binance') {
              // Binance åˆçº¦Kçº¿API (æ°¸ç»­åˆçº¦)
              apiUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=1`;
            } else if (currentApiProvider === 'bybit') {
              // Bybit åˆçº¦Kçº¿API (æ°¸ç»­åˆçº¦ - linear)
              apiUrl = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=1`;
            }

            const response = await fetch(apiUrl, { method: 'GET' });

            if (!response.ok) {
              return null;
            }

            let newData;
            if (currentApiProvider === 'okx') {
              const json = await response.json();
              newData = json.data;
            } else if (currentApiProvider === 'bybit') {
              const json = await response.json();
              newData = json.result.list;
            } else {
              newData = await response.json();
            }

            if (newData && newData.length > 0) {
              // OKXå’ŒBybitè¿”å›çš„æ˜¯å€’åºï¼Œéœ€è¦è½¬æ¢
              let newKline;
              if (currentApiProvider === 'okx' || currentApiProvider === 'bybit') {
                newKline = [
                  parseInt(newData[0][0]), // æ—¶é—´æˆ³
                  parseFloat(newData[0][1]), // å¼€ç›˜ä»·
                  parseFloat(newData[0][2]), // æœ€é«˜ä»·
                  parseFloat(newData[0][3]), // æœ€ä½ä»·
                  parseFloat(newData[0][4]), // æ”¶ç›˜ä»·
                  parseFloat(newData[0][5])  // æˆäº¤é‡
                ];
              } else {
                newKline = newData[0];
              }

              const newKlineTime = newKline[0];
              const lastCachedTime = cached.data[cached.data.length - 1][0];

              // æ£€æŸ¥æ–°Kçº¿æ˜¯å¦ä¸ç¼“å­˜æœ€åä¸€æ¡é‡å¤
              if (newKlineTime === lastCachedTime) {
                // é‡å¤ï¼Œä½¿ç”¨ç¼“å­˜çš„æœ€åä¸€æ¡ï¼ˆæ›´æ–°æœ€æ–°æ•°æ®ï¼‰
                cached.data[cached.data.length - 1] = newKline;
              } else if (newKlineTime > lastCachedTime) {
                // æ–°Kçº¿æ—¶é—´æˆ³æ›´å¤§ï¼Œè¿½åŠ å¹¶åˆ é™¤æœ€è¿œçš„ä¸€æ¡
                cached.data.push(newKline);
                if (cached.data.length > klineWindowSize) {
                  cached.data.shift(); // åˆ é™¤æœ€è¿œçš„ä¸€æ ¹
                }
              } else {
                // æ—¶é—´æˆ³å¼‚å¸¸ï¼Œé‡æ–°åˆå§‹åŒ–
                console.warn(`Kçº¿æ—¶é—´æˆ³å¼‚å¸¸: ${symbol}, é‡æ–°åˆå§‹åŒ–`);
                return await initializeKlineCache(symbol, interval);
              }

              // æ›´æ–°ç¼“å­˜æ—¶é—´æˆ³
              cached.timestamp = now;

              return calculateKlineMetrics(cached.data);
            }
          } catch (error) {
            console.error(`å¢é‡æ›´æ–°Kçº¿å¤±è´¥: ${symbol}`, error);
            // å¢é‡æ›´æ–°å¤±è´¥ï¼Œè¿”å›ç¼“å­˜æ•°æ®
            return calculateKlineMetrics(cached.data);
          }
        }

        // ç¼“å­˜ä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–è·å–51æ ¹Kçº¿
        return await initializeKlineCache(symbol, interval);

      } catch (error) {
        console.error(`è·å–Kçº¿æ•°æ®å¤±è´¥: ${symbol}`, error);
        return null;
      }
    }

    // åˆå§‹åŒ–Kçº¿ç¼“å­˜ï¼ˆè·å–51æ ¹Kçº¿ï¼‰
    async function initializeKlineCache(symbol, interval) {
      const cacheKey = `${symbol}_${interval}`;
      const now = Date.now();

      try {
        let apiUrl;
        if (currentApiProvider === 'okx') {
          // OKX åˆçº¦Kçº¿API (æ°¸ç»­åˆçº¦)
          const instId = symbol.replace('USDT', '-USDT-SWAP');
          apiUrl = `https://www.okx.com/api/v5/market/candles?instId=${instId}&bar=${interval}&limit=51&instType=SWAP`;
        } else if (currentApiProvider === 'binance') {
          // Binance åˆçº¦Kçº¿API (æ°¸ç»­åˆçº¦)
          apiUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=51`;
        } else if (currentApiProvider === 'bybit') {
          // Bybit åˆçº¦Kçº¿API (æ°¸ç»­åˆçº¦ - linear)
          apiUrl = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=51`;
        }

        const response = await fetch(apiUrl, { method: 'GET' });

        if (!response.ok) {
          return null;
        }

        let data;
        if (currentApiProvider === 'okx') {
          const json = await response.json();
          data = json.data;
          // æ£€æŸ¥æ•°æ®æ˜¯å¦å­˜åœ¨
          if (!data || !Array.isArray(data) || data.length === 0) {
            addLog('warning', `${symbol} OKXåˆçº¦æ•°æ®ä¸ºç©º`);
            return null;
          }
          // OKXè¿”å›çš„æ˜¯å€’åºï¼Œéœ€è¦è½¬æ¢ä¸ºæ­£åº
          data = data.reverse().map(k => [
            parseInt(k[0]), // æ—¶é—´æˆ³
            parseFloat(k[1]), // å¼€ç›˜ä»·
            parseFloat(k[2]), // æœ€é«˜ä»·
            parseFloat(k[3]), // æœ€ä½ä»·
            parseFloat(k[4]), // æ”¶ç›˜ä»·
            parseFloat(k[5])  // æˆäº¤é‡
          ]);
        } else if (currentApiProvider === 'bybit') {
          const json = await response.json();
          data = json.result?.list;
          // æ£€æŸ¥æ•°æ®æ˜¯å¦å­˜åœ¨
          if (!data || !Array.isArray(data) || data.length === 0) {
            addLog('warning', `${symbol} Bybitåˆçº¦æ•°æ®ä¸ºç©º`);
            return null;
          }
          // Bybitè¿”å›çš„æ˜¯å€’åºï¼Œéœ€è¦è½¬æ¢ä¸ºæ­£åº
          data = data.reverse().map(k => [
            parseInt(k[0]), // æ—¶é—´æˆ³
            parseFloat(k[1]), // å¼€ç›˜ä»·
            parseFloat(k[2]), // æœ€é«˜ä»·
            parseFloat(k[3]), // æœ€ä½ä»·
            parseFloat(k[4]), // æ”¶ç›˜ä»·
            parseFloat(k[5])  // æˆäº¤é‡
          ]);
        } else {
          data = await response.json();
          // Binance æ•°æ®éªŒè¯
          if (!data || !Array.isArray(data) || data.length === 0) {
            addLog('warning', `${symbol} Binanceåˆçº¦æ•°æ®ä¸ºç©º`);
            return null;
          }
        }

        if (data && data.length >= 51) {
          // å­˜å…¥ç¼“å­˜
          klineCache.set(cacheKey, {
            data: data,
            timestamp: now
          });

          // æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆä¿ç•™æœ€è¿‘100ä¸ªäº¤æ˜“å¯¹çš„ç¼“å­˜ï¼‰
          if (klineCache.size > 100) {
            const keys = Array.from(klineCache.keys());
            const oldestKey = keys.reduce((oldest, key) => {
              return klineCache.get(key).timestamp < klineCache.get(oldest).timestamp ? key : oldest;
            }, keys[0]);
            klineCache.delete(oldestKey);
          }

          addLog('info', `åˆå§‹åŒ–Kçº¿ç¼“å­˜: ${symbol}, ${data.length}æ ¹Kçº¿`);
          return calculateKlineMetrics(data);
        }

        return null;
      } catch (error) {
        console.error(`åˆå§‹åŒ–Kçº¿ç¼“å­˜å¤±è´¥: ${symbol}`, error);
        return null;
      }
    }

    // è®¡ç®—Kçº¿æŒ‡æ ‡ï¼ˆä½¿ç”¨51æ ¹æ»‘åŠ¨çª—å£æ•°æ®ï¼šå‰48æ ¹ä½œä¸ºåŸºå‡†ï¼Œåˆ†æç¬¬49å’Œ50æ ¹ï¼‰
    function calculateKlineMetrics(data) {
      // å‰48æ ¹Kçº¿ä½œä¸ºåŸºå‡†
      const kline48Highs = data.slice(0, 48).map(k => parseFloat(k[2]));
      const kline48Lows = data.slice(0, 48).map(k => parseFloat(k[3]));
      const kline48Volumes = data.slice(0, 48).map(k => parseFloat(k[5]));
      const kline48Closes = data.slice(0, 48).map(k => parseFloat(k[4]));

      // è®¡ç®—åŸºå‡†æå€¼å’Œå¹³å‡å€¼
      const maxHigh48 = Math.max(...kline48Highs);
      const minLow48 = Math.min(...kline48Lows);
      const avgVolume48 = kline48Volumes.reduce((sum, vol) => sum + vol, 0) / kline48Volumes.length;
      const avgClose48 = kline48Closes.reduce((sum, close) => sum + close, 0) / kline48Closes.length;

      // ===== æ³¢æµªåˆ†æï¼ˆæ–¹æ¡ˆ2ï¼šå¢åŠ æ³¢æµªæˆäº¤é‡ç»´åº¦ï¼‰=====
      // åœ¨å‰48æ ¹Kçº¿ä¸­æ‰¾ç»å¯¹é«˜ç‚¹å’Œç»å¯¹ä½ç‚¹
      let lowPointIndex = -1;
      let highPointIndex = -1;
      let lowPointValue = Infinity;
      let highPointValue = -Infinity;

      for (let i = 0; i < 48; i++) {
        const high = parseFloat(data[i][2]);
        const low = parseFloat(data[i][3]);

        if (low < lowPointValue) {
          lowPointValue = low;
          lowPointIndex = i;
        }
        if (high > highPointValue) {
          highPointValue = high;
          highPointIndex = i;
        }
      }

      // ç¡®å®šæ³¢æµªæ–¹å‘å’ŒèŒƒå›´
      let waveStartIndex = 0;
      let waveEndIndex = 47;
      let waveDirection = 'unknown';
      let waveStartPrice = 0; // æ³¢æµªèµ·ç‚¹ä»·æ ¼

      if (lowPointIndex < highPointIndex) {
        // ä½ç‚¹åœ¨å‰ï¼Œé«˜ç‚¹åœ¨å â†’ ä¸Šå‡æµª
        waveStartIndex = lowPointIndex;
        waveEndIndex = highPointIndex;
        waveDirection = 'up';
        waveStartPrice = lowPointValue; // ä¸Šå‡æµªèµ·ç‚¹ = ä½ç‚¹
      } else if (highPointIndex < lowPointIndex) {
        // é«˜ç‚¹åœ¨å‰ï¼Œä½ç‚¹åœ¨å â†’ ä¸‹è·Œæµª
        waveStartIndex = highPointIndex;
        waveEndIndex = lowPointIndex;
        waveDirection = 'down';
        waveStartPrice = highPointValue; // ä¸‹è·Œæµªèµ·ç‚¹ = é«˜ç‚¹
      } else {
        // å¼‚å¸¸æƒ…å†µï¼šä½¿ç”¨æ•´ä¸ª48æ ¹Kçº¿
        waveStartIndex = 0;
        waveEndIndex = 47;
        waveDirection = 'unknown';
        waveStartPrice = kline48Closes[0]; // ä½¿ç”¨ç¬¬ä¸€æ ¹Kçº¿çš„æ”¶ç›˜ä»·
      }

      // è®¡ç®—æ³¢æµªæˆäº¤é‡
      const waveKçº¿æ•°é‡ = waveEndIndex - waveStartIndex + 1;
      const waveVolumeSum = kline48Volumes.slice(waveStartIndex, waveEndIndex + 1)
        .reduce((sum, vol) => sum + vol, 0);
      const waveAvgVolume = waveVolumeSum / waveKçº¿æ•°é‡;

      // åˆ¤æ–­æ³¢æµªçº§åˆ«ï¼ˆæ ¹æ®æ³¢æµªæ€»æˆäº¤é‡ï¼‰
      let waveLevel;
      let waveLevelName;

      if (waveVolumeSum >= 1000) {
        waveLevel = 5;
        waveLevelName = 'å·¨é‡';
      } else if (waveVolumeSum >= 100) {
        waveLevel = 4;
        waveLevelName = 'å¤§é‡';
      } else if (waveVolumeSum >= 50) {
        waveLevel = 3;
        waveLevelName = 'ä¸­é‡';
      } else if (waveVolumeSum >= 10) {
        waveLevel = 2;
        waveLevelName = 'å°é‡';
      } else {
        waveLevel = 1;
        waveLevelName = 'å¾®é‡';
      }

      // æ ¹æ®æ³¢æµªçº§åˆ«è®¾ç½®æ”¾é‡é˜ˆå€¼
      const volumeThresholds = {
        5: 1.5,  // å·¨é‡ï¼š1.5å€å°±ç®—æ”¾é‡
        4: 2,    // å¤§é‡ï¼š2å€
        3: 2.5,  // ä¸­é‡ï¼š2.5å€
        2: 5,    // å°é‡ï¼š5å€
        1: 10    // å¾®é‡ï¼š10å€
      };
      const volumeThreshold = volumeThresholds[waveLevel];
      // ===== æ³¢æµªåˆ†æç»“æŸ =====

      // ç¬¬49æ ¹å’Œç¬¬50æ ¹Kçº¿ï¼ˆç¬¬51æ ¹ä½œä¸ºæœ€æ–°æ•°æ®å¤‡ç”¨ï¼‰
      const k49High = parseFloat(data[48][2]);
      const k49Low = parseFloat(data[48][3]);
      const k49Close = parseFloat(data[48][4]);
      const k49Volume = parseFloat(data[48][5]);

      const k50High = parseFloat(data[49][2]);
      const k50Low = parseFloat(data[49][3]);
      const k50Close = parseFloat(data[49][4]);
      const k50Volume = parseFloat(data[49][5]);

      // æ”¾é‡è®¡ç®—ï¼šæœ€è¿‘2æ ¹ï¼ˆ49+50ï¼‰å¹³å‡ vs å‰48æ ¹å¹³å‡
      const recentVolume = (k49Volume + k50Volume) / 2;
      const volumeSpike = recentVolume / avgVolume48;

      // è®¡ç®—æœ€è¿‘5æ ¹Kçº¿çš„æˆäº¤é‡æ€»å’Œï¼ˆç¬¬46-50æ ¹ï¼‰
      const recent5VolumeSum = data.slice(45, 50).reduce((sum, k) => sum + parseFloat(k[5]), 0);

      // è®¡ç®—æœ€è¿‘5æ ¹Kçº¿çš„ä»·æ ¼å˜åŒ–ï¼ˆç›¸å¯¹äºå¹³å‡æ”¶ç›˜ä»·ï¼‰
      const k46Close = parseFloat(data[45][4]);
      const currentClose = k50Close;
      const priceChange = ((currentClose - k46Close) / k46Close) * 100; // ç™¾åˆ†æ¯”

      return {
        maxHigh48,
        minLow48,
        k49High,
        k49Low,
        k50High,
        k50Low,
        k49Close,
        k50Close,
        currentClose,
        volumeSpike,
        recent5VolumeSum,
        priceChange,
        // æ–°å¢æ³¢æµªç›¸å…³å­—æ®µ
        waveDirection,
        waveStartPrice,
        waveStartIndex,
        waveEndIndex,
        waveKçº¿æ•°é‡,
        waveVolumeSum,
        waveAvgVolume,
        waveLevel,
        waveLevelName,
        volumeThreshold
      };
    }

    // è·å–æœ€æ–°å¿«è®¯
    async function fetchNews() {
      try {
        if (!FOLLOWIN_API_KEY) {
          addLog('warning', 'è·³è¿‡æœ€æ–°å¿«è®¯æ¥å£è°ƒç”¨ï¼šæœªé…ç½®API Key', 'è¯·ç‚¹å‡»"APIé…ç½®"æŒ‰é’®é…ç½®Followin API Key');
          return;
        }

        addLog('api', 'æ­£åœ¨è¿æ¥Followinæœ€æ–°å¿«è®¯æ¥å£...');

        const response = await fetchWithRetry(`https://api.followin.io/open/feed/news?apikey=${FOLLOWIN_API_KEY}&lang=zh-Hans&count=10`, {
          method: 'GET'
        }, 2, false);

        if (!response.ok) {
          addLog('error', `æœ€æ–°å¿«è®¯æ¥å£è¿”å› ${response.status} ${response.statusText}`, 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æ­£ç¡®');

          // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
          if (news.length > 0) {
            updateNewsView();
          }
          return;
        }

        const data = await response.json();
        if (data.code === 2000 && data.data?.list) {
          addLog('success', `æœ€æ–°å¿«è®¯æ¥å£è¿æ¥æˆåŠŸï¼Œè·å– ${data.data.list.length} æ¡æ•°æ®`);
          news = data.data.list;
          saveNewsData();
          updateNewsView();  // âœ… æ›´æ–°æ–°é—»è§†å›¾
        } else if (data.code && data.code !== 2000) {
          addLog('error', `APIè¿”å›é”™è¯¯ç : ${data.code}`, data.msg || 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æœ‰æ•ˆ');
        } else {
          addLog('warning', 'æœ€æ–°å¿«è®¯æ¥å£è¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', JSON.stringify(data));
        }
      } catch (error) {
        addLog('error', 'æœ€æ–°å¿«è®¯æ¥å£è¿æ¥å¤±è´¥', error.message);

        // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
        if (news.length > 0) {
          updateNewsView();
        }
        console.error('âŒ [æ–°é—»API] æœ€æ–°å¿«è®¯æ¥å£è¿æ¥å¤±è´¥:', error);
      }
    }

    // è·å–çƒ­é—¨å¿«è®¯
    async function fetchHotNews() {
      try {
        if (!FOLLOWIN_API_KEY) {
          addLog('warning', 'è·³è¿‡çƒ­é—¨å¿«è®¯æ¥å£è°ƒç”¨ï¼šæœªé…ç½®API Key', 'è¯·ç‚¹å‡»"APIé…ç½®"æŒ‰é’®é…ç½®Followin API Key');
          return;
        }

        addLog('api', 'æ­£åœ¨è¿æ¥Followinçƒ­é—¨å¿«è®¯æ¥å£...');

        const response = await fetchWithRetry(`https://api.followin.io/open/feed/list/trending?apikey=${FOLLOWIN_API_KEY}&lang=zh-Hans&type=hot_news&count=10`, {
          method: 'GET'
        }, 2, false);

        if (!response.ok) {
          addLog('error', `çƒ­é—¨å¿«è®¯æ¥å£è¿”å› ${response.status} ${response.statusText}`, 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æ­£ç¡®');

          // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
          if (hotNews.length > 0) {
            updateNewsView();
          }
          return;
        }

        const data = await response.json();
        if (data.code === 2000 && data.data?.list) {
          addLog('success', `çƒ­é—¨å¿«è®¯æ¥å£è¿æ¥æˆåŠŸï¼Œè·å– ${data.data.list.length} æ¡æ•°æ®`);
          hotNews = data.data.list;
          saveNewsData();
          updateNewsView();  // âœ… æ›´æ–°æ–°é—»è§†å›¾
        } else if (data.code && data.code !== 2000) {
          addLog('error', `APIè¿”å›é”™è¯¯ç : ${data.code}`, data.msg || 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æœ‰æ•ˆ');
        } else {
          addLog('warning', 'çƒ­é—¨å¿«è®¯æ¥å£è¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', JSON.stringify(data));
        }
      } catch (error) {
        addLog('error', 'çƒ­é—¨å¿«è®¯æ¥å£è¿æ¥å¤±è´¥', error.message);

        // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
        if (hotNews.length > 0) {
          updateNewsView();
        }
        console.error('âŒ [æ–°é—»API] çƒ­é—¨å¿«è®¯æ¥å£è¿æ¥å¤±è´¥:', error);
      }
    }

    // è·å–KOLè§‚ç‚¹
    async function fetchKolOpinions() {
      try {
        if (!FOLLOWIN_API_KEY) {
          addLog('warning', 'è·³è¿‡KOLè§‚ç‚¹æ¥å£è°ƒç”¨ï¼šæœªé…ç½®API Key', 'è¯·ç‚¹å‡»"APIé…ç½®"æŒ‰é’®é…ç½®Followin API Key');
          return;
        }

        addLog('api', 'æ­£åœ¨è¿æ¥Followin KOLè§‚ç‚¹æ¥å£...');

        // KOLè§‚ç‚¹éœ€è¦æŒ‡å®šsymbolå‚æ•°ï¼Œè¿™é‡Œä½¿ç”¨BTCä½œä¸ºé»˜è®¤å€¼
        const response = await fetchWithRetry(`https://api.followin.io/open/feed/list/tag/opinions?apikey=${FOLLOWIN_API_KEY}&lang=zh-Hans&count=10&symbol=BTC`, {
          method: 'GET'
        }, 2, false);

        if (!response.ok) {
          addLog('error', `KOLè§‚ç‚¹æ¥å£è¿”å› ${response.status} ${response.statusText}`, 'è¯·æ£€æŸ¥API Keyæ˜¯å¦æ­£ç¡®');

          // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
          if (kolOpinions.length > 0) {
            updateNewsView();
          }
          return;
        }

        const data = await response.json();
        if (data.code === 2000 && data.data?.list) {
          addLog('success', `KOLè§‚ç‚¹æ¥å£è¿æ¥æˆåŠŸï¼Œè·å– ${data.data.list.length} æ¡æ•°æ®`);
          kolOpinions = data.data.list;
          saveNewsData();
          updateNewsView();  // âœ… æ›´æ–°æ–°é—»è§†å›¾
        } else if (data.code && data.code !== 2000) {
          addLog('warning', `KOLè§‚ç‚¹æ¥å£è¿”å›é”™è¯¯ç : ${data.code}`, `${data.msg || 'APIæš‚ä¸å¯ç”¨ï¼Œå°è¯•ä½¿ç”¨å…¶ä»–æ ‡ç­¾'}`);
        } else {
          addLog('warning', 'KOLè§‚ç‚¹æ¥å£è¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸', JSON.stringify(data));
        }
      } catch (error) {
        addLog('error', 'KOLè§‚ç‚¹æ¥å£è¿æ¥å¤±è´¥', error.message);

        // é™çº§ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®
        if (kolOpinions.length > 0) {
          updateNewsView();
        }
        console.error('âŒ [æ–°é—»API] KOLè§‚ç‚¹æ¥å£è¿æ¥å¤±è´¥:', error);
      }
    }

    // å•ç‹¬åˆ·æ–°æ–°é—»æ•°æ®ï¼ˆç”¨äºAPI Keyé…ç½®åï¼‰
    async function refreshNewsData() {
      await Promise.all([
        fetchNews(),
        fetchHotNews(),
        fetchKolOpinions()
      ]);
      updateNewsView();
    }

    // ==================== UI æ›´æ–°å‡½æ•° ====================

    function updateAPIStatus(status, message) {
      const indicator = document.getElementById('apiStatusIndicator');
      const text = document.getElementById('apiStatusText');

      if (!indicator || !text) return;

      switch (status) {
        case 'connecting':
          indicator.className = 'w-1.5 h-1.5 rounded-full bg-yellow-400 animate-pulse';
          text.textContent = message || 'APIè¿æ¥ä¸­';
          break;
        case 'success':
          indicator.className = 'w-1.5 h-1.5 rounded-full bg-green-400';
          text.textContent = message || 'APIæ­£å¸¸';
          break;
        case 'error':
          indicator.className = 'w-1.5 h-1.5 rounded-full bg-red-400';
          text.textContent = message || 'APIå¼‚å¸¸';
          break;
        default:
          indicator.className = 'w-1.5 h-1.5 rounded-full bg-slate-400';
          text.textContent = message || 'æœªçŸ¥çŠ¶æ€';
      }
    }

    function updateProgress(current, total) {
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');

      if (!progressBar || !progressFill) return;

      if (total > 0) {
        progressBar.classList.remove('hidden');
        const percentage = Math.round((current / total) * 100);
        progressFill.style.width = `${percentage}%`;
      } else {
        progressBar.classList.add('hidden');
      }
    }

    function hideProgress() {
      const progressBar = document.getElementById('progressBar');
      if (progressBar) {
        progressBar.classList.add('hidden');
      }
    }

    function updateLastUpdateTime() {
      const lastUpdate = document.getElementById('lastUpdate');
      if (lastUpdate) {
        lastUpdate.textContent = 'æœ€åæ›´æ–°: ' + new Date().toLocaleTimeString();
      }
    }

    function updateAnomalyStatus(status) {
      const indicator = document.getElementById('anomalyStatusIndicator');
      const text = document.getElementById('anomalyStatus');

      if (status === 'analyzing') {
        indicator.className = 'w-2 h-2 rounded-full bg-yellow-400 animate-pulse';
        text.textContent = 'åˆ†æä¸­';
        // ä¸éšè—å†…å®¹ï¼Œè®©ç”¨æˆ·ç»§ç»­æŸ¥çœ‹å·²æœ‰ä¿¡å·
        document.getElementById('anomalyLoading').classList.add('hidden');
        document.getElementById('anomalyContent').classList.remove('hidden');
      } else if (status === 'idle') {
        indicator.className = 'w-2 h-2 rounded-full bg-green-400';
        text.textContent = 'å®æ—¶ç›‘æ§';
        document.getElementById('anomalyLastUpdate').textContent = 'æ›´æ–°: ' + new Date().toLocaleTimeString();
      }
    }

    function updateAnomalyView() {
      const loading = document.getElementById('anomalyLoading');
      const empty = document.getElementById('anomalyEmpty');
      const content = document.getElementById('anomalyContent');

      if (!loading || !empty || !content) {
        addLog('warning', 'å¼‚åŠ¨ç›‘æ§é¢æ¿DOMå…ƒç´ æœªå°±ç»ª');
        return;
      }

      loading.classList.add('hidden');

      addLog('info', `æ›´æ–°å¼‚åŠ¨ç›‘æ§è§†å›¾ï¼Œå½“å‰ä¿¡å·æ•°é‡: ${anomalySignals.length}`);

      if (anomalySignals.length === 0) {
        empty.classList.remove('hidden');
        content.classList.add('hidden');
        return;
      }

      empty.classList.add('hidden');
      content.classList.remove('hidden');

      const table = document.getElementById('anomalySignalsTable');
      if (!table) return;

      // æ˜¾ç¤ºæ‰€æœ‰ä¿¡å·ï¼Œé€šè¿‡å›ºå®šé«˜åº¦å’Œæ»šåŠ¨æ¡æ§åˆ¶æ˜¾ç¤ºåŒºåŸŸ
      const filteredSignals = getFilteredAndSortedAnomalySignals();
      table.innerHTML = filteredSignals.map((signal, index) => {
        // ä»å½“å‰çš„ binancePrices ä¸­è·å–æœ€æ–°çš„ä»·æ ¼æ•°æ®ï¼ˆç¡®ä¿æ•°æ®ä¸€è‡´æ€§ï¼‰
        const currentTicker = binancePrices.find(p => p.symbol === signal.symbol);
        const currentPrice = currentTicker ? parseFloat(currentTicker.price) : parseFloat(signal.price);
        const currentVolume = currentTicker ? parseFloat(currentTicker.quoteVolume) : parseFloat(signal.volume);
        const currentChange24h = currentTicker ? parseFloat(currentTicker.priceChangePercent) : parseFloat(signal.change24h);

        // æ£€æŸ¥ç¼“å­˜ä¸­çš„èµ„é‡‘è´¹ç‡å’ŒæŒä»“é‡æ•°æ®ï¼ˆä½¿ç”¨ cacheManagerï¼‰
        const cachedData = cacheManager.get(signal.symbol)?.cache;
        let fundingRateText = '--';
        let fundingRateClass = 'text-slate-600 dark:text-slate-400';
        let openInterestText = '--';

        if (cachedData && cachedData.fundingRate) {
          const ratePercent = cachedData.fundingRate.ratePercent;
          fundingRateText = (ratePercent >= 0 ? '+' : '') + ratePercent.toFixed(4) + '%';
          fundingRateClass = ratePercent >= 0 ? 'text-red-600 dark:text-red-400' : 'text-green-600 dark:text-green-400';
        }

        if (cachedData && cachedData.openInterest) {
          const oiInM = cachedData.openInterest.openInterest / 1000000;
          openInterestText = oiInM.toFixed(2) + 'M';
        } else if (cachedData && cachedData.openInterest === null) {
          openInterestText = 'N/A';
        }

        // è·å–ä¿¡å·ç±»å‹ï¼ˆä¼˜å…ˆä½¿ç”¨æ–°çš„signalTypeï¼Œå…¼å®¹æ—§çš„strategyï¼‰
        const signalType = signal.signalType || getSignalTypeText(signal.strategy);

        // ä½¿ç”¨æ³¢æµªå‘¨æœŸæˆäº¤é‡ï¼ˆå¾€å‰48æ ¹Kçº¿æœ€é«˜ç‚¹åˆ°ä½ç‚¹æˆ–æœ€ä½ç‚¹åˆ°æœ€é«˜ç‚¹çš„æˆäº¤é‡ï¼‰
        const waveVolumeM = signal.waveVolumeSum ? (signal.waveVolumeSum / 1000000) : 0;

        return `
        <tr class="border-b border-slate-200 dark:border-slate-700 hover:bg-slate-100/30 dark:hover:bg-slate-700/30 transition-colors ${index === 0 ? 'bg-yellow-500/10' : ''}">
          <td class="px-2 py-1 font-bold text-slate-900 dark:text-white text-xs cursor-pointer hover:text-cyan-500 dark:hover:text-cyan-400" onclick="showCoinDetail('${signal.symbol}')">
            ${signal.symbol.replace('USDT', '')}
            ${signal.count > 1 ? `<span class="ml-1 px-1.5 py-0.5 bg-yellow-500/20 text-yellow-700 dark:text-yellow-300 rounded-full text-xs font-medium">${signal.count}æ¬¡</span>` : ''}
          </td>
          <td class="px-2 py-1">
            <span class="px-2 py-0.5 rounded-full text-xs font-medium text-white ${getSignalTypeClass(signalType)}">
              ${signalType}
            </span>
          </td>
          <td class="px-2 py-1 text-slate-700 dark:text-slate-300 font-mono text-xs">${signal.volumeSpike}</td>
          <td class="px-2 py-1 text-slate-900 dark:text-white font-mono font-medium text-xs">
            ${currentPrice ? '$' + currentPrice.toFixed(currentPrice < 1 ? 6 : 2) : '--'}
          </td>
          <td class="px-2 py-1 text-slate-700 dark:text-slate-300 font-mono text-xs">${formatNumber(waveVolumeM)}M</td>
          <td class="px-2 py-1">
            <span class="${currentChange24h >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'} font-medium text-xs">
              ${currentChange24h >= 0 ? '+' : ''}${(currentChange24h || 0).toFixed(2)}%
            </span>
          </td>
          <td class="px-2 py-1 font-mono text-xs ${fundingRateClass}">
            ${fundingRateText}
          </td>
          <td class="px-2 py-1 text-slate-700 dark:text-slate-300 font-mono text-xs">
            ${openInterestText}
          </td>
          <td class="px-2 py-1 text-slate-600 dark:text-slate-400 text-xs">${formatTime(signal.timestamp)}</td>
        </tr>
      `}).join('');

      addLog('success', `å·²æ¸²æŸ“å…¨éƒ¨ ${filteredSignals.length} ä¸ªå¼‚åŠ¨ä¿¡å·`);
    }

    function updateNewsView() {
      // æ‰§è¡Œæ–°é—»æ‰¹é‡æ¸…ç†
      cleanupNews();

      const loading = document.getElementById('newsLoading');
      const empty = document.getElementById('newsEmpty');
      const content = document.getElementById('newsContent');

      if (!loading || !empty || !content) {
        addLog('warning', 'æ–°é—»é¢æ¿DOMå…ƒç´ æœªå°±ç»ª');
        return;
      }

      loading.classList.add('hidden');

      if (currentTab === 'hot' && hotNews.length === 0) {
        empty.classList.remove('hidden');
        content.classList.add('hidden');
        return;
      }

      if (currentTab === 'latest' && news.length === 0) {
        empty.classList.remove('hidden');
        content.classList.add('hidden');
        return;
      }

      if (currentTab === 'kol' && kolOpinions.length === 0) {
        empty.classList.remove('hidden');
        content.classList.add('hidden');
        return;
      }

      empty.classList.add('hidden');
      content.classList.remove('hidden');

      // éšè—æ‰€æœ‰å†…å®¹
      const contentHot = document.getElementById('contentHot');
      const contentLatest = document.getElementById('contentLatest');
      const contentKol = document.getElementById('contentKol');

      if (contentHot) contentHot.classList.add('hidden');
      if (contentLatest) contentLatest.classList.add('hidden');
      if (contentKol) contentKol.classList.add('hidden');

      // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå¡ç‰‡HTMLï¼ˆç€‘å¸ƒæµå¸ƒå±€ï¼‰
      const generateCardHTML = (item, index, type) => {
        const colors = {
          hot: { from: 'from-rose-500/10', to: 'to-pink-600/10', border: 'border-rose-500/30', hoverBorder: 'hover:border-rose-500/50', shadow: 'hover:shadow-rose-500/10', bg: 'hover:bg-rose-500/20' },
          latest: { from: 'from-blue-500/10', to: 'to-indigo-600/10', border: 'border-blue-500/30', hoverBorder: 'hover:border-blue-500/50', shadow: 'hover:shadow-blue-500/10', bg: 'hover:bg-blue-500/20' },
          kol: { from: 'from-amber-500/10', to: 'to-yellow-600/10', border: 'border-amber-500/30', hoverBorder: 'hover:border-amber-500/50', shadow: 'hover:shadow-amber-500/10', bg: 'hover:bg-amber-500/20' }
        };
        const c = colors[type];

        let headerHTML = '';
        let detailHTML = '';
        let imageHTML = '';

        // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡
        const hasImage = item.image || item.thumbnail || item.avatar;

        if (type === 'hot') {
          headerHTML = `<div class="w-8 h-8 bg-gradient-to-br from-rose-500 to-pink-600 rounded-lg flex items-center justify-center text-white font-bold shrink-0 text-sm">${index + 1}</div>`;
          detailHTML = `${item.source_name ? `<span class="px-1.5 py-0.5 bg-rose-500/20 text-rose-300 rounded-md font-medium text-xs">${item.source_name}</span>` : ''}`;
        } else if (type === 'latest') {
          headerHTML = item.avatar ? `<img src="${item.avatar}" alt="${item.nickname}" class="w-8 h-8 rounded-full object-cover shrink-0 border border-slate-600" onerror="this.style.display='none'">` : '<div class="w-8 h-8 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-lg flex items-center justify-center text-white text-sm shrink-0">ğŸ“°</div>';
          detailHTML = item.tags && item.tags.length > 0 ? item.tags.slice(0, 2).map(tag => `<span class="px-1.5 py-0.5 bg-blue-500/20 text-blue-300 rounded-md font-medium text-xs">${tag.symbol || tag.name}</span>`).join('') : '';
        } else if (type === 'kol') {
          headerHTML = item.avatar ? `<img src="${item.avatar}" alt="${item.nickname}" class="w-8 h-8 rounded-full object-cover shrink-0 border border-slate-600" onerror="this.style.display='none'">` : '<div class="w-8 h-8 bg-gradient-to-br from-amber-500 to-yellow-600 rounded-lg flex items-center justify-center text-white text-sm shrink-0">ğŸ‘¤</div>';
          detailHTML = `<span class="text-amber-400 font-semibold text-xs">${item.nickname}</span>`;
        }

        // æ·»åŠ å›¾ç‰‡ï¼ˆå¦‚æœæœ‰ï¼‰
        if (hasImage && (item.image || item.thumbnail)) {
          imageHTML = `<img src="${item.image || item.thumbnail}" alt="æ–°é—»å›¾ç‰‡" class="news-card-image" onerror="this.style.display='none'">`;
        }

        // æ ¹æ®æ˜¯å¦æœ‰å›¾ç‰‡è®¾ç½®å¡ç‰‡ç±»å
        const cardClass = hasImage ? 'news-card news-card-with-image' : 'news-card';

        return `
          <div onclick="showNewsDetail(${type === 'hot' ? 'hotNews' : type === 'latest' ? 'news' : 'kolOpinions'}[${index}], '${type}')" class="news-card p-3 bg-gradient-to-br ${c.from} ${c.to} rounded-xl border ${c.border} transition-all ${c.hoverBorder} hover:shadow-lg ${c.shadow} flex flex-col cursor-pointer ${c.bg}">
            ${imageHTML}
            <div class="flex items-start gap-2 mb-2 shrink-0">
              ${headerHTML}
              <div class="flex-1 min-w-0">
                <h3 class="font-semibold text-slate-900 dark:text-white text-sm mb-1 line-clamp-2">${item.title}</h3>
                <div class="flex items-center gap-2 flex-wrap text-xs">
                  <span class="text-slate-600 dark:text-slate-400">${formatPublishTime(item.publish_time)}</span>
                  ${detailHTML}
                </div>
              </div>
            </div>
            <p class="text-xs text-slate-700 dark:text-slate-400 line-clamp-3 flex-1 leading-relaxed">${item.content || ''}</p>
          </div>
        `;
      };

      // æ˜¾ç¤ºå½“å‰å†…å®¹ï¼ˆç€‘å¸ƒæµå¸ƒå±€ï¼‰
      if (currentTab === 'hot' && contentHot) {
        contentHot.classList.remove('hidden');
        contentHot.innerHTML = hotNews.map((item, index) => generateCardHTML(item, index, 'hot')).join('');
      } else if (currentTab === 'latest' && contentLatest) {
        contentLatest.classList.remove('hidden');
        contentLatest.innerHTML = news.map((item, index) => generateCardHTML(item, index, 'latest')).join('');
      } else if (currentTab === 'kol' && contentKol) {
        contentKol.classList.remove('hidden');
        contentKol.innerHTML = kolOpinions.map((item, index) => generateCardHTML(item, index, 'kol')).join('');
      }
    }

    // ==================== ç­›é€‰å’Œæ’åºå‡½æ•° ====================

    function getFilteredAndSortedAnomalySignals() {
      let filtered = [...anomalySignals];

      // æ’åº
      filtered.sort((a, b) => {
        let valueA, valueB;

        switch (anomalySortColumn) {
          case 'symbol':
            valueA = a.symbol;
            valueB = b.symbol;
            break;
          case 'volume':
            valueA = a.volume;
            valueB = b.volume;
            break;
          case 'change':
            valueA = Math.abs(a.change24h);
            valueB = Math.abs(b.change24h);
            break;
          case 'time':
            valueA = new Date(a.timestamp).getTime();
            valueB = new Date(b.timestamp).getTime();
            break;
          default:
            return 0;
        }

        if (anomalySortDirection === 'asc') {
          return valueA > valueB ? 1 : valueA < valueB ? -1 : 0;
        } else {
          return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
        }
      });

      return filtered;
    }

    function sortAnomalySignals(column) {
      if (anomalySortColumn === column) {
        anomalySortDirection = anomalySortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        anomalySortColumn = column;
        anomalySortDirection = 'desc';
      }

      // æ›´æ–°æ’åºæŒ‡ç¤ºå™¨
      document.querySelectorAll('#anomalyContent th span').forEach(span => {
        span.textContent = '';
      });
      const sortSpan = document.getElementById(`sort${column.charAt(0).toUpperCase() + column.slice(1)}`);
      if (sortSpan) {
        sortSpan.textContent = anomalySortDirection === 'asc' ? 'â†‘' : 'â†“';
      }

      updateAnomalyView();
    }

    function switchTab(tab) {
      currentTab = tab;

      // æ›´æ–°æŒ‰é’®æ ·å¼
      ['Hot', 'Latest', 'Kol'].forEach(name => {
        const btn = document.getElementById(`tab${name}`);
        if (name.toLowerCase() === tab) {
          btn.className = 'px-2 py-1 rounded-lg text-xs font-medium transition-all bg-rose-500 text-white';
        } else {
          btn.className = 'px-2 py-1 rounded-lg text-xs font-medium transition-all bg-slate-700 text-slate-300 hover:bg-slate-600';
        }
      });

      updateNewsView();
    }

    // ==================== å·¥å…·å‡½æ•° ====================

    function formatNumber(num) {
      return num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    function formatVolume(volume) {
      if (volume >= 1000) {
        return `${(volume / 1000).toFixed(2)}B`;
      } else if (volume >= 1) {
        return `${volume.toFixed(2)}M`;
      } else {
        return `${(volume * 1000).toFixed(2)}K`;
      }
    }

    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diff = Math.floor((now - date) / 1000);

      if (diff < 60) return `${diff}ç§’å‰`;
      if (diff < 3600) return `${Math.floor(diff / 60)}åˆ†é’Ÿå‰`;
      if (diff < 86400) return `${Math.floor(diff / 3600)}å°æ—¶å‰`;
      return `${Math.floor(diff / 86400)}å¤©å‰`;
    }

    function formatPublishTime(timestamp) {
      if (!timestamp) return 'æœªçŸ¥';

      // å¤„ç†ç§’çº§æ—¶é—´æˆ³
      const timestampMs = timestamp < 10000000000 ? timestamp * 1000 : timestamp;
      const date = new Date(timestampMs);
      const now = new Date();
      const diff = Math.floor((now - date) / 1000);

      if (diff < 60) return `${diff}ç§’å‰`;
      if (diff < 3600) return `${Math.floor(diff / 60)}åˆ†é’Ÿå‰`;
      if (diff < 86400) return `${Math.floor(diff / 3600)}å°æ—¶å‰`;
      if (diff < 2592000) return `${Math.floor(diff / 86400)}å¤©å‰`; // 30å¤©å†…
      if (diff < 31536000) return `${Math.floor(diff / 2592000)}æœˆå‰`; // 365å¤©å†…
      return `${Math.floor(diff / 31536000)}å¹´å‰`;
    }

    function getSignalTypeClass(signalType) {
      // æ–°ä¿¡å·ç±»å‹çš„é¢œè‰²æ ·å¼ï¼ˆåŸºäºå æ¯”é˜ˆå€¼ + çªç ´2%ï¼‰- ç»¿æ¶¨çº¢è·Œï¼ˆå›½é™…æ ‡å‡†ï¼‰
      switch (signalType) {
        case 'ğŸš€ è¶…é¢„æœŸæ‹‰ç›˜': return 'bg-gradient-to-r from-green-600 to-emerald-600';
        case 'ğŸš€ å¼ºæ‹‰ç›˜': return 'bg-gradient-to-r from-green-500 to-green-600';
        case 'ğŸ“ˆ æ‹‰ç›˜': return 'bg-gradient-to-r from-green-400 to-green-500';
        case 'âš ï¸ å¯èƒ½å‡æ‹‰ç›˜': return 'bg-gradient-to-r from-yellow-500 to-orange-500';
        case 'âŒ å‡æ‹‰ç›˜': return 'bg-slate-500';
        case 'âš ï¸ å‡ºè´§': return 'bg-gradient-to-r from-red-600 to-rose-600';
        case 'ğŸ’¥ è¶…é¢„æœŸä¸‹è·Œ': return 'bg-gradient-to-r from-red-600 to-rose-600';
        case 'âš ï¸ æ´—ç›˜': return 'bg-gradient-to-r from-orange-500 to-orange-600';
        case 'ğŸ”» ä¸‹è·Œ': return 'bg-gradient-to-r from-red-400 to-red-500';
        case 'âš ï¸ å¯èƒ½å‡ç ¸ç›˜': return 'bg-gradient-to-r from-orange-400 to-orange-500';
        case 'âŒ å‡ç ¸ç›˜': return 'bg-slate-500';
        default: return 'bg-slate-600';
      }
    }

    function getSignalTypeText(signalType) {
      // æ–°ä¿¡å·ç±»å‹çš„æ–‡æœ¬ï¼ˆå¦‚æœå·²ç»æ˜¯æ–°ç±»å‹ï¼Œç›´æ¥è¿”å›ï¼‰
      const signalTypes = [
        'ğŸš€ è¶…é¢„æœŸæ‹‰ç›˜',
        'ğŸš€ å¼ºæ‹‰ç›˜',
        'ğŸ“ˆ æ‹‰ç›˜',
        'âš ï¸ å¯èƒ½å‡æ‹‰ç›˜',
        'âŒ å‡æ‹‰ç›˜',
        'âš ï¸ å‡ºè´§',
        'ğŸ’¥ è¶…é¢„æœŸä¸‹è·Œ',
        'âš ï¸ æ´—ç›˜',
        'ğŸ”» ä¸‹è·Œ',
        'âš ï¸ å¯èƒ½å‡ç ¸ç›˜',
        'âŒ å‡ç ¸ç›˜'
      ];
      if (signalTypes.includes(signalType)) {
        return signalType;
      }

      // å…¼å®¹æ—§çš„strategyç±»å‹ï¼ˆä¸»æ‹‰ã€ä¸»ç ¸ã€èµ„æ‹‰ã€èµ„ç ¸ï¼‰
      switch (signalType) {
        case 'main_up': return 'ğŸš€ æ‹‰ç›˜';
        case 'main_down': return 'ğŸ’¥ ç ¸ç›˜';
        case 'fund_up': return 'ğŸš€ æ‹‰ç›˜';
        case 'fund_down': return 'ğŸ’¥ ç ¸ç›˜';
        default: return signalType || 'æœªçŸ¥';
      }
    }

    // ==================== åˆå§‹åŒ–å’Œè‡ªåŠ¨åˆ·æ–° ====================

    async function refreshAll() {
      try {
        addLog('info', 'ğŸ”„ å¼€å§‹åˆ·æ–°æ‰€æœ‰æ•°æ®...');
        updateAPIStatus('connecting', 'APIè¿æ¥ä¸­');
        updateProgress(0, 6);

        let completed = 0;
        let hasError = false;

        // ä¼˜å…ˆè·å–é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹æ•°æ®
        try {
          await fetchImportantSymbolsData();
        } catch (e) {
          addLog('warning', 'é‡ç‚¹å…³æ³¨äº¤æ˜“å¯¹æ•°æ®åˆ·æ–°å¤±è´¥', e.message);
        }

        // å¸å®‰API
        try {
          await fetchBinancePrices();
        } catch (e) {
          addLog('error', 'å¸å®‰APIåˆ·æ–°å¤±è´¥', e.message);
          hasError = true;
        }
        completed++;
        updateProgress(completed, 6);

        // ğŸš€ ä¼˜å…ˆåŠ è½½ä¿¡å·ç›‘æ§å’Œå¸‚åœºçƒ­åº¦äº¤æ˜“å¯¹è¯¦æƒ…
        try {
          await fetchPrioritySymbolsData();
        } catch (e) {
          addLog('warning', 'ä¼˜å…ˆåŠ è½½äº¤æ˜“å¯¹è¯¦æƒ…å¤±è´¥', e.message);
        }
        completed++;
        updateProgress(completed, 6);

        // æ–°é—»API
        try {
          await Promise.all([
            fetchNews(),
            fetchHotNews(),
            fetchKolOpinions()
          ]);
        } catch (e) {
          addLog('error', 'æ–°é—»APIåˆ·æ–°å¤±è´¥', e.message);
          hasError = true;
        }
        completed += 3;
        updateProgress(completed, 6);

        // å¼‚åŠ¨åˆ†æï¼ˆåå°ç»§ç»­åˆ†æï¼Œä¸é˜»å¡UIï¼‰
        try {
          await fetchAnomalySignals();
        } catch (e) {
          addLog('error', 'å¼‚åŠ¨åˆ†æå¤±è´¥', e.message);
          hasError = true;
        }
        completed++;
        updateProgress(completed, 6);

        // æ›´æ–°UI
        updateLastUpdateTime();
        updateNewsView();
        
        // æ ¹æ®æ˜¯å¦æœ‰é”™è¯¯è®¾ç½®çŠ¶æ€
        if (hasError) {
          updateAPIStatus('success', 'APIæ­£å¸¸ï¼ˆéƒ¨åˆ†å¤±è´¥ï¼‰');
        } else {
          updateAPIStatus('success', 'APIæ­£å¸¸');
        }
        hideProgress();

        addLog('success', 'âœ… æ‰€æœ‰æ•°æ®åˆ·æ–°å®Œæˆ');
      } catch (error) {
        addLog('error', 'æ•°æ®åˆ·æ–°å¤±è´¥', error.message);
        updateAPIStatus('error', 'APIå¼‚å¸¸');
        hideProgress();
        updateLastUpdateTime();
      }
    }

    // ==================== è§¦æ‘¸æ»‘åŠ¨åŠŸèƒ½ ====================
    let touchStartX = 0;
    let touchStartY = 0;

    function handleTouchStart(e) {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }

    function handleTouchEnd(e) {
      const touchEndX = e.changedTouches[0].screenX;
      const touchEndY = e.changedTouches[0].screenY;
      const diffX = touchStartX - touchEndX;
      const diffY = touchStartY - touchEndY;

      // åªæœ‰å½“æ¨ªå‘æ»‘åŠ¨è·ç¦»å¤§äºçºµå‘æ»‘åŠ¨è·ç¦»æ—¶ï¼Œæ‰å¤„ç†ä¸ºæ¨ªå‘æ»‘åŠ¨
      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 30) {
        // åœ¨æ–°é—»å†…å®¹åŒºåŸŸè¿›è¡Œæ¨ªå‘æ»šåŠ¨ï¼ˆæ¯æ¬¡æ»šåŠ¨ä¸€é¡µï¼‰
        const activeContent = document.querySelector('#newsContent > div:not(.hidden)');
        if (activeContent) {
          // è·å–è§†å£å®½åº¦å‡å»è¾¹è·
          const pageWidth = window.innerWidth - 32; // 100vw - 2rem
          const scrollAmount = Math.round(diffX / pageWidth) * pageWidth || (diffX > 0 ? pageWidth : -pageWidth);
          activeContent.scrollBy({
            left: scrollAmount,
            behavior: 'smooth'
          });
        }
      }
    }

    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    window.addEventListener('DOMContentLoaded', async () => {
      addLog('info', 'ğŸš€ é¡µé¢åˆå§‹åŒ–å¼€å§‹...');

      // åˆå§‹åŒ–ä¸»é¢˜
      initTheme();
      addLog('info', 'ğŸ¨ ä¸»é¢˜ç³»ç»Ÿå·²åŠ è½½');

      // æ¸…ç†è¿‡æœŸæ•°æ®
      cleanExpiredData();

      // åŠ è½½å†å²æ•°æ®
      loadApiKey();
      loadLogs();
      loadAnomalySignals();
      loadNewsData();
      loadTickerData();

      addLog('info', 'ğŸ“¡ ç›‘æ§æ—¥å¿—ç³»ç»Ÿå·²å¯åŠ¨');
      addLog('info', 'ğŸŒ Followinå®˜ç½‘: https://followin.io');
      addLog('info', 'ğŸ”‘ å·²é¢„ç½®Followin API Keyï¼Œæ–°é—»åŠŸèƒ½å¯æ­£å¸¸ä½¿ç”¨');
      addLog('info', 'ğŸ’¡ è·å–è‡ªå®šä¹‰API Key: è®¿é—®å®˜ç½‘ -> ä¸ªäººä¸­å¿ƒ -> å¼€å‘è€…è®¾ç½®');
      addLog('info', 'ğŸ’¾ æ•°æ®æŒä¹…åŒ–å·²å¯ç”¨ï¼Œå†å²æ•°æ®è‡ªåŠ¨ä¿å­˜ï¼ˆ24å°æ—¶è¿‡æœŸï¼‰');

      // ä¸ºæ–°é—»å†…å®¹å®¹å™¨æ·»åŠ è§¦æ‘¸æ»‘åŠ¨äº‹ä»¶
      const newsSection = document.getElementById('news-section');
      if (newsSection) {
        newsSection.addEventListener('touchstart', handleTouchStart, { passive: true });
        newsSection.addEventListener('touchend', handleTouchEnd, { passive: true });
      }

      // åˆå§‹åŒ–ç»¼åˆä¿¡æ¯æ¿å—
      await refreshMarketData();

      // é¢„åŠ è½½ä¿¡å·ç›‘æ§å’Œå¸‚åœºçƒ­åº¦æ¿å—äº¤æ˜“å¯¹
      setTimeout(() => {
        const allPrioritySymbols = new Set();

        // 1. ä¼˜å…ˆæ·»åŠ ä¿¡å·ç›‘æ§æ¿å—çš„æ‰€æœ‰äº¤æ˜“å¯¹ï¼ˆå¼‚åŠ¨ä¿¡å·ï¼‰
        if (anomalySignals && anomalySignals.length > 0) {
          anomalySignals.forEach(signal => {
            allPrioritySymbols.add(signal.symbol);
          });
          addLog('info', `ğŸ¯ æ·»åŠ ä¿¡å·ç›‘æ§äº¤æ˜“å¯¹: ${anomalySignals.length} ä¸ª`);
        }

        // 2. çƒ­é—¨æœç´¢Top 10ï¼ˆä»localStorageåŠ è½½ï¼‰
        const marketData = loadMarketData();
        const trendingCoins = marketData.trendingCoins || [];
        if (trendingCoins && trendingCoins.length > 0) {
          trendingCoins.slice(0, 10).forEach(coin => {
            const symbol = coin.symbol || (coin.item && coin.item.symbol);
            if (symbol) allPrioritySymbols.add(symbol + 'USDT');
          });
        }
        
        // 3. æ¶¨å¹…æ¦œTop 10
        if (binancePrices && binancePrices.length > 0) {
          const topGainers = binancePrices
            .sort((a, b) => b.priceChangePercent - a.priceChangePercent)
            .slice(0, 10);
          topGainers.forEach(p => allPrioritySymbols.add(p.symbol));
        }
        
        // 4. æˆäº¤é‡æ¦œTop 10
        if (binancePrices && binancePrices.length > 0) {
          const topVolume = binancePrices
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, 10);
          topVolume.forEach(p => allPrioritySymbols.add(p.symbol));
        }
        
        const symbolsArray = Array.from(allPrioritySymbols);
        if (symbolsArray.length > 0) {
          console.log('[Init] é¢„åŠ è½½ä¼˜å…ˆäº¤æ˜“å¯¹ï¼ˆä¿¡å·ç›‘æ§ + å¸‚åœºçƒ­åº¦æ¿å—ï¼Œå»é‡åï¼‰:', symbolsArray);
          cacheManager.preloadHotSymbols(symbolsArray);
        }
      }, 2000);  // å»¶è¿Ÿ2ç§’ï¼Œé¿å…ä¸ä¸»æ•°æ®åˆ·æ–°å†²çª

      await refreshAll();

      // æ¯5åˆ†é’Ÿè‡ªåŠ¨åˆ·æ–°
      setInterval(refreshAll, 300000);

      // æ¯30ç§’åˆ·æ–°ç»¼åˆä¿¡æ¯æ•°æ®
      setInterval(refreshMarketData, 30000);

      // æ¯å°æ—¶æ¸…ç†è¿‡æœŸæ•°æ®
      setInterval(cleanExpiredData, 3600000);
    });
  </script>
</body>
</html>
